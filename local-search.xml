<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端批量下载图片并统一转换格式的最佳实践</title>
    <link href="/2025/05/04/%E5%89%8D%E7%AB%AF%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87%E5%B9%B6%E7%BB%9F%E4%B8%80%E8%BD%AC%E6%8D%A2%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/05/04/%E5%89%8D%E7%AB%AF%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87%E5%B9%B6%E7%BB%9F%E4%B8%80%E8%BD%AC%E6%8D%A2%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="前端批量下载图片并统一转换格式的最佳实践"><a href="#前端批量下载图片并统一转换格式的最佳实践" class="headerlink" title="前端批量下载图片并统一转换格式的最佳实践"></a>前端批量下载图片并统一转换格式的最佳实践</h1><p>在现代 Web 应用中，用户经常有批量下载图片的需求。比如：将页面上的多张图片打包成 zip 文件下载，或者统一转换为更高效的图片格式（如 webp、jpeg）以节省存储和带宽。本文将带你深入了解如何用 JavaScript 实现这一功能，并重点讲解 <code>createImageBitmap</code> 的优势和使用场景。</p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><p>假设我们有一组图片 URL，用户希望一键下载所有图片，并且希望所有图片都被统一转换为 webp 或 jpeg 格式，最后打包成 zip 文件。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ul><li><strong>JSZip</strong>：用于在前端生成 zip 文件。</li><li><strong>canvas</strong>：用于图片格式转换。</li><li><strong>createImageBitmap</strong>：高效解码图片，便于绘制到 canvas。</li><li><strong>fetch</strong>：获取图片二进制数据。</li></ul><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><ol><li><strong>批量 fetch</strong>：将每个图片 URL 对应的二进制数据（Blob）拉取到前端。</li><li><strong>解码为 ImageBitmap</strong>：通过 createImageBitmap(blob) 异步解码，不阻塞主线程。</li><li><strong>绘制与格式转换</strong>：在（Offscreen）Canvas 上用 drawImage 渲染图像，再用 toBlob 或 convertToBlob 导出指定格式（webp&#x2F;jpeg）和质量。</li><li><strong>打包 ZIP</strong>：借助 JSZip，按文件名和格式将每个 Blob 添加到 ZIP。</li><li><strong>触发下载</strong>：生成 ZIP Blob 后，构造临时链接 <a> 并自动点击下载。</li></ol><h2 id="关键代码实现"><a href="#关键代码实现" class="headerlink" title="关键代码实现"></a>关键代码实现</h2><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">JSZip</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jszip&#x27;</span>;<br><br><span class="hljs-comment">// 批量下载并转换图片为指定格式</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">downloadImagesZip</span> = (<span class="hljs-params"><span class="hljs-attr">images</span>: <span class="hljs-built_in">string</span>[], <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;webp&#x27;</span> | <span class="hljs-string">&#x27;jpeg&#x27;</span> = <span class="hljs-string">&#x27;webp&#x27;</span></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> zip = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSZip</span>();<br>  <span class="hljs-keyword">const</span> folder = zip.<span class="hljs-title function_">folder</span>(<span class="hljs-string">&#x27;images&#x27;</span>);<br><br>  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<br>    images.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">async</span> imgUrl =&gt; &#123;<br>      <span class="hljs-comment">// 1. 获取图片 Blob</span><br>      <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(imgUrl);<br>      <span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">blob</span>();<br><br>      <span class="hljs-comment">// 2. 解码为 ImageBitmap</span><br>      <span class="hljs-keyword">const</span> imageBitmap = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createImageBitmap</span>(blob);<br><br>      <span class="hljs-comment">// 3. 绘制到 canvas 并导出为目标格式</span><br>      <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;canvas&#x27;</span>);<br>      canvas.<span class="hljs-property">width</span> = imageBitmap.<span class="hljs-property">width</span>;<br>      canvas.<span class="hljs-property">height</span> = imageBitmap.<span class="hljs-property">height</span>;<br>      <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);<br>      ctx?.<span class="hljs-title function_">drawImage</span>(imageBitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>      <span class="hljs-comment">// 4. 转为 webp 或 jpeg Blob</span><br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">outBlob</span>: <span class="hljs-title class_">Blob</span> = <span class="hljs-keyword">await</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span><br>        canvas.<span class="hljs-title function_">toBlob</span>(<span class="hljs-function"><span class="hljs-params">b</span> =&gt;</span> <span class="hljs-title function_">resolve</span>(b <span class="hljs-keyword">as</span> <span class="hljs-title class_">Blob</span>), <span class="hljs-string">`image/<span class="hljs-subst">$&#123;format&#125;</span>`</span>)<br>      );<br><br>      <span class="hljs-comment">// 5. 添加到 zip</span><br>      <span class="hljs-keyword">const</span> name = imgUrl.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;/&#x27;</span>).<span class="hljs-title function_">pop</span>()?.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\.\\w+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>) || <span class="hljs-string">&#x27;image&#x27;</span>;<br>      folder?.<span class="hljs-title function_">file</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span>.<span class="hljs-subst">$&#123;format&#125;</span>`</span>, outBlob);<br>    &#125;)<br>  ).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 6. 生成并下载 zip</span><br>    zip.<span class="hljs-title function_">generateAsync</span>(&#123; <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;blob&#x27;</span> &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">content</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>      a.<span class="hljs-property">href</span> = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(content);<br>      a.<span class="hljs-property">download</span> = <span class="hljs-string">`images.zip`</span>;<br>      a.<span class="hljs-title function_">click</span>();<br>      <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(a.<span class="hljs-property">href</span>);<br>    &#125;);<br>  &#125;);<br>&#125;;<br><br></code></pre></td></tr></table></figure><h2 id="为什么要用-createImageBitmap？"><a href="#为什么要用-createImageBitmap？" class="headerlink" title="为什么要用 createImageBitmap？"></a>为什么要用 createImageBitmap？</h2><h3 id="1-性能更优"><a href="#1-性能更优" class="headerlink" title="1. 性能更优"></a>1. 性能更优</h3><p><code>createImageBitmap</code> 是异步的，不会阻塞主线程，适合批量处理图片。相比 <code>&lt;img&gt;</code> 标签+onload 的传统方式，解码速度更快，体验更流畅。</p><h3 id="2-代码更简洁"><a href="#2-代码更简洁" class="headerlink" title="2. 代码更简洁"></a>2. 代码更简洁</h3><p>无需创建和管理 <code>&lt;img&gt;</code> 元素，也不用处理 onload、URL 回收等繁琐细节。直接 await 得到 bitmap，马上就能绘制到 canvas。</p><h3 id="3-灵活性更高"><a href="#3-灵活性更高" class="headerlink" title="3. 灵活性更高"></a>3. 灵活性更高</h3><p>支持多种图片源（Blob、File、ImageData、Canvas等），不仅限于 URL。</p><h3 id="4-避免-DOM-污染"><a href="#4-避免-DOM-污染" class="headerlink" title="4. 避免 DOM 污染"></a>4. 避免 DOM 污染</h3><p>不需要在页面上插入临时 <code>&lt;img&gt;</code> 元素，减少内存泄漏和 DOM 污染的风险。</p><h3 id="传统方式（不推荐）："><a href="#传统方式（不推荐）：" class="headerlink" title="传统方式（不推荐）："></a>传统方式（不推荐）：</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> imgEl = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>imgEl.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  ctx.<span class="hljs-title function_">drawImage</span>(imgEl, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>&#125;;<br>imgEl.<span class="hljs-property">src</span> = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);<br><br></code></pre></td></tr></table></figure><h3 id="推荐方式（现代浏览器）："><a href="#推荐方式（现代浏览器）：" class="headerlink" title="推荐方式（现代浏览器）："></a>推荐方式（现代浏览器）：</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> imageBitmap = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createImageBitmap</span>(blob);<br>ctx.<span class="hljs-title function_">drawImage</span>(imageBitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br></code></pre></td></tr></table></figure><h2 id="兼容性说明"><a href="#兼容性说明" class="headerlink" title="兼容性说明"></a>兼容性说明</h2><ul><li><code>createImageBitmap</code> 支持主流现代浏览器（Chrome、Firefox、Edge、Safari）。</li><li>如果需要兼容 IE 或极老旧浏览器，可以降级为 <code>&lt;img&gt;</code> 标签方式，但建议优先使用 <code>createImageBitmap</code>。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过 <code>createImageBitmap</code> + <code>canvas</code> + <code>JSZip</code>，我们可以高效地实现前端批量图片下载与格式统一转换。这样不仅提升了用户体验，还能有效节省带宽和存储空间。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web API</tag>
      
      <tag>JavaScript</tag>
      
      <tag>性能优化</tag>
      
      <tag>前端</tag>
      
      <tag>图片处理</tag>
      
      <tag>Canvas</tag>
      
      <tag>文件下载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端魔法解密：深入理解 File、Blob 与 Object URL</title>
    <link href="/2025/05/04/%E5%89%8D%E7%AB%AF%E9%AD%94%E6%B3%95%E8%A7%A3%E5%AF%86%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-File%E3%80%81Blob-%E4%B8%8E-Object-URL/"/>
    <url>/2025/05/04/%E5%89%8D%E7%AB%AF%E9%AD%94%E6%B3%95%E8%A7%A3%E5%AF%86%EF%BC%9A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-File%E3%80%81Blob-%E4%B8%8E-Object-URL/</url>
    
    <content type="html"><![CDATA[<h2 id="前端魔法解密：深入理解-File、Blob-与-Object-URL"><a href="#前端魔法解密：深入理解-File、Blob-与-Object-URL" class="headerlink" title="前端魔法解密：深入理解 File、Blob 与 Object URL"></a>前端魔法解密：深入理解 File、Blob 与 Object URL</h2><p>在现代 Web 开发中，处理用户上传的文件（尤其是图片）并在前端进行展示或处理是一项常见任务。无论是实现图片预览、客户端裁剪、添加滤镜，还是将数据上传到服务器，我们都离不开对这些二进制数据的操作。然而，<code>File</code> 对象、<code>Blob</code> 对象以及 <code>URL.createObjectURL()</code> 之间的关系常常让开发者感到困惑。</p><p>本文将深入探讨这三者的概念、关系以及最佳实践，帮助你自信地在项目中处理文件和二进制数据。</p><h3 id="1-数据的基石：File-与-Blob-对象"><a href="#1-数据的基石：File-与-Blob-对象" class="headerlink" title="1. 数据的基石：File 与 Blob 对象"></a>1. 数据的基石：<code>File</code> 与 <code>Blob</code> 对象</h3><p>首先，我们需要理解两个核心的 JavaScript 对象：</p><ul><li><strong><code>Blob</code> (Binary Large Object):</strong> 这是 Web 平台上表示<strong>原始二进制数据</strong>的基础构建块。你可以把它想象成一个只读的、包含一堆字节数据的”容器”。这个容器里的数据可以是图片、音频、视频、JSON、或者任何其他格式的二进制流。<code>Blob</code> 对象本身包含两个主要属性：<code>size</code>（数据的大小，以字节为单位）和 <code>type</code> (数据的 MIME 类型，例如 <code>&#39;image/jpeg&#39;</code>)。</li><li><strong><code>File</code> 对象:</strong> <code>File</code> 对象是一种特殊的 <code>Blob</code>。它继承了 <code>Blob</code> 的所有属性和方法，并额外添加了一些文件系统相关的<strong>元数据</strong>，如：<ul><li><code>name</code>: 文件名字符串。</li><li><code>lastModified</code>: 文件最后修改时间的时间戳。</li></ul></li></ul><p>当你使用 <code>&lt;input type=&quot;file&quot;&gt;</code> 允许用户选择本地文件时，浏览器就会为用户选择的每个文件创建一个 <code>File</code> 对象。同样，当你通过 <code>fetch</code> API 请求一个资源并使用 <code>response.blob()</code> 时，你会得到一个 <code>Blob</code> 对象。</p><p><strong>数据存放在哪里？</strong></p><p>一个常见的误解是这些数据存储在 JavaScript 的堆内存中。实际上，当 <code>File</code> 或 <code>Blob</code> 对象被创建时，它们所代表的<strong>原始二进制数据通常被加载并存储在浏览器进程自身管理的内存区域中</strong>。你的 JavaScript 代码持有对这个 <code>File</code>&#x2F;<code>Blob</code> 对象的引用，但实际的字节数据由浏览器更底层地管理。这块内存是<strong>临时</strong>的，与你的网页标签页生命周期相关联，并且不是持久化存储（除非你使用 IndexedDB 等 API）。</p><h3 id="2-内存数据的”门牌号”：URL-createObjectURL"><a href="#2-内存数据的”门牌号”：URL-createObjectURL" class="headerlink" title="2. 内存数据的”门牌号”：URL.createObjectURL()"></a>2. 内存数据的”门牌号”：<code>URL.createObjectURL()</code></h3><p>现在，我们有了表示内存中数据的 <code>File</code> 或 <code>Blob</code> 对象。但很多时候，我们需要一个 URL 字符串才能将这些数据用在某些地方，比如 <code>&lt;img&gt;</code> 标签的 <code>src</code> 属性。这时，<code>URL.createObjectURL()</code> 就派上用场了。</p><p>当你调用 <code>URL.createObjectURL(yourFileOrBlob)</code> 时：</p><ol><li><strong>不会复制数据:</strong> 它并不会创建原始数据的副本。</li><li><strong>创建临时引用:</strong> 浏览器会在其内部维护的一个 <strong>URL 映射表</strong>中创建一个<strong>新的、唯一的条目</strong>。</li><li><strong>生成特殊 URL:</strong> 这个条目包含一个格式通常为 <code>blob:http://&lt;origin&gt;/&lt;uuid&gt;</code> 的 URL 字符串（我们称之为 Object URL 或 Blob URL）。</li><li><strong>指向原始数据:</strong> 最重要的是，这个 URL <strong>指向</strong>（引用）你传入的那个 <code>File</code> 或 <code>Blob</code> 对象所代表的、<strong>已存在于浏览器内存中的原始数据</strong>。</li></ol><p>所以，**Object URL 本质上就是内存中那块二进制数据的一个临时的、唯一的”门牌号”或”快捷方式”**。浏览器看到这种 <code>blob:</code> URL 时，就知道该去内部的映射表查找对应的数据来使用。</p><table><thead><tr><th>特性</th><th>File&#x2F;Blob 对象</th><th>URL.createObjectURL() 返回的 URL</th></tr></thead><tbody><tr><td>本质</td><td>JavaScript 对象，代表浏览器内存中的数据</td><td>一个临时的字符串，是到内存中数据的引用&#x2F;指针&#x2F;门牌号</td></tr><tr><td>数据位置</td><td>浏览器管理的内存区域</td><td>指向上述内存区域</td></tr><tr><td>生命周期</td><td>由 JavaScript 的引用计数决定（标准 GC）</td><td>临时，与创建它的文档相关联，需要手动调用 revokeObjectURL 释放</td></tr><tr><td>用途</td><td>直接传递给 API (createImageBitmap, FormData, FileReader)</td><td>用于需要 URL 字符串的地方 (img.src, a.href, fetch(url))</td></tr><tr><td>内存管理</td><td>自动（垃圾回收）</td><td>需要手动释放 (revokeObjectURL)，否则可能导致内存泄漏</td></tr></tbody></table><h3 id="3-如何使用这些数据？"><a href="#3-如何使用这些数据？" class="headerlink" title="3. 如何使用这些数据？"></a>3. 如何使用这些数据？</h3><p>有了 <code>File</code>&#x2F;<code>Blob</code> 对象和可能的 Object URL，我们来看看常见的应用场景：</p><p><strong>场景一：在 <code>&lt;img&gt;</code> 标签中显示图片</strong></p><p>这是 Object URL 最常见的用途。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 假设 &#x27;imageFile&#x27; 是一个 File 或 Blob 对象</span><br><span class="hljs-keyword">const</span> imageUrl = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(imageFile);<br><span class="hljs-keyword">const</span> imgElement = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;img&#x27;</span>);<br><br>imgElement.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;图片加载成功!&#x27;</span>);<br>  <span class="hljs-comment">// 图片加载完成，可以进行后续操作</span><br>  <span class="hljs-comment">// **关键：不再需要 URL 时，释放它！**</span><br>  <span class="hljs-comment">// 但这里要注意，如果 img 标签还在 DOM 中显示，不能立即释放</span><br>  <span class="hljs-comment">// 最好在图片不再显示或组件卸载时释放</span><br>  <span class="hljs-comment">// URL.revokeObjectURL(imageUrl);</span><br>&#125;;<br><br>imgElement.<span class="hljs-property">onerror</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;图片加载失败!&#x27;</span>);<br>  <span class="hljs-comment">// 加载失败也要释放</span><br>  <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(imageUrl);<br>&#125;;<br><br>imgElement.<span class="hljs-property">src</span> = imageUrl;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(imgElement); <span class="hljs-comment">// 将图片添加到页面</span><br><br><span class="hljs-comment">// 清理示例：假设图片不再需要时调用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanupImage</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (imageUrl) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;释放 Object URL:&#x27;</span>, imageUrl);<br>    <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(imageUrl);<br>    <span class="hljs-comment">// imgElement.remove(); // 从 DOM 移除</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>关键点:</strong> <code>URL.createObjectURL()</code> 创建的 URL 会一直占用内存，直到文档被卸载或者你明确调用 <code>URL.revokeObjectURL(objectUrl)</code> 来释放它。<strong>忘记释放是常见的内存泄漏来源！</strong></p><p><strong>场景二：在 <code>&lt;canvas&gt;</code> 中处理图片 (使用 <code>createImageBitmap</code>)</strong></p><p><code>createImageBitmap()</code> 是一个更现代、更高效的 API，用于将各种图像源（包括 <code>Blob</code>, <code>File</code>, <code>ImageData</code>, <code>HTMLImageElement</code> 等）异步解码为 <code>ImageBitmap</code> 对象，该对象可以高效地绘制到 Canvas 上。</p><ul><li><p><strong>最佳方式：直接使用 <code>File</code>&#x2F;<code>Blob</code></strong></p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 假设 &#x27;imageFile&#x27; 是一个 File 或 Blob 对象</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">drawToCanvas</span>(<span class="hljs-params">imageFile</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> imageBitmap = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createImageBitmap</span>(imageFile);<br>    <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myCanvas&#x27;</span>); <span class="hljs-comment">// 获取你的 Canvas</span><br>    <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);<br><br>    canvas.<span class="hljs-property">width</span> = imageBitmap.<span class="hljs-property">width</span>;<br>    canvas.<span class="hljs-property">height</span> = imageBitmap.<span class="hljs-property">height</span>;<br>    ctx.<span class="hljs-title function_">drawImage</span>(imageBitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;图片已使用 ImageBitmap 绘制到 Canvas&#x27;</span>);<br><br>    <span class="hljs-comment">// ImageBitmap 如果不再需要，可以关闭以提前释放资源 (可选)</span><br>    imageBitmap.<span class="hljs-title function_">close</span>();<br><br>    <span class="hljs-comment">// 注意：因为我们直接用了 Blob/File，没有创建 Object URL，所以不需要 revoke！</span><br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;创建或绘制 ImageBitmap 失败:&#x27;</span>, error);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">drawToCanvas</span>(imageFile);<br><br></code></pre></td></tr></table></figure><p>  这是最推荐的方式，因为它避免了创建和管理 Object URL 的复杂性。</p></li><li><p><strong>次优方式：如果你只有 Object URL</strong></p><p>  如果你因为某种原因只存储了 Object URL 字符串，你需要先用 <code>fetch</code> 将其转换回 <code>Blob</code>。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// 假设 &#x27;imageUrl&#x27; 是一个通过 URL.createObjectURL 创建的 blob: URL</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">drawToCanvasFromUrl</span>(<span class="hljs-params">imageUrl</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(imageUrl);<br>    <span class="hljs-keyword">const</span> imageBlob = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">blob</span>(); <span class="hljs-comment">// 通过 fetch 获取 Blob</span><br>    <span class="hljs-keyword">const</span> imageBitmap = <span class="hljs-keyword">await</span> <span class="hljs-title function_">createImageBitmap</span>(imageBlob); <span class="hljs-comment">// 再创建 ImageBitmap</span><br><br>    <span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);<br>    <span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);<br><br>    canvas.<span class="hljs-property">width</span> = imageBitmap.<span class="hljs-property">width</span>;<br>    canvas.<span class="hljs-property">height</span> = imageBitmap.<span class="hljs-property">height</span>;<br>    ctx.<span class="hljs-title function_">drawImage</span>(imageBitmap, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;图片已通过 fetch + ImageBitmap 绘制到 Canvas&#x27;</span>);<br>    imageBitmap.<span class="hljs-title function_">close</span>();<br><br>  &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;处理图片失败:&#x27;</span>, error);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// **关键：即使处理成功或失败，都要释放原始的 Object URL！**</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;释放 Object URL:&#x27;</span>, imageUrl);<br>    <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(imageUrl);<br>  &#125;<br>&#125;<br><br><span class="hljs-title function_">drawToCanvasFromUrl</span>(imageUrl);<br><br></code></pre></td></tr></table></figure></li><li><p><strong>传统方式：通过 <code>&lt;img&gt;</code> 元素中转</strong></p><p>  你也可以先将 Object URL 加载到 <code>&lt;img&gt;</code> 元素，然后在 <code>onload</code> 事件中将该 <code>&lt;img&gt;</code> 元素绘制到 Canvas。</p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-comment">// (代码类似场景一，在 img.onload 中增加 ctx.drawImage(imgElement, 0, 0) 逻辑)</span><br><span class="hljs-comment">// 同样需要注意 revokeObjectURL 的时机。</span><br><br></code></pre></td></tr></table></figure></li></ul><h3 id="4-最佳实践：该存储什么？File-Blob-还是-Object-URL"><a href="#4-最佳实践：该存储什么？File-Blob-还是-Object-URL" class="headerlink" title="4. 最佳实践：该存储什么？File&#x2F;Blob 还是 Object URL?"></a>4. 最佳实践：该存储什么？<code>File</code>&#x2F;<code>Blob</code> 还是 Object URL?</h3><p>基于以上讨论，我们可以得出结论：</p><p><strong>优先直接存储 <code>File</code> 或 <code>Blob</code> 对象。</strong></p><p>理由：</p><ol><li><strong>简单的内存管理:</strong> JavaScript 的垃圾回收机制会自动处理 <code>File</code>&#x2F;<code>Blob</code> 对象的内存。当你的代码不再持有对这些对象的引用时（例如，React 组件卸载，变量被覆盖），内存会被回收。你无需担心手动调用 <code>revokeObjectURL</code>。</li><li><strong>直接访问数据:</strong> 你可以方便地访问 <code>File</code> 对象的 <code>name</code>, <code>size</code>, <code>type</code> 等属性，或直接将 <code>File</code>&#x2F;<code>Blob</code> 对象传递给 <code>FileReader</code>, <code>createImageBitmap</code>, <code>FormData</code> (用于上传) 等 API。</li><li><strong>生命周期更可控:</strong> 只要你的 JavaScript 代码持有引用，<code>File</code>&#x2F;<code>Blob</code> 对象就是有效的。Object URL 则与创建它的文档绑定，且是临时的。</li></ol><p><strong>那么何时使用 Object URL？</strong></p><p><strong>主要用于临时场景</strong>，当你需要一个 URL 字符串提供给那些只接受 URL 的 Web API 时，比如：</p><ul><li>设置 <code>&lt;img&gt;</code> 的 <code>src</code> 属性。</li><li>设置 <code>&lt;a&gt;</code> 的 <code>href</code> 属性以供下载 (<code>&lt;a href=&#123;objectUrl&#125; download=&quot;filename.png&quot;&gt;</code>)。</li><li>作为 CSS <code>background-image: url()</code> 的值。</li></ul><p>在这些情况下，你应该：</p><ol><li><strong>临时创建:</strong> 在需要时根据你存储的 <code>File</code>&#x2F;<code>Blob</code> 对象创建 Object URL。</li><li><strong>及时释放:</strong> 在不再需要该 URL 时（例如，组件卸载、图片更换、下载链接点击后），**务必调用 <code>URL.revokeObjectURL()</code>**。</li></ol><p><strong>React 示例 (存储 File，临时创建 URL)：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ImagePreview</span>(<span class="hljs-params">&#123; file &#125;: &#123; file: File | <span class="hljs-literal">null</span> &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> [imageUrl, setImageUrl] = useState&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!file) &#123;<br>      <span class="hljs-title function_">setImageUrl</span>(<span class="hljs-literal">null</span>);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 1. 临时创建 Object URL</span><br>    <span class="hljs-keyword">const</span> objectUrl = <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">createObjectURL</span>(file);<br>    <span class="hljs-title function_">setImageUrl</span>(objectUrl);<br><br>    <span class="hljs-comment">// 2. 返回清理函数，在卸载或 file 变化时释放</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Revoking Object URL:&#x27;</span>, objectUrl);<br>      <span class="hljs-variable constant_">URL</span>.<span class="hljs-title function_">revokeObjectURL</span>(objectUrl);<br>    &#125;;<br>  &#125;, [file]); <span class="hljs-comment">// 依赖 file</span><br><br>  <span class="hljs-keyword">if</span> (!imageUrl) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>No image selected<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;imageUrl&#125;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&#123;file?.name</span> || &#x27;<span class="hljs-attr">preview</span>&#x27;&#125; <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">maxWidth:</span> &#x27;<span class="hljs-attr">100</span>%&#x27; &#125;&#125; /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [selectedFile, setSelectedFile] = useState&lt;<span class="hljs-title class_">File</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleFileChange</span> = (<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-title class_">React</span>.<span class="hljs-title class_">ChangeEvent</span>&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;</span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span>.<span class="hljs-property">files</span> &amp;&amp; event.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]) &#123;<br>      <span class="hljs-title function_">setSelectedFile</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">files</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 直接存储 File 对象</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">setSelectedFile</span>(<span class="hljs-literal">null</span>);<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span> <span class="hljs-attr">accept</span>=<span class="hljs-string">&quot;image/*&quot;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleFileChange&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ImagePreview</span> <span class="hljs-attr">file</span>=<span class="hljs-string">&#123;selectedFile&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br><br></code></pre></td></tr></table></figure><h3 id="5-性能考量"><a href="#5-性能考量" class="headerlink" title="5. 性能考量"></a>5. 性能考量</h3><ul><li>访问内存中的 <code>Blob</code> 数据（无论是直接访问还是通过 Object URL）通常是非常快的。</li><li><code>createImageBitmap</code> 相较于先加载到 <code>&lt;img&gt;</code> 再绘制到 Canvas，通常具有更好的性能，尤其是在 Worker 线程中使用时，因为它将解码工作移出了主线程。</li><li>主要的性能陷阱在于忘记 <code>revokeObjectURL</code> 导致的内存泄漏。</li></ul><h2 id="6-通过Fetch获取blob数据和使用已存在的Blob对象之间的区别"><a href="#6-通过Fetch获取blob数据和使用已存在的Blob对象之间的区别" class="headerlink" title="6.通过Fetch获取blob数据和使用已存在的Blob对象之间的区别"></a>6.通过Fetch获取blob数据和使用已存在的Blob对象之间的区别</h2><p><strong>在使用 <code>createImageBitmap</code> 时，通过 <code>fetch(url)</code> 获取 <code>Blob</code> 和直接使用已有的 <code>Blob</code> 对象之间存在区别，主要体现在效率和代码简洁性上</strong>。</p><p>虽然两种方式最终都是将内存中的同一份原始二进制数据传递给 <code>createImageBitmap</code> 进行解码，但它们的<strong>过程</strong>不同：</p><ol><li><strong>直接使用 <code>Blob</code> 对象 ( <code>createImageBitmap(yourBlob)</code> )</strong><ul><li><strong>过程:</strong> 你直接将 JavaScript 中已持有的 <code>Blob</code> 对象引用传递给 <code>createImageBitmap</code> API。</li><li><strong>效率:</strong> 这是<strong>最高效</strong>的方式。API 可以直接访问与该 <code>Blob</code> 引用关联的内存中的二进制数据，无需任何中间步骤。</li><li><strong>代码:</strong> 代码最简洁、直接。</li></ul></li><li><strong>通过 <code>fetch(objectUrl)</code> 获取 <code>Blob</code> ( <code>fetch(url).then(res =&gt; res.blob()).then(blob =&gt; createImageBitmap(blob))</code> )</strong><ul><li><strong>过程:</strong><ul><li>你提供一个 Object URL 字符串 (<code>blob:http://...</code>)。</li><li><code>fetch</code> 首先需要在浏览器内部的 URL 映射表中查找这个 URL，找到它指向的内存中的 <code>Blob</code> 数据。 (虽然这只是内存查找，不是网络请求，但仍有查找开销)。</li><li><code>fetch</code> 返回一个 <code>Response</code> 对象，其 body 是一个指向该 <code>Blob</code> 数据的流。</li><li>你调用 <code>response.blob()</code>, 这会读取 <code>Response</code> 对象中的流，并重新构造（或提供一个引用给）一个 <code>Blob</code> 对象给你的 JavaScript 代码。</li><li>最后，你才将这个通过 <code>fetch</code> 得到的 <code>Blob</code> 对象传递给 <code>createImageBitmap</code>。</li></ul></li><li><strong>效率:</strong> 这是<strong>相对低效</strong>的方式。虽然最终处理的是同一块内存数据，但中间增加了 <code>fetch</code> 调用、<code>Response</code> 对象创建、以及从 <code>Response</code> 中提取 <code>Blob</code> 的开销。这些额外的步骤和至少一次额外的异步操作 (<code>.then()</code>) 增加了延迟和轻微的性能消耗。</li><li><strong>代码:</strong> 代码相对冗长，需要处理 <code>fetch</code> 的 Promise 链。</li></ul></li></ol><p><strong>总结:</strong></p><table><thead><tr><th>特性</th><th>直接使用 <code>Blob</code> (<code>createImageBitmap(blob)</code>)</th><th>通过 <code>fetch(url)</code> 获取 (<code>fetch...then(blob =&gt; createImageBitmap(blob))</code>)</th></tr></thead><tbody><tr><td><strong>数据源</strong></td><td>直接访问内存中的原始数据</td><td>通过 URL 引用间接访问内存中的<strong>相同</strong>原始数据</td></tr><tr><td><strong>效率</strong></td><td><strong>更高</strong> (最直接)</td><td><strong>较低</strong> (有 fetch、Response、提取 Blob 的开销)</td></tr><tr><td><strong>代码</strong></td><td><strong>更简洁</strong></td><td><strong>更冗长</strong></td></tr><tr><td><strong>最终结果</strong></td><td><code>ImageBitmap</code> 对象</td><td>功能上<strong>相同</strong>的 <code>ImageBitmap</code> 对象</td></tr></tbody></table><p><strong>结论：</strong></p><p>如果你手头<strong>已经有</strong> <code>File</code> 或 <code>Blob</code> 对象的引用，那么**毫无疑问应该直接将它传递给 <code>createImageBitmap</code>**。这不仅代码更简单，而且性能也更好。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>理解 <code>File</code>、<code>Blob</code> 和 <code>URL.createObjectURL()</code> 的工作原理对于高效、健壮地处理前端二进制数据至关重要。总的来说：</p><ul><li><strong><code>File</code>&#x2F;<code>Blob</code> 是数据的载体，存在于浏览器内存中。</strong></li><li><strong>Object URL 是指向这些内存数据的临时引用（门牌号）。</strong></li><li><strong>优先在你的应用状态中存储 <code>File</code>&#x2F;<code>Blob</code> 对象。</strong></li><li><strong>仅在需要 URL 字符串时临时创建 Object URL，并务必在不再需要时调用 <code>URL.revokeObjectURL()</code> 来释放它。</strong></li></ul><p>掌握了这些概念，你就能更从容地应对各种文件处理场景，构建出性能更优、内存更安全的 Web 应用。</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>前端开发</tag>
      
      <tag>JavaScript</tag>
      
      <tag>性能优化</tag>
      
      <tag>文件处理</tag>
      
      <tag>Blob</tag>
      
      <tag>File</tag>
      
      <tag>URL</tag>
      
      <tag>内存管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入 Canvas：掌握 drawImage 实现图像绘制与操作</title>
    <link href="/2025/05/04/%E6%B7%B1%E5%85%A5-Canvas%EF%BC%9A%E6%8E%8C%E6%8F%A1-drawImage-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6%E4%B8%8E%E6%93%8D%E4%BD%9C/"/>
    <url>/2025/05/04/%E6%B7%B1%E5%85%A5-Canvas%EF%BC%9A%E6%8E%8C%E6%8F%A1-drawImage-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E5%83%8F%E7%BB%98%E5%88%B6%E4%B8%8E%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="深入-Canvas：掌握-drawImage-实现图像绘制与操作"><a href="#深入-Canvas：掌握-drawImage-实现图像绘制与操作" class="headerlink" title="深入 Canvas：掌握 drawImage 实现图像绘制与操作"></a>深入 Canvas：掌握 <code>drawImage</code> 实现图像绘制与操作</h2><p>HTML5 Canvas API 为 Web 开发者提供了在网页上动态绘制图形、图像和动画的能力。其中，<code>CanvasRenderingContext2D.drawImage()</code> 方法是处理图像的核心，它允许我们将各种来源的图像绘制到 Canvas 上，并能进行缩放、裁剪等操作。本文将深入探讨 <code>drawImage</code> 的用法，并介绍一些与其经常配合使用的相关函数和概念。</p><h3 id="drawImage：Canvas-图像绘制的瑞士军刀"><a href="#drawImage：Canvas-图像绘制的瑞士军刀" class="headerlink" title="drawImage：Canvas 图像绘制的瑞士军刀"></a><code>drawImage</code>：Canvas 图像绘制的瑞士军刀</h3><p><code>drawImage()</code> 方法根据传递参数的不同，有三种主要的重载形式：</p><ol><li><p><strong><code>drawImage(image, dx, dy)</code></strong>:</p><ul><li><strong>作用</strong>: 将源图像 <code>image</code> 完整地绘制到 Canvas 的 <code>(dx, dy)</code> 坐标处（目标矩形的左上角）。</li><li><strong>参数</strong>:<ul><li><code>image</code>: 要绘制的图像源。可以是 <code>HTMLImageElement</code> ( <code>&lt;img&gt;</code> ), <code>HTMLVideoElement</code> ( <code>&lt;video&gt;</code> ), <code>HTMLCanvasElement</code> (另一个 <code>&lt;canvas&gt;</code> ), <code>ImageBitmap</code> 等。</li><li><code>dx</code>: 图像在目标 Canvas 上绘制的 x 轴坐标。</li><li><code>dy</code>: 图像在目标 Canvas 上绘制的 y 轴坐标。</li></ul></li></ul> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);<br><span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);<br><span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 图片加载完成后，在 canvas 的 (10, 10) 位置绘制完整图片</span><br>  ctx.<span class="hljs-title function_">drawImage</span>(img, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>&#125;;<br>img.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;path/to/your/image.png&#x27;</span>;<br><br></code></pre></td></tr></table></figure></li><li><p><strong><code>drawImage(image, dx, dy, dWidth, dHeight)</code></strong>:</p><ul><li><strong>作用</strong>: 将源图像 <code>image</code> 在绘制时进行缩放，使其填充目标 Canvas 上从 <code>(dx, dy)</code> 开始，宽度为 <code>dWidth</code>、高度为 <code>dHeight</code> 的矩形区域。</li><li><strong>参数</strong>:<ul><li><code>image</code>, <code>dx</code>, <code>dy</code>: 同上。</li><li><code>dWidth</code>: 图像在目标 Canvas 上绘制的宽度。</li><li><code>dHeight</code>: 图像在目标 Canvas 上绘制的高度。</li></ul></li></ul> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);<br><span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);<br><span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 图片加载完成后，在 canvas 的 (10, 10) 位置绘制</span><br>  <span class="hljs-comment">// 并缩放至 100x80 像素大小</span><br>  ctx.<span class="hljs-title function_">drawImage</span>(img, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">80</span>);<br>&#125;;<br>img.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;path/to/your/image.png&#x27;</span>;<br><br></code></pre></td></tr></table></figure></li><li><p><strong><code>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)</code></strong>:</p><ul><li><strong>作用</strong>: 这是功能最全的形式，它允许你从源图像 <code>image</code> 中裁剪出一个矩形区域（由 <code>sx, sy, sWidth, sHeight</code> 定义），然后将这个裁剪出的区域绘制（并可能缩放）到目标 Canvas 的指定矩形区域（由 <code>dx, dy, dWidth, dHeight</code> 定义）。</li><li><strong>参数</strong>:<ul><li><code>image</code>: 同上。</li><li><code>sx</code>: 源图像中要裁剪的矩形区域的左上角 x 坐标。</li><li><code>sy</code>: 源图像中要裁剪的矩形区域的左上角 y 坐标。</li><li><code>sWidth</code>: 源图像中要裁剪的矩形区域的宽度。</li><li><code>sHeight</code>: 源图像中要裁剪的矩形区域的高度。</li><li><code>dx</code>, <code>dy</code>, <code>dWidth</code>, <code>dHeight</code>: 同第二种形式，定义目标 Canvas 上的绘制区域和尺寸。</li></ul></li></ul> <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">const</span> canvas = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myCanvas&#x27;</span>);<br><span class="hljs-keyword">const</span> ctx = canvas.<span class="hljs-title function_">getContext</span>(<span class="hljs-string">&#x27;2d&#x27;</span>);<br><span class="hljs-keyword">const</span> img = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>img.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 图片加载完成后，从源图的 (50, 50) 坐标开始，</span><br>  <span class="hljs-comment">// 裁剪一个 100x100 的区域</span><br>  <span class="hljs-keyword">const</span> sx = <span class="hljs-number">50</span>, sy = <span class="hljs-number">50</span>, sWidth = <span class="hljs-number">100</span>, sHeight = <span class="hljs-number">100</span>;<br>  <span class="hljs-comment">// 将裁剪出的区域绘制到 canvas 的 (10, 10) 位置，</span><br>  <span class="hljs-comment">// 并保持原始裁剪尺寸 (100x100)</span><br>  <span class="hljs-keyword">const</span> dx = <span class="hljs-number">10</span>, dy = <span class="hljs-number">10</span>, dWidth = <span class="hljs-number">100</span>, dHeight = <span class="hljs-number">100</span>;<br>  ctx.<span class="hljs-title function_">drawImage</span>(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);<br>&#125;;<br>img.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;path/to/your/image.png&#x27;</span>;<br><br></code></pre></td></tr></table></figure><p> 在 <code>useCropImage.ts</code> 钩子中，正是使用了这种形式来实现图片裁剪：</p> <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// ... existing code ...</span><br>    <span class="hljs-comment">// 绘制裁剪后的图片</span><br>    ctx.<span class="hljs-title function_">drawImage</span>(<br>      imageRef.<span class="hljs-property">current</span>, <span class="hljs-comment">// 源图像</span><br>      cropRegion.<span class="hljs-property">left</span> / scalingFactor, <span class="hljs-comment">// 源图像裁剪区域 x (考虑了缩放)</span><br>      cropRegion.<span class="hljs-property">top</span> / scalingFactor,  <span class="hljs-comment">// 源图像裁剪区域 y (考虑了缩放)</span><br>      width,                          <span class="hljs-comment">// 源图像裁剪区域宽度 (计算后的实际像素)</span><br>      height,                         <span class="hljs-comment">// 源图像裁剪区域高度 (计算后的实际像素)</span><br>      <span class="hljs-number">0</span>,                              <span class="hljs-comment">// 目标 Canvas 绘制 x (从 0 开始)</span><br>      <span class="hljs-number">0</span>,                              <span class="hljs-comment">// 目标 Canvas 绘制 y (从 0 开始)</span><br>      width,                          <span class="hljs-comment">// 目标 Canvas 绘制宽度 (与裁剪宽度一致)</span><br>      height                          <span class="hljs-comment">// 目标 Canvas 绘制高度 (与裁剪高度一致)</span><br>    );<br><span class="hljs-comment">// ... existing code ...</span><br><br></code></pre></td></tr></table></figure><p> 这里，<code>sx</code>, <code>sy</code> 是根据用户选择的裁剪框位置（<code>cropRegion.left</code>, <code>cropRegion.top</code>）并考虑了图片在屏幕上的显示缩放因子 (<code>scalingFactor</code>) 计算得出的。<code>sWidth</code>, <code>sHeight</code> 是裁剪框在图片原始像素下的宽度和高度。<code>dx</code>, <code>dy</code> 设置为 0，表示从 Canvas 的左上角开始绘制。<code>dWidth</code>, <code>dHeight</code> 与 <code>sWidth</code>, <code>sHeight</code> 相同，表示裁剪出的内容以原始尺寸绘制到新的 Canvas 上。</p></li></ol><h3 id="与-drawImage-协同作战的伙伴们"><a href="#与-drawImage-协同作战的伙伴们" class="headerlink" title="与 drawImage 协同作战的伙伴们"></a>与 <code>drawImage</code> 协同作战的伙伴们</h3><p>要有效使用 <code>drawImage</code>，通常需要借助以下 Canvas API 和 Web API：</p><ol><li><strong><code>canvas.getContext(&#39;2d&#39;)</code></strong>:<ul><li>获取 Canvas 的 2D 渲染上下文对象。所有 2D 绘图操作（包括 <code>drawImage</code>）都需要通过这个上下文对象来调用。</li></ul></li><li><strong><code>document.createElement(&#39;canvas&#39;)</code></strong>:<ul><li>动态创建 <code>&lt;canvas&gt;</code> 元素，常用于离屏渲染或创建临时画布进行图像处理（如 <code>useCropImage.ts</code> 中所示）。</li></ul></li><li><strong><code>canvas.width</code> 和 <code>canvas.height</code></strong>:<ul><li>设置 Canvas 元素的<strong>绘图表面</strong>的实际像素尺寸。<strong>非常重要</strong>: 这不同于通过 CSS 设置的 <code>style.width</code> 和 <code>style.height</code>，后者仅改变元素的显示大小，可能导致绘制内容被拉伸或压缩。要确保绘制清晰，通常需要让 <code>canvas.width</code> 等于其 <code>clientWidth</code>（或期望的像素宽度），<code>canvas.height</code> 等于其 <code>clientHeight</code>（或期望的像素高度）。</li></ul></li><li><strong><code>Image()</code> 构造函数 &#x2F; <code>document.createElement(&#39;img&#39;)</code></strong>:<ul><li>创建 <code>HTMLImageElement</code> 对象。你需要设置其 <code>src</code> 属性来指定图像来源。</li></ul></li><li><strong><code>image.onload</code> 事件处理器</strong>:<ul><li>由于图像加载是异步的，必须确保图像完全加载后才能调用 <code>drawImage</code> 进行绘制，否则可能什么也画不出来或者只绘制一部分。<code>onload</code> 事件是执行绘制操作的最佳时机。如果图像已经缓存，<code>onload</code> 可能不会触发，因此有时需要检查 <code>image.complete</code> 属性。</li></ul></li><li><strong><code>canvas.toBlob(callback, mimeType, quality)</code></strong>:<ul><li>将 Canvas 的内容异步转换为一个 Blob 对象。这对于需要将绘制结果（如图标、裁剪后的图片）保存为文件或上传到服务器非常有用。</li><li><code>callback</code>: 转换完成后的回调函数，接收生成的 Blob 对象作为参数。</li><li><code>mimeType</code>: (可选) 指定输出图像的 MIME 类型，如 <code>&#39;image/png&#39;</code> (默认), <code>&#39;image/jpeg&#39;</code> 等。</li><li><code>quality</code>: (可选) 对于 JPEG 等有损格式，可以指定 0 到 1 之间的图像质量。</li></ul></li><li><strong><code>canvas.toDataURL(mimeType, quality)</code></strong>:<ul><li>将 Canvas 内容同步转换为一个 Data URL 字符串（Base64 编码）。适合于需要立即在 <code>&lt;img&gt;</code> 标签中显示 Canvas 内容，或在 CSS 中使用。但对于大图像，性能不如 <code>toBlob</code>，且生成的字符串很长。</li></ul></li><li><strong><code>URL.createObjectURL(blob)</code></strong>:<ul><li>为 Blob 或 File 对象创建一个临时的本地 URL。常与 <code>toBlob</code> 配合使用，生成一个可以赋给 <code>&lt;img&gt;</code> 的 <code>src</code> 或 <code>&lt;a&gt;</code> 的 <code>href</code> 的 URL，用于预览或下载。</li></ul></li><li><strong><code>URL.revokeObjectURL(url)</code></strong>:<ul><li>释放由 <code>createObjectURL</code> 创建的临时 URL，以释放内存。当不再需要这个 URL 时（例如，用户下载完成或预览组件卸载），应及时调用此方法。</li></ul></li></ol><h3 id="实践：图片裁剪流程回顾"><a href="#实践：图片裁剪流程回顾" class="headerlink" title="实践：图片裁剪流程回顾"></a>实践：图片裁剪流程回顾</h3><p>结合 <code>useCropImage.ts</code> 的代码，我们可以看到这些函数如何协同工作：</p><ol><li><strong>创建临时 Canvas</strong>: <code>document.createElement(&#39;canvas&#39;)</code> 创建一个用于裁剪的画布。</li><li><strong>获取上下文</strong>: <code>canvas.getContext(&#39;2d&#39;)</code> 获取绘图上下文。</li><li><strong>设置 Canvas 尺寸</strong>: <code>canvas.width = ...; canvas.height = ...;</code> 根据计算出的裁剪区域实际像素大小设置画布尺寸。</li><li><strong>加载源图像</strong>: (在 <code>useCropImage</code> 中，源图像由 <code>imageRef.current</code> 提供，假设它已经加载完成)。</li><li><strong>执行裁剪绘制</strong>: <code>ctx.drawImage(...)</code> 使用第九种形式，将源图像的指定区域绘制到临时 Canvas 上。</li><li><strong>导出为 Blob</strong>: <code>canvas.toBlob(callback, &#39;image/png&#39;)</code> 将裁剪结果转换为 PNG 格式的 Blob。</li><li><strong>创建对象 URL</strong>: 在 <code>toBlob</code> 的回调中，<code>URL.createObjectURL(blob)</code> 为 Blob 创建一个临时 URL。</li><li><strong>(可选) 导出&#x2F;下载</strong>: <code>exportCroppedImage</code> 函数创建一个 <code>&lt;a&gt;</code> 标签，设置 <code>href</code> 为对象 URL，<code>download</code> 属性指定文件名，模拟点击实现下载，最后调用 <code>URL.revokeObjectURL(url)</code> 释放资源。</li></ol><h3 id="注意事项与最佳实践"><a href="#注意事项与最佳实践" class="headerlink" title="注意事项与最佳实践"></a>注意事项与最佳实践</h3><ul><li><strong>异步处理</strong>: 始终等待图像加载完成 (<code>onload</code>) 再绘制。</li><li><strong>Canvas 尺寸</strong>: 正确设置 <code>canvas.width</code> 和 <code>canvas.height</code> 以避免失真。</li><li><strong>性能</strong>: 对于频繁绘制或复杂场景，考虑使用 <code>requestAnimationFrame</code>、离屏 Canvas 或 Web Workers。避免在循环中重复获取上下文。</li><li><strong>跨域图像</strong>: 如果绘制来自不同域的图像，可能会遇到安全限制（”tainted canvas”），导致 <code>toBlob</code>, <code>toDataURL</code>, <code>getImageData</code> 等操作失败。需要服务器配置 CORS 策略，并在客户端 <code>Image</code> 对象上设置 <code>crossOrigin=&quot;anonymous&quot;</code> 属性。</li><li><strong>内存管理</strong>: 使用 <code>URL.createObjectURL</code> 后，记得适时调用 <code>URL.revokeObjectURL</code>。</li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p><code>canvas.drawImage()</code> 是 Canvas API 中功能强大且用途广泛的方法。通过理解其不同的参数形式，并结合图像加载、Canvas 尺寸设置、导出方法 (<code>toBlob</code>, <code>toDataURL</code>) 等辅助工具，你可以实现从简单的图像展示到复杂的图像编辑、合成、游戏精灵渲染等各种功能。希望本文能帮助你更好地掌握 <code>drawImage</code>，并在你的 Web 项目中灵活运用 Canvas 的图像处理能力。</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>Web开发</tag>
      
      <tag>HTML5</tag>
      
      <tag>JavaScript</tag>
      
      <tag>Canvas</tag>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 调试实录：当输入框的值总是&quot;叛逆&quot;地重置</title>
    <link href="/2025/05/04/%E5%8F%9B%E9%80%86%E5%9C%B0%E9%87%8D%E7%BD%AE/"/>
    <url>/2025/05/04/%E5%8F%9B%E9%80%86%E5%9C%B0%E9%87%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="React-调试实录：当输入框的值总是”叛逆”地重置"><a href="#React-调试实录：当输入框的值总是”叛逆”地重置" class="headerlink" title="React 调试实录：当输入框的值总是”叛逆”地重置"></a>React 调试实录：当输入框的值总是”叛逆”地重置</h2><p>大家好！今天想和大家分享一个最近在开发 React 应用时遇到的有趣 Bug。你是否也曾遇到过这样的情况：一个简单的输入框，你明明输入了内容，但它却像有自己的想法一样，瞬间恢复到了原来的值？如果你也抓耳挠腮过，那这篇文章可能会给你一些启发。</p><h3 id="问题现象：挥之不去的”初始值”"><a href="#问题现象：挥之不去的”初始值”" class="headerlink" title="问题现象：挥之不去的”初始值”"></a>问题现象：挥之不去的”初始值”</h3><p>在我们的图片编辑工具中，有一个控制面板 (CanvasControls)，允许用户在裁剪模式下手动输入图片的宽度和高度。我们使用了 styled-components 创建了一个看起来很酷的胶囊状输入框 (CapsuleInput)。</p><p>然而，奇怪的事情发生了：每当用户尝试在宽度或高度输入框里输入数字时，输入框的值会立刻被重置回图片加载时的原始尺寸。就好像用户什么都没输入一样。</p><h3 id="初步排查：确认基础逻辑"><a href="#初步排查：确认基础逻辑" class="headerlink" title="初步排查：确认基础逻辑"></a>初步排查：确认基础逻辑</h3><p>面对这种现象，我们首先快速检查了基础的事件处理：CapsuleInput 的 value 属性确实绑定到了组件的 width 和 height 状态，并且 onChange 事件处理函数也已正确添加，用于在用户输入时更新这些状态。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// CanvasControls.tsx</span><br><span class="hljs-comment">// ... (状态定义)</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleWidthChange</span> = (<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-title class_">React</span>.<span class="hljs-title class_">ChangeEvent</span>&lt;<span class="hljs-title class_">HTMLInputElement</span>&gt;</span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> newWidth = <span class="hljs-built_in">parseInt</span>(event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>, <span class="hljs-number">10</span>);<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">isNaN</span>(newWidth)) &#123;<br>    <span class="hljs-title function_">setWidth</span>(newWidth); <span class="hljs-comment">// 更新状态</span><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span> === <span class="hljs-string">&#x27;&#x27;</span>) &#123;<br>    <span class="hljs-title function_">setWidth</span>(<span class="hljs-number">0</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// ... handleHeightChange 类似</span><br><br><span class="hljs-keyword">return</span> (<br>  <span class="hljs-comment">// ...</span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">CapsuleInput</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;number&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;width&#125;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;handleWidthChange&#125;</span> /&gt;</span></span><br>  <span class="hljs-comment">// ...</span><br>);<br><br></code></pre></td></tr></table></figure><p>确认了基本的事件绑定和状态更新逻辑无误后，我们排除了是简单遗漏 onChange 导致的低级错误。但问题依旧存在，输入值还是会被重置。这说明问题隐藏得更深。</p><h3 id="深入探究：useEffect-与不必要的重渲染"><a href="#深入探究：useEffect-与不必要的重渲染" class="headerlink" title="深入探究：useEffect 与不必要的重渲染"></a>深入探究：useEffect 与不必要的重渲染</h3><p>既然简单的状态更新没问题，那问题一定出在组件渲染周期的其他环节。我们再次审视 CanvasControls 组件的代码，注意到了这个 useEffect：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// CanvasControls.tsx</span><br><span class="hljs-keyword">import</span> &#123; useImageSize &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../../hooks/useImageContextHooks&#x27;</span>;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CanvasControls</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">const</span> &#123; getNaturalSize &#125; = <span class="hljs-title function_">useImageSize</span>(); <span class="hljs-comment">// &lt;--- 从自定义 Hook 获取函数</span><br>  <span class="hljs-keyword">const</span> [width, setWidth] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> [height, setHeight] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 这个 Effect 用于在图片加载时，用图片的自然尺寸初始化输入框的值</span><br>    <span class="hljs-keyword">if</span> (selectedImage) &#123;<br>      <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">width</span>: naturalWidth, <span class="hljs-attr">height</span>: naturalHeight &#125; = <span class="hljs-title function_">getNaturalSize</span>();<br>      <span class="hljs-keyword">if</span> (naturalWidth &gt; <span class="hljs-number">0</span> &amp;&amp; naturalHeight &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-title function_">setWidth</span>(naturalWidth); <span class="hljs-comment">// &lt;--- 这里会重置状态</span><br>        <span class="hljs-title function_">setHeight</span>(naturalHeight); <span class="hljs-comment">// &lt;--- 这里也会重置状态</span><br>      &#125;<br>    &#125;<br>  &#125;, [selectedImage, getNaturalSize]); <span class="hljs-comment">// &lt;--- 注意这里的依赖项！</span><br><br>  <span class="hljs-comment">// ... (事件处理函数等)</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>这个 useEffect 的作用是在 selectedImage（用户选择的图片）变化时，获取图片的原始尺寸，并用它来设置 width 和 height 状态的初始值。</p><p><strong>疑点来了</strong>：useEffect 的依赖项数组包含了 getNaturalSize。这意味着，如果 getNaturalSize 函数的引用发生变化，这个 useEffect 就会重新执行。</p><p>难道用户每次输入导致状态更新，进而触发重新渲染时，getNaturalSize 的引用也变了？</p><p>我们赶紧查看了 getNaturalSize 的来源——自定义 Hook useImageSize (src&#x2F;hooks&#x2F;useImageContextHooks.ts)：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// src/hooks/useImageContextHooks.ts</span><br><span class="hljs-keyword">import</span> &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useImageSize</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; imageRef &#125; = <span class="hljs-title function_">useImageRef</span>();<br><br>  <span class="hljs-comment">// 每次 useImageSize Hook 执行（即 CanvasControls 渲染）时，</span><br>  <span class="hljs-comment">// 都会创建一个新的 getNaturalSize 函数实例！</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">getNaturalSize</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (!imageRef?.<span class="hljs-property">current</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">0</span> &#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">width</span>: imageRef.<span class="hljs-property">current</span>.<span class="hljs-property">naturalWidth</span>,<br>      <span class="hljs-attr">height</span>: imageRef.<span class="hljs-property">current</span>.<span class="hljs-property">naturalHeight</span>,<br>    &#125;;<br>  &#125;;<br><br>  <span class="hljs-comment">// ... (getDisplaySize 类似)</span><br>  <span class="hljs-keyword">return</span> &#123; getNaturalSize, getDisplaySize &#125;;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>真相大白！</strong> 问题就出在这里。getNaturalSize 函数是在 useImageSize Hook 内部直接定义的。这意味着每次 CanvasControls 组件渲染（包括我们输入数字触发 setWidth 或 setHeight 导致的状态更新后的重新渲染），useImageSize Hook 都会运行，从而创建一个全新的 getNaturalSize 函数实例。</p><p>因为 getNaturalSize 的引用在每次渲染时都不同，所以依赖于它的 useEffect 每次都会执行。结果就是，我们刚刚通过 onChange 更新的 width 或 height 状态，马上就被 useEffect 内部的 setWidth(naturalWidth) 和 setHeight(naturalHeight) 给覆盖回了图片的原始尺寸！这就是输入被重置的根本原因。</p><h3 id="最终解决方案：useCallback-登场"><a href="#最终解决方案：useCallback-登场" class="headerlink" title="最终解决方案：useCallback 登场"></a>最终解决方案：useCallback 登场</h3><p>要解决这个问题，我们需要确保 getNaturalSize 函数的引用保持稳定，除非它的依赖项（这里是 imageRef）真的发生了变化。这正是 useCallback Hook 的用武之地。</p><p>我们修改 useImageSize Hook，用 useCallback 来包裹 getNaturalSize 和 getDisplaySize：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// src/hooks/useImageContextHooks.ts</span><br><span class="hljs-keyword">import</span> &#123; useContext, useCallback &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>; <span class="hljs-comment">// 导入 useCallback</span><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">useImageSize</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123; imageRef &#125; = <span class="hljs-title function_">useImageRef</span>();<br><br>  <span class="hljs-comment">// 使用 useCallback 记忆化函数</span><br>  <span class="hljs-keyword">const</span> getNaturalSize = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!imageRef?.<span class="hljs-property">current</span>) &#123;<br>      <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">0</span> &#125;;<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">width</span>: imageRef.<span class="hljs-property">current</span>.<span class="hljs-property">naturalWidth</span>,<br>      <span class="hljs-attr">height</span>: imageRef.<span class="hljs-property">current</span>.<span class="hljs-property">naturalHeight</span>,<br>    &#125;;<br>  &#125;, [imageRef]); <span class="hljs-comment">// 只有当 imageRef 变化时，才重新创建函数</span><br><br>  <span class="hljs-keyword">const</span> getDisplaySize = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// ... (类似处理)</span><br>  &#125;, [imageRef]);<br><br>  <span class="hljs-keyword">return</span> &#123; getNaturalSize, getDisplaySize &#125;;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>修改后，getNaturalSize 函数的引用只会在 imageRef 变化时才更新。这样，在 CanvasControls 组件因输入而重新渲染时，getNaturalSize 的引用保持不变，useEffect 不会再次执行，我们输入的值也就不会被重置了！</p><p>再次测试，输入框终于”听话”了！</p><h3 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h3><p>这次调试过程再次提醒我们：</p><ol><li><strong>React 的渲染机制</strong>：状态更新会导致组件重新渲染，理解这一点是解决复杂问题的基础。</li><li><strong>useEffect 的依赖项陷阱</strong>：务必谨慎处理 useEffect 的依赖项数组。如果依赖项是函数或对象，要特别注意它们的引用稳定性，否则可能导致 Effect 非预期地频繁执行。</li><li><strong>自定义 Hook 的最佳实践</strong>：在自定义 Hook 中返回函数或对象时，应默认使用 useCallback 和 useMemo 进行记忆化，这可以有效避免下游组件因不必要的引用变化而产生性能问题或 Bug。</li></ol><p>希望这个案例能帮助大家在未来的 React 开发中少走一些弯路！如果你也遇到过类似的”灵异”事件，欢迎在评论区分享你的故事和解决方案！</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>前端开发</tag>
      
      <tag>useEffect</tag>
      
      <tag>Hooks</tag>
      
      <tag>useCallback</tag>
      
      <tag>性能优化</tag>
      
      <tag>调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搞定Flexbox溢出：如何优雅处理子容器超出父容器的问题</title>
    <link href="/2025/05/04/flex%E5%B8%83%E5%B1%80%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%AD%90%E9%A1%B9%E8%B6%85%E5%87%BA%E7%88%B6%E5%AE%B9%E5%99%A8%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F/"/>
    <url>/2025/05/04/flex%E5%B8%83%E5%B1%80%EF%BC%9A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%AD%90%E9%A1%B9%E8%B6%85%E5%87%BA%E7%88%B6%E5%AE%B9%E5%99%A8%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="搞定Flexbox溢出：如何优雅处理子容器超出父容器的问题"><a href="#搞定Flexbox溢出：如何优雅处理子容器超出父容器的问题" class="headerlink" title="搞定Flexbox溢出：如何优雅处理子容器超出父容器的问题"></a>搞定Flexbox溢出：如何优雅处理子容器超出父容器的问题</h2><p>Flexbox（弹性盒子布局）无疑是现代 Web 前端开发中最强大、最灵活的布局模型之一。它极大地简化了元素对齐、分布和排序的复杂性。然而，即使是经验丰富的开发者，有时也会遇到一个棘手的问题：<strong>Flex 子项（flex item）的内容或设定尺寸超出了其父容器（flex container）的边界。</strong></p><p>这种情况不仅会破坏预期的布局，还可能导致内容被遮挡或出现不必要的滚动条。别担心，这个问题很常见，而且有多种有效的解决方案。本文将深入探讨导致此问题的原因，并提供一系列实用的解决策略。</p><h3 id="为什么会发生溢出？"><a href="#为什么会发生溢出？" class="headerlink" title="为什么会发生溢出？"></a>为什么会发生溢出？</h3><p>理解问题根源是找到最佳解决方案的第一步。以下是一些常见的导致 Flex 子项溢出的原因：</p><ol><li><strong>内容的固有尺寸（Intrinsic Size）:</strong> 这是最常见的原因之一。Flex 子项默认具有 <code>min-width: auto</code> 和 <code>min-height: auto</code>。这意味着它们不会收缩到比其内容（如长单词、固定宽度的图片、<code>&lt;code&gt;</code> 块等）所需的最小尺寸还要小。即使父容器空间不足，子项也会坚持显示其全部内容，从而导致溢出。</li><li><strong>固定的 <code>width</code> 或 <code>height</code>:</strong> 如果你给 Flex 子项设置了固定的 <code>width</code> 或 <code>height</code> 值，并且这个值大于父容器在相应方向上可用的空间，子项自然会溢出。</li><li><strong><code>flex-basis</code> 设置过大:</strong> <code>flex-basis</code> 定义了子项在分配多余空间之前的初始（主轴）尺寸。如果设置了一个较大的 <code>flex-basis</code> 值，并且没有足够的收缩能力（<code>flex-shrink</code>），子项也可能超出容器。</li><li><strong><code>flex-wrap: nowrap</code> (默认值):</strong> 当父容器设置为 <code>display: flex</code> 时，其 <code>flex-wrap</code> 属性默认为 <code>nowrap</code>。这意味着所有子项会尝试排在同一行（或同一列，取决于 <code>flex-direction</code>），即使它们的总宽度（或高度）超过了父容器。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>了解了原因后，我们可以针对性地采取以下策略来解决溢出问题：</p><h3 id="方案一：允许子项收缩-min-width-0-min-height-0"><a href="#方案一：允许子项收缩-min-width-0-min-height-0" class="headerlink" title="方案一：允许子项收缩 (min-width: 0 &#x2F; min-height: 0)"></a>方案一：允许子项收缩 (<code>min-width: 0</code> &#x2F; <code>min-height: 0</code>)</h3><p>这是解决 <strong>内容固有尺寸</strong> 导致溢出的最常用且有效的方法。通过在 <strong>Flex 子项</strong> 上设置 <code>min-width: 0</code>（对于水平溢出）或 <code>min-height: 0</code>（对于垂直溢出），你可以覆盖 <code>auto</code> 的默认行为，允许子项在必要时收缩到小于其内容尺寸。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flex-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>; <span class="hljs-comment">/* 父容器宽度有限 */</span><br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>&#125;<br><br><span class="hljs-selector-class">.flex-item</span> &#123;<br>  <span class="hljs-comment">/* 关键：允许子项宽度收缩至0，覆盖min-width: auto */</span><br>  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/* 确保允许收缩 */</span><br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;<br>&#125;<br><br><span class="hljs-selector-class">.long-content</span> &#123;<br>  <span class="hljs-attribute">white-space</span>: nowrap; <span class="hljs-comment">/* 模拟一个不会自动换行的长内容 */</span><br>  <span class="hljs-attribute">background-color</span>: lightblue;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-item&quot;</span>&gt;</span>Short<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-item&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;long-content&quot;</span>&gt;</span>ThisIsAVeryVeryVeryLongWordThatCausesOverflow<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-item&quot;</span>&gt;</span>Short<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>在这个例子中，如果没有 <code>min-width: 0</code>，包含长单词的 <code>.flex-item</code> 会撑开布局。加上 <code>min-width: 0</code> 后，它就能正确地收缩了（当然，内容本身可能还是会被截断，这时需要配合其他方案）。</p><h3 id="方案二：在子项上使用-overflow"><a href="#方案二：在子项上使用-overflow" class="headerlink" title="方案二：在子项上使用 overflow"></a>方案二：在子项上使用 <code>overflow</code></h3><p>如果你希望 <strong>Flex 子项</strong> 本身能够处理其内部内容的溢出（例如，通过显示滚动条或隐藏多余内容），可以在子项上应用 <code>overflow</code> 属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flex-item</span> &#123;<br>  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 可能仍然需要，确保能收缩 */</span><br>  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 隐藏溢出内容 */</span><br>  <span class="hljs-comment">/* 或 overflow: auto; */</span> <span class="hljs-comment">/* 当内容溢出时显示滚动条 */</span><br>  <span class="hljs-comment">/* 或 overflow: scroll; */</span> <span class="hljs-comment">/* 总是显示滚动条 */</span><br>  <span class="hljs-attribute">text-overflow</span>: ellipsis; <span class="hljs-comment">/* 可选：配合overflow: hidden使用，显示省略号 */</span><br>  <span class="hljs-attribute">white-space</span>: nowrap; <span class="hljs-comment">/* 可选：配合text-overflow使用，确保文本不换行 */</span><br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid blue;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这种方法适用于你希望保持子项的计算尺寸，但控制其内部内容的显示方式。</p><h3 id="方案三：在父容器上使用-overflow"><a href="#方案三：在父容器上使用-overflow" class="headerlink" title="方案三：在父容器上使用 overflow"></a>方案三：在父容器上使用 <code>overflow</code></h3><p>如果你希望整个 <strong>Flex 容器</strong> 来处理所有子项组合起来可能产生的溢出，可以在父容器上设置 <code>overflow</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flex-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>  <span class="hljs-comment">/* 在父容器上处理溢出 */</span><br>  <span class="hljs-attribute">overflow-x</span>: auto; <span class="hljs-comment">/* 水平方向溢出时显示滚动条 */</span><br>  <span class="hljs-comment">/* 或 overflow-y: auto; */</span> <span class="hljs-comment">/* 垂直方向溢出时显示滚动条 */</span><br>  <span class="hljs-comment">/* 或 overflow: hidden; */</span> <span class="hljs-comment">/* 直接隐藏溢出的子项部分 */</span><br>&#125;<br><br><span class="hljs-selector-class">.flex-item</span> &#123;<br>   <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 假设子项不允许收缩，更容易触发父容器滚动 */</span><br>   <span class="hljs-attribute">width</span>: <span class="hljs-number">150px</span>;<br>   <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid green;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-item&quot;</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-item&quot;</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-item&quot;</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>这种方法适用于创建水平或垂直滚动的组件，如轮播图、标签栏等。</p><h3 id="方案四：允许换行-flex-wrap-wrap"><a href="#方案四：允许换行-flex-wrap-wrap" class="headerlink" title="方案四：允许换行 (flex-wrap: wrap)"></a>方案四：允许换行 (<code>flex-wrap: wrap</code>)</h3><p>如果布局允许子项在空间不足时换到下一行（或下一列），那么在 <strong>父容器</strong> 上设置 <code>flex-wrap: wrap</code> 是一个简单直接的解决方案。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flex-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid black;<br>  <span class="hljs-comment">/* 允许子项换行 */</span><br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>&#125;<br><br><span class="hljs-selector-class">.flex-item</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>; <span class="hljs-comment">/* 子项有固定宽度 */</span><br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid orange;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-item&quot;</span>&gt;</span>Item 1<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-item&quot;</span>&gt;</span>Item 2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-item&quot;</span>&gt;</span>Item 3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;flex-item&quot;</span>&gt;</span>Item 4<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>当一行放不下所有子项时，超出的子项会自动排列到下一行。</p><h3 id="方案五：限制最大尺寸-max-width-max-height"><a href="#方案五：限制最大尺寸-max-width-max-height" class="headerlink" title="方案五：限制最大尺寸 (max-width &#x2F; max-height)"></a>方案五：限制最大尺寸 (<code>max-width</code> &#x2F; <code>max-height</code>)</h3><p>对于图片或其他需要按比例缩放的元素，可以在 <strong>子项</strong> 或其内部元素上设置 <code>max-width: 100%</code> 或 <code>max-height: 100%</code>。这确保它们的最大尺寸不会超过其容器（在这里是 Flex 子项）的可用空间。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flex-item</span> <span class="hljs-selector-tag">img</span> &#123;<br>  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 图片宽度不会超过其父元素（flex-item）的宽度 */</span><br>  <span class="hljs-attribute">height</span>: auto; <span class="hljs-comment">/* 保持图片宽高比 */</span><br>  <span class="hljs-attribute">display</span>: block; <span class="hljs-comment">/* 避免图片下方出现空隙 */</span><br>&#125;<br><br><span class="hljs-selector-class">.flex-item</span> &#123;<br>   <span class="hljs-attribute">min-width</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 仍然推荐，确保flex item本身能收缩 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="方案六：处理长文本-word-break-overflow-wrap"><a href="#方案六：处理长文本-word-break-overflow-wrap" class="headerlink" title="方案六：处理长文本 (word-break, overflow-wrap)"></a>方案六：处理长文本 (<code>word-break</code>, <code>overflow-wrap</code>)</h3><p>如果溢出主要是由长单词或 URL 引起的，可以在 <strong>子项</strong> 上使用 CSS 文本处理属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flex-item</span> &#123;<br>  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 允许收缩 */</span><br>  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 可能需要隐藏 */</span><br><br>  <span class="hljs-comment">/* 处理长单词或URL */</span><br>  <span class="hljs-attribute">word-break</span>: break-all; <span class="hljs-comment">/* 允许在任意字符间断行 (比较粗暴) */</span><br>  <span class="hljs-comment">/* 或 */</span><br>  <span class="hljs-attribute">overflow-wrap</span>: break-word; <span class="hljs-comment">/* 优先在空格或连字符处断行，实在不行才在单词内断行 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="如何选择合适的方案？"><a href="#如何选择合适的方案？" class="headerlink" title="如何选择合适的方案？"></a>如何选择合适的方案？</h3><ul><li><strong>内容撑开无法收缩？</strong> -&gt; 优先尝试在子项上加 <code>min-width: 0</code> 或 <code>min-height: 0</code>。</li><li><strong>希望子项内部滚动或隐藏内容？</strong> -&gt; 在子项上使用 <code>overflow</code>。</li><li><strong>希望整个容器提供滚动条？</strong> -&gt; 在父容器上使用 <code>overflow</code>。</li><li><strong>布局允许子项换行&#x2F;列？</strong> -&gt; 在父容器上使用 <code>flex-wrap: wrap</code>。</li><li><strong>图片或媒体元素过大？</strong> -&gt; 在子项或媒体元素上使用 <code>max-width: 100%</code> &#x2F; <code>max-height: 100%</code>。</li><li><strong>长单词或文本导致溢出？</strong> -&gt; 在子项上使用 <code>word-break</code> 或 <code>overflow-wrap</code>，通常配合 <code>overflow: hidden</code>。</li></ul><p>通常，你可能需要组合使用这些策略。例如，设置 <code>min-width: 0</code> 允许子项收缩，然后用 <code>overflow: hidden</code> 和 <code>text-overflow: ellipsis</code> 来优雅地处理被截断的文本。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Flexbox 子项溢出父容器是一个常见但完全可以解决的问题。关键在于理解导致溢出的具体原因——是内容的固有尺寸、固定的宽高、不允许换行，还是其他因素？一旦明确了原因，就可以从 <code>min-width/height: 0</code>、父子容器的 <code>overflow</code>、<code>flex-wrap</code>、<code>max-width/height</code> 以及文本处理属性中选择最合适的方案或组合拳来应对。</p><p>掌握这些技巧，你就能更自信地驾驭 Flexbox，构建出更加健壮和美观的响应式布局。记住，多动手实践，并利用好浏览器的开发者工具来观察和调试布局，是提升 Flexbox 技能的最佳途径！</p><p>好的，我们来深入探讨一下 Flexbox 子项溢出的原理，特别是 <code>min-width: auto</code> 这个“幕后推手”，并进行举一反三的思考。</p><hr><h2 id="深入-Flexbox-溢出：解密-min-width-auto-与尺寸计算"><a href="#深入-Flexbox-溢出：解密-min-width-auto-与尺寸计算" class="headerlink" title="深入 Flexbox 溢出：解密 min-width: auto 与尺寸计算"></a>深入 Flexbox 溢出：解密 <code>min-width: auto</code> 与尺寸计算</h2><p>我们已经知道 Flexbox 子项溢出父容器是个常见问题，并且 <code>min-width: 0</code> 是一个关键的解决方案。但要真正掌握它，我们需要理解更深层次的原因：<strong>为什么 Flex 子项默认会有 <code>min-width: auto</code>？这个 <code>auto</code> 到底意味着什么？以及它如何影响 Flexbox 的尺寸计算？</strong></p><h3 id="核心原理：min-width-auto-与内容的固有最小尺寸-Intrinsic-Minimum-Size"><a href="#核心原理：min-width-auto-与内容的固有最小尺寸-Intrinsic-Minimum-Size" class="headerlink" title="核心原理：min-width: auto 与内容的固有最小尺寸 (Intrinsic Minimum Size)"></a>核心原理：<code>min-width: auto</code> 与内容的固有最小尺寸 (Intrinsic Minimum Size)</h3><ol><li><strong><code>min-width</code> 的作用：</strong><code>min-width</code> 属性定义了一个元素的最小宽度。无论外部容器如何挤压，或者 <code>width</code> 属性设置得有多小，元素的实际渲染宽度（除非使用 <code>overflow</code> 隐藏）通常不会小于 <code>min-width</code> 指定的值。</li><li><strong><code>auto</code> 的含义 (在 <code>min-width</code> &#x2F; <code>min-height</code> 上)：</strong><br>对于 Flex 子项 (flex items) 来说，<code>min-width</code> 的默认值是 <code>auto</code>。这里的 <code>auto</code> <strong>并不意味着 0</strong>，也不是简单地继承或依赖其他尺寸属性。根据 W3C 的 Flexbox 规范，对于 Flex 子项，<code>min-width: auto</code> 和 <code>min-height: auto</code> 会<strong>计算为一个等于该项目“最小内容尺寸” (min-content size) 的值</strong>。</li><li><strong>什么是“最小内容尺寸” (min-content size)？</strong><ul><li>可以理解为：为了<strong>完全显示</strong>该项目内部<strong>不可断行的内容</strong>（或者说最长的那个不可分割单元）所需要的最小宽度。</li><li><strong>具体例子：</strong><ul><li><strong>长单词&#x2F;URL：</strong> 一个很长的英文单词或 URL，浏览器默认不会在单词中间断开换行。这个单词的宽度就是其最小内容宽度。</li><li><strong><code>white-space: nowrap</code> 的文本：</strong> 明确指定不换行的文本，其总宽度就是最小内容宽度。</li><li><strong>固定宽度的子元素：</strong> 如果 Flex 子项内部有一个设置了 <code>width: 200px</code> 的图片或 <code>div</code>，那么这个 Flex 子项的最小内容宽度至少是 200px (加上可能的 padding&#x2F;border)。</li><li><strong><code>&lt;code&gt;</code> 或 <code>&lt;pre&gt;</code> 标签：</strong> 这些标签通常包含需要精确格式化的内容，浏览器倾向于不破坏其内部换行，因此可能产生较宽的最小内容宽度。</li><li><strong>替换元素 (Replaced Elements)：</strong> 如 <code>&lt;img&gt;</code>, <code>&lt;video&gt;</code>, <code>&lt;canvas&gt;</code> 等，它们的固有尺寸（如果未指定 <code>width</code>&#x2F;<code>height</code>）或其 <code>width</code>&#x2F;<code>height</code> 属性值会影响最小内容尺寸。</li></ul></li></ul></li><li><strong>为什么默认是 <code>auto</code> (即 min-content) 而不是 0？</strong><br>这是 Flexbox 设计时的一个<strong>重要考量</strong>。设计者希望 Flexbox 在默认情况下能够<strong>尽可能地保护内容不被过度压缩而导致不可读或布局错乱</strong>。如果默认 <code>min-width</code> 是 0，那么当容器空间不足时，包含长单词或固定尺寸内容的 Flex 子项可能会被无限压缩，导致内容完全无法辨认或被截断得失去意义。<code>min-width: auto</code> 提供了一种“智能”的下限，它基于内容本身，尝试在收缩的同时保持内容的基本可见性。</li></ol><h3 id="min-width-auto-导致的现象-后果"><a href="#min-width-auto-导致的现象-后果" class="headerlink" title="min-width: auto 导致的现象 (后果)"></a><code>min-width: auto</code> 导致的现象 (后果)</h3><p>当 Flex 容器空间不足，需要收缩子项时，Flexbox 的算法会根据子项的 <code>flex-shrink</code> 属性来分配“负空间”（需要收缩的总量）。但是，这个收缩过程<strong>受到 <code>min-width</code> (或 <code>min-height</code>) 的限制</strong>。</p><ul><li><strong>拒绝过度收缩：</strong> 即使一个 Flex 子项的 <code>flex-shrink</code> 值很大（意味着它应该优先收缩），但如果计算出的收缩后尺寸小于其 <code>min-width: auto</code>（即其最小内容尺寸），<strong>它将停止收缩</strong>，最终尺寸会被“卡”在 <code>min-width: auto</code> 这个值上。</li><li><strong>推挤效应：</strong> 这个“拒绝收缩”的子项会保持其最小内容宽度，从而占据比预期更多的空间。</li><li><strong>导致溢出：</strong> 如果所有子项（特别是那些内容较宽的子项）停止收缩后的总宽度仍然大于父容器的宽度，并且父容器设置了 <code>flex-wrap: nowrap</code> (默认值)，那么多余的部分就会<strong>超出父容器的边界</strong>，形成溢出。</li></ul><p><strong>简单来说：<code>min-width: auto</code> 就像是给每个 Flex 子项设置了一个基于其内容的“宽度底线”。当 Flexbox 想让它变得更窄时，它会说：“不行，我至少得这么宽才能显示清楚我最重要的内容（那个最长的单词&#x2F;图片等）！” 如果所有子项的“底线”加起来都比容器宽，那自然就溢出了。</strong></p><h3 id="解决方案-min-width-0-的原理"><a href="#解决方案-min-width-0-的原理" class="headerlink" title="解决方案 min-width: 0 的原理"></a>解决方案 <code>min-width: 0</code> 的原理</h3><p>当我们显式地将 Flex 子项的 <code>min-width</code> 设置为 <code>0</code> 时：</p><ul><li>我们覆盖了 <code>auto</code> 的默认行为。</li><li>我们告诉浏览器：“这个子项在收缩时<strong>没有基于内容的宽度底线</strong>了，你可以根据 <code>flex-shrink</code> 的规则将它一直压缩下去，甚至理论上可以压缩到 0 宽度（尽管实际内容可能被隐藏或截断）。”</li><li>这样，Flexbox 的收缩算法就不再受到内容最小尺寸的阻碍，子项可以充分利用其 <code>flex-shrink</code> 的潜力，从而更有可能适应父容器的宽度，避免溢出。</li></ul><p><strong>注意：</strong> 设置 <code>min-width: 0</code> 并不意味着子项的宽度 <em>一定</em> 会变成 0。它只是移除了内容带来的最小宽度限制，允许 Flexbox 根据可用空间和 <code>flex</code> 属性（<code>flex-grow</code>, <code>flex-shrink</code>, <code>flex-basis</code>）自由计算最终尺寸。最终尺寸仍然取决于容器大小、其他兄弟项的尺寸和 Flex 属性。</p><h3 id="举一反三：将原理应用到其他场景"><a href="#举一反三：将原理应用到其他场景" class="headerlink" title="举一反三：将原理应用到其他场景"></a>举一反三：将原理应用到其他场景</h3><p>理解了 <code>min-width: auto</code> 的原理后，我们可以更好地理解其他相关问题和解决方案：</p><ol><li><strong><code>min-height: auto</code> 与垂直溢出 (<code>flex-direction: column</code>)：</strong><ul><li>完全相同的原理适用于垂直方向。当 <code>flex-direction: column</code> 时，子项默认有 <code>min-height: auto</code>，它等于子项的“最小内容高度”。</li><li>如果子项内容（如很高的图片、多行文本块）的高度超过了父容器分配给它的高度，并且它拒绝收缩到比内容高度更小，就会导致垂直溢出。</li><li>解决方案同样是在子项上设置 <code>min-height: 0</code>，允许它在垂直方向上被充分压缩。</li></ul></li><li><strong>固定 <code>width</code>&#x2F;<code>height</code> 与溢出：</strong><ul><li>给 Flex 子项设置固定的 <code>width</code> 或 <code>height</code> (例如 <code>width: 500px</code>)，其效果<strong>类似于</strong> <code>min-width: auto</code>，因为它也设定了一个下限（甚至同时是上限）。</li><li>Flexbox 在收缩时，同样不能将子项收缩到小于其固定 <code>width</code> 的尺寸（因为 <code>width</code> 优先级高于 <code>flex-shrink</code> 效果，除非显式设置了更小的 <code>max-width</code>）。如果固定尺寸总和超过容器，且 <code>flex-wrap: nowrap</code>，就会溢出。</li><li>这解释了为什么有时即使没有特别长的内容，只要固定宽度子项加起来太多，也会溢出。解决方案可能是移除固定宽度、允许换行 (<code>flex-wrap: wrap</code>)、或者让父容器滚动 (<code>overflow: auto/scroll</code>)。</li></ul></li><li><strong><code>flex-basis</code> 与溢出：</strong><ul><li><code>flex-basis</code> 定义了子项在分配剩余空间之前的“基础尺寸”。</li><li>如果 <code>flex-basis</code> 设置了一个较大的值（例如 <code>flex-basis: 300px</code>），并且 <code>flex-shrink</code> 为 0（不允许收缩），那么它的行为就非常像设置了 <code>width: 300px</code>，可能导致溢出。</li><li>如果 <code>flex-shrink</code> 大于 0（允许收缩），Flexbox 会尝试从 <code>flex-basis</code> 开始收缩。<strong>但是，这个收缩过程仍然受到 <code>min-width: auto</code> (或显式 <code>min-width</code>) 的限制！</strong> 如果收缩到 <code>min-content</code> 尺寸时空间仍然不足，它就会停止收缩并可能导致溢出。这就是为什么有时即使设置了 <code>flex-shrink: 1</code>，如果内容本身很宽，仍然需要 <code>min-width: 0</code> 来解决溢出。</li></ul></li><li><strong><code>overflow</code> 属性的角色：</strong><ul><li><code>overflow: hidden/auto/scroll</code> (无论在子项还是父容器上) <strong>并不改变 Flexbox 的尺寸计算逻辑</strong>。它是在尺寸计算<strong>完成之后</strong>，决定如何处理那些<strong>已经被计算为“溢出”</strong>的部分。</li><li><code>min-width: 0</code> 是在<strong>尺寸计算阶段</strong>介入，通过移除下限来<strong>避免</strong>产生（或减少）计算上的溢出。</li><li><code>overflow</code> 是在<strong>渲染阶段</strong>介入，处理<strong>已经发生</strong>的溢出（隐藏、提供滚动条）。</li><li>这就是为什么 <code>min-width: 0</code> 和 <code>overflow: hidden</code> 经常一起使用：前者让子项能正确收缩以适应容器（可能导致内容被截断），后者则处理这些被截断内容的视觉表现（隐藏掉）。</li></ul></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li>Flex 子项默认的 <code>min-width: auto</code> 是为了保护内容可见性，其值等于内容的“最小内容尺寸”。</li><li>这个默认行为限制了 Flexbox 在空间不足时收缩子项的能力，是导致内容驱动型溢出的主要原因。</li><li>设置 <code>min-width: 0</code> (或 <code>min-height: 0</code> 对于垂直方向) 可以移除这个基于内容的收缩下限，让 <code>flex-shrink</code> 充分发挥作用，从而有效解决溢出问题。</li><li>理解这个核心原理有助于我们推断固定尺寸、<code>flex-basis</code>、<code>flex-wrap</code> 和 <code>overflow</code> 等属性在 Flexbox 布局和溢出场景中的相互作用。</li></ul><p>掌握了这些原理，你就能在遇到 Flexbox 溢出问题时，不仅仅是知其然（知道用 <code>min-width: 0</code>），更能知其所以然（明白为什么它能解决问题，以及何时需要结合其他方案）。这将让你在构建复杂布局时更加得心应手。好的，我们来看一些具体的实际场景，这些场景经常会遇到 Flexbox 子项溢出的问题，以及如何应用我们讨论过的原理和解决方案来处理它们。</p><h3 id="场景一：导航菜单项过长"><a href="#场景一：导航菜单项过长" class="headerlink" title="场景一：导航菜单项过长"></a>场景一：导航菜单项过长</h3><p><strong>情景描述：</strong><br>你正在构建一个网站的顶部水平导航栏。大部分菜单项名称都很短，但其中一个或几个特别长（比如“企业解决方案与服务”或者多语言环境下某个词特别长）。</p><p><strong>HTML 结构 (简化):</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">nav</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;main-nav&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;menu-list&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;menu-item&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;menu-item&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>产品中心<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;menu-item&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>关于我们<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;menu-item&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>一个非常非常非常长的菜单项名称示例<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;menu-item&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>联系方式<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>CSS (可能导致问题):</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.main-nav</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">600px</span>; <span class="hljs-comment">/* 导航栏容器宽度有限 */</span><br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 通常导航栏会隐藏溢出 */</span><br>&#125;<br><br><span class="hljs-selector-class">.menu-list</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">list-style</span>: none;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-comment">/* flex-wrap: nowrap; 是默认值 */</span><br>&#125;<br><br><span class="hljs-selector-class">.menu-item</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">15px</span>;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span>;<br>  <span class="hljs-attribute">white-space</span>: nowrap; <span class="hljs-comment">/* 菜单项文本通常不换行 */</span><br>  <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>; <span class="hljs-comment">/* 允许收缩，但可能不够 */</span><br>&#125;<br><br><span class="hljs-selector-class">.menu-item</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">text-decoration</span>: none;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>问题现象：</strong><br>由于那个特别长的菜单项的存在，它的 <code>min-width: auto</code> 会计算为一个等于其完整文本内容的宽度。即使设置了 <code>flex-shrink: 1</code>，它也拒绝收缩到小于这个宽度。结果是：</p><ol><li>整个 <code>.menu-list</code> 的总宽度超过了 <code>.main-nav</code> 的 600px。</li><li>由于 <code>.main-nav</code> 设置了 <code>overflow: hidden</code>，超出部分（可能是“联系方式”菜单项或其一部分）会被直接隐藏。</li><li>如果没有 <code>overflow: hidden</code>，<code>.menu-list</code> 会直接撑破 <code>.main-nav</code> 的边界。</li></ol><p><strong>解决方案：</strong></p><ul><li><p><strong>方案 A (常用 - 截断文本):</strong> 在 <code>.menu-item</code> 上应用 <code>min-width: 0</code>，并配合文本溢出处理。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.menu-item</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">15px</span>;<br>  <span class="hljs-attribute">border-right</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#eee</span>;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>  <span class="hljs-attribute">flex-shrink</span>: <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">/* --- 关键解决方案 --- */</span><br>  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">0</span>;       <span class="hljs-comment">/* 覆盖 min-width: auto，允许无限收缩 */</span><br>  <span class="hljs-attribute">overflow</span>: hidden;   <span class="hljs-comment">/* 隐藏超出自身边界的内容 */</span><br>  <span class="hljs-attribute">text-overflow</span>: ellipsis; <span class="hljs-comment">/* 显示省略号 */</span><br>  <span class="hljs-comment">/* --- 结束 --- */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>  <strong>效果：</strong> 长菜单项现在可以被压缩了。当它的空间不足以显示全部文本时，<code>overflow: hidden</code> 会隐藏超出部分，<code>text-overflow: ellipsis</code> 会显示 “…”，整体布局得以保持。</p></li><li><p><strong>方案 B (如果允许换行):</strong> 如果设计允许，可以在 <code>.menu-list</code> 上设置 <code>flex-wrap: wrap</code>。但这通常不适用于主导航。</p></li><li><p><strong>方案 C (容器滚动):</strong> 可以在 <code>.main-nav</code> 或 <code>.menu-list</code> 上设置 <code>overflow-x: auto</code>，让导航栏本身可以水平滚动。适用于移动端或次要导航。</p></li></ul><h3 id="场景二：卡片组件内容溢出"><a href="#场景二：卡片组件内容溢出" class="headerlink" title="场景二：卡片组件内容溢出"></a>场景二：卡片组件内容溢出</h3><p><strong>情景描述：</strong><br>你正在创建一个卡片列表（如产品展示、文章列表），每个卡片包含图片、标题、描述等。卡片本身是 Flex 容器或 Flex 子项。卡片内的某个文本区域（如标题或用户名）可能会有很长的、不换行的内容。</p><p><strong>HTML 结构 (简化 - 单个卡片):</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;product.jpg&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Product Image&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-image&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-content&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-title&quot;</span>&gt;</span>一个超级无敌长的产品标题用来测试溢出情况<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-user&quot;</span>&gt;</span>由 VeryLongUsernameWithoutSpaces 发布<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;card-description&quot;</span>&gt;</span>简短描述...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>CSS (可能导致问题):</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.card</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex; <span class="hljs-comment">/* 或者卡片内容区域使用 flex */</span><br>  <span class="hljs-attribute">flex-direction</span>: column; <span class="hljs-comment">/* 或者 row */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ddd</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">8px</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 卡片通常会裁剪内容 */</span><br>&#125;<br><br><span class="hljs-selector-class">.card-content</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">15px</span>;<br>  <span class="hljs-comment">/* 假设 card-content 是 flex item (如果 .card 是 flex container) */</span><br>  <span class="hljs-comment">/* 或者 .card-content 内部元素使用 flex */</span><br>  <span class="hljs-comment">/* 问题可能出在这里的子元素上 */</span><br>&#125;<br><br><span class="hljs-selector-class">.card-title</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">1.2em</span>;<br>  <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-comment">/* 默认 white-space: normal，但如果单词本身长呢？ */</span><br>&#125;<br><br><span class="hljs-selector-class">.card-user</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#777</span>;<br>  <span class="hljs-attribute">white-space</span>: nowrap; <span class="hljs-comment">/* 假设用户名不允许换行 */</span><br>  <span class="hljs-comment">/* 这个元素是潜在的溢出源 */</span><br>&#125;<br><br><span class="hljs-comment">/* 如果 .card-content 使用了 display: flex 来布局标题和用户名等 */</span><br><span class="hljs-selector-class">.card-content</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">flex-direction</span>: column; <span class="hljs-comment">/* 或 row */</span><br>  <span class="hljs-comment">/* ... 其他样式 ... */</span><br>&#125;<br><span class="hljs-selector-class">.card-title</span>, <span class="hljs-selector-class">.card-user</span> &#123;<br> <span class="hljs-comment">/* 如果它们是 flex items */</span><br> <span class="hljs-comment">/* 默认 min-width: auto 会导致问题 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>问题现象：</strong></p><ol><li><strong>长标题 (<code>.card-title</code>)：</strong> 如果标题包含一个非常长的单词（比如技术术语或 URL），即使 <code>white-space: normal</code>，这个长单词本身也构成了最小内容宽度。如果这个宽度大于卡片内容区域的宽度，标题就可能溢出。</li><li><strong>不换行的用户名 (<code>.card-user</code>)：</strong> <code>white-space: nowrap</code> 强制用户名在单行显示，其 <code>min-width: auto</code> 就是完整的用户名宽度。如果用户名过长，它会撑开其容器，甚至溢出卡片。</li></ol><p><strong>解决方案：</strong></p><ul><li><p><strong>针对长单词&#x2F;标题：</strong></p><ul><li>在 <code>.card-title</code> 上添加 <code>overflow-wrap: break-word;</code> 或 <code>word-break: break-all;</code>。这允许浏览器在长单词内部断行。</li><li>如果标题是 Flex 子项，并且因为 <code>min-width: auto</code> 导致溢出（即使允许断词），可能还需要在该 Flex 子项上添加 <code>min-width: 0</code>。</li></ul>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.card-title</span> &#123;<br>  <span class="hljs-comment">/* ... 其他样式 ... */</span><br>  <span class="hljs-attribute">overflow-wrap</span>: break-word; <span class="hljs-comment">/* 优先考虑这个，更智能 */</span><br>  <span class="hljs-comment">/* 如果标题本身是 flex item，且需要它能被压缩 */</span><br>  <span class="hljs-comment">/* min-width: 0; */</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><strong>针对不换行的用户名 (<code>.card-user</code>)：</strong></p><ul><li>这是 <code>min-width: auto</code> 的典型案例。如果 <code>.card-user</code> 或其父级 Flex 项需要收缩但被阻止了：<ul><li>在 <strong>包含</strong> <code>.card-user</code> 的那个 <strong>Flex 子项</strong>上设置 <code>min-width: 0</code>。</li><li>在 <code>.card-user</code> 自身上应用 <code>overflow: hidden;</code> 和 <code>text-overflow: ellipsis;</code> 来优雅地截断。</li></ul></li></ul>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 假设 .card-user 的某个祖先是 flex item，我们叫它 .user-container */</span><br><span class="hljs-selector-class">.user-container</span> &#123; <span class="hljs-comment">/* 或者直接是 .card-user 如果它是 flex item */</span><br>  <span class="hljs-attribute">min-width</span>: <span class="hljs-number">0</span>; <span class="hljs-comment">/* 允许这个区域收缩 */</span><br>&#125;<br><br><span class="hljs-selector-class">.card-user</span> &#123;<br>  <span class="hljs-attribute">white-space</span>: nowrap;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>  <span class="hljs-comment">/* ... 其他样式 ... */</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="场景三：标签-徽章列表"><a href="#场景三：标签-徽章列表" class="headerlink" title="场景三：标签&#x2F;徽章列表"></a>场景三：标签&#x2F;徽章列表</h3><p><strong>情景描述：</strong><br>在一个区域显示多个标签（tags）或徽章（badges），水平排列。当标签数量过多或者屏幕宽度变窄时，它们会超出容器。</p><p><strong>HTML 结构 (简化):</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tags-container&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tag&quot;</span>&gt;</span>JavaScript<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tag&quot;</span>&gt;</span>Flexbox<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tag&quot;</span>&gt;</span>CSS Grid<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tag&quot;</span>&gt;</span>Web Development<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tag&quot;</span>&gt;</span>Responsive Design<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tag&quot;</span>&gt;</span>Accessibility<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tag&quot;</span>&gt;</span>Performance Optimization<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>CSS (可能导致问题):</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.tags-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">8px</span>; <span class="hljs-comment">/* 标签间距 */</span><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>; <span class="hljs-comment">/* 假设容器宽度自适应 */</span><br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed blue;<br>  <span class="hljs-comment">/* flex-wrap: nowrap; (默认) */</span><br>&#125;<br><br><span class="hljs-selector-class">.tag</span> &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span> <span class="hljs-number">8px</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#eee</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">4px</span>;<br>  <span class="hljs-attribute">white-space</span>: nowrap; <span class="hljs-comment">/* 标签文本通常不换行 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>问题现象：</strong><br>当所有标签的宽度（加上 <code>gap</code>）总和超过 <code>.tags-container</code> 的宽度时，由于 <code>flex-wrap: nowrap</code>，标签会继续排在同一行，超出容器右边界。</p><p><strong>解决方案：</strong></p><ul><li><p><strong>方案 A (最常用 - 换行):</strong> 在容器上允许换行。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.tags-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">8px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed blue;<br>  <span class="hljs-comment">/* --- 关键解决方案 --- */</span><br>  <span class="hljs-attribute">flex-wrap</span>: wrap; <span class="hljs-comment">/* 允许标签换到下一行 */</span><br>  <span class="hljs-comment">/* --- 结束 --- */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>  <strong>效果：</strong> 当一行放不下时，标签会自动转到下一行，这是最符合直觉的响应式行为。</p></li><li><p><strong>方案 B (水平滚动):</strong> 如果设计要求所有标签保持单行（例如在特定UI组件中），可以在容器上添加水平滚动。</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.tags-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">8px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> dashed blue;<br>  <span class="hljs-comment">/* --- 关键解决方案 --- */</span><br>  <span class="hljs-attribute">overflow-x</span>: auto; <span class="hljs-comment">/* 提供水平滚动条 */</span><br>  <span class="hljs-comment">/* 可能需要给容器或父元素一个明确的高度，防止滚动条影响布局 */</span><br>  <span class="hljs-comment">/* --- 结束 --- */</span><br>&#125;<br><span class="hljs-comment">/* 为了在触摸设备上更好看，可以隐藏滚动条但保留滚动功能 */</span><br><span class="hljs-selector-class">.tags-container</span>::-webkit-scrollbar &#123;<br>  <span class="hljs-attribute">display</span>: none; <span class="hljs-comment">/* Chrome, Safari, Opera */</span><br>&#125;<br><span class="hljs-selector-class">.tags-container</span> &#123;<br>  -ms-<span class="hljs-attribute">overflow</span>-style: none;  <span class="hljs-comment">/* IE and Edge */</span><br>  <span class="hljs-attribute">scrollbar-width</span>: none;  <span class="hljs-comment">/* Firefox */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>  <strong>效果：</strong> 容器宽度固定，但用户可以左右滑动来查看所有标签。</p></li></ul><h3 id="总结这些例子："><a href="#总结这些例子：" class="headerlink" title="总结这些例子："></a>总结这些例子：</h3><ul><li><strong>内容本身太长</strong>（长单词、URL、<code>white-space: nowrap</code> 的文本）导致 <code>min-width: auto</code> 阻止收缩时，<code>min-width: 0</code> 是核心武器，通常配合 <code>overflow: hidden</code> 和 <code>text-overflow: ellipsis</code> 处理视觉。有时也可用 <code>overflow-wrap</code> &#x2F; <code>word-break</code>。</li><li><strong>子项数量太多</strong> 或 <strong>固定宽度子项总和过大</strong> 导致溢出时，<code>flex-wrap: wrap</code> 是最直接的响应式解决方案，让它们自然流动。</li><li><strong>希望容器处理溢出</strong>（保持子项完整性，但容器滚动）时，在 <strong>父容器</strong> 上使用 <code>overflow: auto</code> 或 <code>overflow: scroll</code>。</li><li><strong>图片或媒体</strong> 溢出其 Flex 项容器时，<code>max-width: 100%</code> 是标准做法。</li></ul><p>通过这些具体的场景，你可以看到同一个 Flexbox 溢出问题，根据上下文和设计需求，可以选择不同的、最合适的解决方案。理解 <code>min-width: auto</code> 的原理是诊断问题的关键，而掌握各种解决策略则能让你灵活应对。”</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端开发</tag>
      
      <tag>布局</tag>
      
      <tag>布局技巧</tag>
      
      <tag>响应式设计</tag>
      
      <tag>Flexbox</tag>
      
      <tag>溢出处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>querySelector 的默认作用域与 :scope 伪类</title>
    <link href="/2025/05/04/querySelector-%E7%9A%84%E9%BB%98%E8%AE%A4%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E-scope-%E4%BC%AA%E7%B1%BB/"/>
    <url>/2025/05/04/querySelector-%E7%9A%84%E9%BB%98%E8%AE%A4%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E-scope-%E4%BC%AA%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>在这篇文章中，我们将系统地回顾如何在 CSS 和 JavaScript 中选中父容器的第 2 个子元素，重点剖析 <code>:nth-child()</code>、<code>:nth-of-type()</code> 与 <code>:scope</code> 三大伪类的差异及其在 <code>querySelector</code> 中的正确用法，并给出最佳实践示例。</p><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><ul><li><strong><code>:nth-child(n)</code></strong> 根据元素在<strong>所有</strong>兄弟节点中的位置进行匹配（计数包括任意类型的子节点） (<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/%3Anth-child?utm_source=chatgpt.com">nth-child() - CSS: Cascading Style Sheets - MDN Web Docs - Mozilla</a>)。</li><li><strong><code>:nth-of-type(n)</code></strong> 则只在同类型元素之间计数，更加稳健（只统计相同标签名的兄弟节点） (<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/%3Anth-of-type?utm_source=chatgpt.com">nth-of-type() - CSS: Cascading Style Sheets - MDN Web Docs - Mozilla</a>)。</li><li>在 JavaScript 中，<code>document.querySelector(&#39;:nth-child(2)&#39;)</code> 会在全局或当前上下文中找到第一个”在其父元素中排名第二”的元素，但不保证是指定容器的直接第 2 个子元素 (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelector?utm_source=chatgpt.com">Element: querySelector() method - Web APIs | MDN</a>)。</li><li>正确方案是对目标容器调用 <code>element.querySelector(&#39;:scope &gt; :nth-child(2)&#39;)</code>，其中 <code>:scope</code> 明确将匹配限定在当前元素，<code>&gt;</code> 表示只匹配<strong>直系</strong>子节点 (<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/%3Ascope?utm_source=chatgpt.com">scope - CSS: Cascading Style Sheets - MDN Web Docs</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll?utm_source=chatgpt.com">Element: querySelectorAll() method - Web APIs | MDN</a>)。</li><li>最直观的替代写法是直接使用 DOM API：<code>element.children[1]</code>（下标从 0 开始） (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll?utm_source=chatgpt.com">Element: querySelectorAll() method - Web APIs | MDN</a>)。</li></ul><hr><h2 id="CSS-伪类：-nth-child-vs-nth-of-type"><a href="#CSS-伪类：-nth-child-vs-nth-of-type" class="headerlink" title="CSS 伪类：:nth-child() vs :nth-of-type()"></a>CSS 伪类：<code>:nth-child()</code> vs <code>:nth-of-type()</code></h2><h3 id="nth-child-的工作原理"><a href="#nth-child-的工作原理" class="headerlink" title=":nth-child() 的工作原理"></a><code>:nth-child()</code> 的工作原理</h3><ul><li><code>:nth-child(n)</code> 按照父元素的子节点列表顺序进行计数，所有类型的节点都参与排名，索引从 1 开始 (<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/%3Anth-child?utm_source=chatgpt.com">nth-child() - CSS: Cascading Style Sheets - MDN Web Docs - Mozilla</a>)。</li><li>常见用法包括数字（如 <code>:nth-child(2)</code>），关键字 <code>odd</code>&#x2F;<code>even</code>，以及公式 An+B（如 <code>2n+1</code>，表示所有奇数位） (<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/%3Anth-child?utm_source=chatgpt.com">nth-child() - CSS: Cascading Style Sheets - MDN Web Docs - Mozilla</a>)。</li></ul><h3 id="nth-of-type-的优势"><a href="#nth-of-type-的优势" class="headerlink" title=":nth-of-type() 的优势"></a><code>:nth-of-type()</code> 的优势</h3><ul><li><code>:nth-of-type(n)</code> 仅在同类型（标签名相同）的兄弟节点中进行计数，过滤掉中间不同标签的干扰，更适合”选中第 n 个段落””第 n 行表格”等场景 (<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/%3Anth-of-type?utm_source=chatgpt.com">nth-of-type() - CSS: Cascading Style Sheets - MDN Web Docs - Mozilla</a>)。</li><li>在 DOM 结构频繁变化或含插入元素时，<code>:nth-of-type()</code> 通常比 <code>:nth-child()</code> 更不易出错 (<a href="https://css-tricks.com/the-difference-between-nth-child-and-nth-of-type/?utm_source=chatgpt.com">The Difference Between :nth-child and :nth-of-type - CSS-Tricks</a>)。</li></ul><hr><h2 id="querySelector-的默认作用域与-scope-伪类"><a href="#querySelector-的默认作用域与-scope-伪类" class="headerlink" title="querySelector 的默认作用域与 :scope 伪类"></a><code>querySelector</code> 的默认作用域与 <code>:scope</code> 伪类</h2><h3 id="querySelector-在-Element-与-Document-上的差异"><a href="#querySelector-在-Element-与-Document-上的差异" class="headerlink" title="querySelector 在 Element 与 Document 上的差异"></a><code>querySelector</code> 在 Element 与 Document 上的差异</h3><ul><li><code>Document.querySelector(selector)</code> 返回文档中第一个匹配 <code>selector</code> 的元素 (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector?utm_source=chatgpt.com">Document: querySelector() method - Web APIs | MDN</a>)。</li><li><code>Element.querySelector(selector)</code> 则在该元素的整个子树（<strong>所有</strong>后代）中查找第一个匹配项，同样不限制深度，也不限定仅直系子节点 (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelector?utm_source=chatgpt.com">Element: querySelector() method - Web APIs | MDN</a>)。</li></ul><h3 id="为什么需要-scope"><a href="#为什么需要-scope" class="headerlink" title="为什么需要 :scope"></a>为什么需要 <code>:scope</code></h3><ul><li>默认情况下，<code>querySelectorAll()</code> 与 <code>querySelector()</code> 在 Element 上调用时，选择器仍会匹配整个后代树，而不是仅限直系子节点。要限定作用域，必须在选择器前加上 <code>:scope</code> (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll?utm_source=chatgpt.com">Element: querySelectorAll() method - Web APIs | MDN</a>)。</li><li><code>:scope</code> 伪类在选择器中代表当前正在调用 <code>querySelector</code> 的元素本身，使得随后使用的子选择符（如 <code>&gt; ...</code>）都从该元素开始计算 (<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/%3Ascope?utm_source=chatgpt.com">scope - CSS: Cascading Style Sheets - MDN Web Docs</a>)。</li></ul><hr><h2 id="实战：选中容器的第-2-个子元素"><a href="#实战：选中容器的第-2-个子元素" class="headerlink" title="实战：选中容器的第 2 个子元素"></a>实战：选中容器的第 2 个子元素</h2><h3 id="方法一：纯-CSS（只在样式表中）"><a href="#方法一：纯-CSS（只在样式表中）" class="headerlink" title="方法一：纯 CSS（只在样式表中）"></a>方法一：纯 CSS（只在样式表中）</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 仅在样式表中：选中 parent-container 的第2个 div 直系子元素 */</span><br><span class="hljs-selector-class">.parent-container</span> &gt; <span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(<span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-comment">/* 样式规则 */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="方法二：JavaScript-scope"><a href="#方法二：JavaScript-scope" class="headerlink" title="方法二：JavaScript + :scope"></a>方法二：JavaScript + <code>:scope</code></h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 获取目标容器</span><br><span class="hljs-keyword">const</span> feed = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;[role=&quot;feed&quot;]&#x27;</span>);<br><span class="hljs-comment">// 选中其第2个直系子元素</span><br><span class="hljs-keyword">const</span> secondChild = feed.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;:scope &gt; :nth-child(2)&#x27;</span>);<br><br></code></pre></td></tr></table></figure><ul><li><code>:scope</code> 保证 <code>&gt;</code> 之后的 <code>:nth-child(2)</code> 只在 <code>feed</code> 的直接子节点里生效，而不会误匹配深层嵌套的节点 (<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/%3Ascope?utm_source=chatgpt.com">scope - CSS: Cascading Style Sheets - MDN Web Docs</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll?utm_source=chatgpt.com">Element: querySelectorAll() method - Web APIs | MDN</a>)。</li></ul><h3 id="方法三：DOM-API（最简洁）"><a href="#方法三：DOM-API（最简洁）" class="headerlink" title="方法三：DOM API（最简洁）"></a>方法三：DOM API（最简洁）</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">const</span> feed = <span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">&#x27;[role=&quot;feed&quot;]&#x27;</span>);<br><span class="hljs-comment">// children 返回仅直系子元素的集合，索引从0开始</span><br><span class="hljs-keyword">const</span> secondChild = feed.children[<span class="hljs-number">1</span>];<br><br></code></pre></td></tr></table></figure><ul><li><code>children</code> 返回 <code>HTMLCollection</code>，它只包含 Element 类型的直系子节点，不含文本或注释节点，读取速度也更快 (<a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll?utm_source=chatgpt.com">Element: querySelectorAll() method - Web APIs | MDN</a>)。</li></ul><hr><h2 id="小结与规范建议"><a href="#小结与规范建议" class="headerlink" title="小结与规范建议"></a>小结与规范建议</h2><ol><li><strong>选中同类型的第 n 个元素</strong>：优先使用 <code>:nth-of-type(n)</code>；</li><li><strong>选中所有类型的第 n 个子元素</strong>：使用 <code>:nth-child(n)</code>；</li><li><strong>在 JS 中严格限定父容器范围</strong>：在 <code>querySelector</code> 内部请加上 <code>:scope</code>，并使用子选择符 <code>&gt;</code>；</li><li><strong>性能和可读性</strong>：若仅需获取元素节点，<code>element.children[ index ]</code> 简洁高效。</li></ol><p>通过正确理解各伪类计数范围及 <code>querySelector</code> 的作用域，你可以在开发复杂布局或动态脚本时，既保证选择器的准确性，又提升代码可维护性。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>JavaScript</tag>
      
      <tag>DOM</tag>
      
      <tag>选择器</tag>
      
      <tag>querySelector</tag>
      
      <tag>伪类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clip-path与transform：scale使用顺序不同会造成结果不同吗？</title>
    <link href="/2025/04/22/clip-path%E4%B8%8Etransform%EF%BC%9Ascale%E4%BD%BF%E7%94%A8%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C%E4%BC%9A%E9%80%A0%E6%88%90%E7%BB%93%E6%9E%9C%E4%B8%8D%E5%90%8C%E5%90%97%EF%BC%9F/"/>
    <url>/2025/04/22/clip-path%E4%B8%8Etransform%EF%BC%9Ascale%E4%BD%BF%E7%94%A8%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C%E4%BC%9A%E9%80%A0%E6%88%90%E7%BB%93%E6%9E%9C%E4%B8%8D%E5%90%8C%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>在CSS中，<code>clip-path</code>和<code>transform</code>是两个常用的属性，它们分别用于裁剪元素和进行变换操作。然而，对于同一个元素，先应用<code>scale</code>再应用<code>clip-path</code>，还是先应用<code>clip-path</code>再应用<code>scale</code>，是否有区别呢？答案是<strong>没有区别</strong>。这背后的原因在于CSS的渲染机制，它决定了这两个属性的应用顺序是固定的：总是先应用<code>clip-path</code>，然后再应用<code>transform</code>（包括<code>scale</code>）。</p><h3 id="CSS渲染机制的解释"><a href="#CSS渲染机制的解释" class="headerlink" title="CSS渲染机制的解释"></a>CSS渲染机制的解释</h3><p>在CSS的渲染流水线中，浏览器会按照一定的顺序来处理元素的样式和布局。具体来说，渲染过程大致分为以下几个阶段：创建DOM、计算CSS样式、布局（Layout）、绘制（Paint）和合成（Composite）。<code>clip-path</code>和<code>transform</code>这两个属性主要影响“绘制”阶段。</p><p>在绘制阶段内部，浏览器首先会根据元素的样式（包括<code>clip-path</code>）来绘制内容。<code>clip-path</code>定义了一个裁剪路径，裁剪的是元素未经过变换的原始内容区域（即基于元素的content box）。之后，<code>transform</code>（如<code>scale</code>）会在绘制完成后应用，缩放已经裁剪好的内容。</p><h3 id="为什么没有区别？"><a href="#为什么没有区别？" class="headerlink" title="为什么没有区别？"></a>为什么没有区别？</h3><p>无论你在CSS中如何书写代码（例如，先写<code>transform: scale(2)</code>再写<code>clip-path: circle(50px)</code>，还是反过来），实际的渲染效果总是：</p><ol><li>先根据<code>clip-path</code>裁剪元素的原始内容，</li><li>然后对裁剪后的结果应用<code>scale</code>变换。</li></ol><p>这种顺序是CSS规范固有的，无法通过调整属性声明顺序改变。</p><h3 id="具体例子"><a href="#具体例子" class="headerlink" title="具体例子"></a>具体例子</h3><p>假设有一个<code>div</code>，样式如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">circle</span>(<span class="hljs-number">50px</span>);<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>渲染过程是：</p><ol><li><strong>原始尺寸</strong>：<code>div</code>的宽度和高度为100px。</li><li>**应用<code>clip-path</code>**：<code>clip-path: circle(50px)</code>裁剪出一个半径为50px的圆形（直径100px），基于元素的原始尺寸。</li><li>**应用<code>scale</code>**：<code>transform: scale(2)</code>将裁剪后的圆形放大2倍，最终呈现为直径200px的圆形。</li></ol><p>无论你将<code>transform</code>写在<code>clip-path</code>之前还是之后，结果都是相同的，因为<code>clip-path</code>总是基于未变换的元素尺寸进行裁剪，然后<code>scale</code>作用于裁剪后的内容。</p><h3 id="概念上的顺序差异"><a href="#概念上的顺序差异" class="headerlink" title="概念上的顺序差异"></a>概念上的顺序差异</h3><p>如果从概念上考虑，先<code>scale</code>再<code>clip-path</code>与先<code>clip-path</code>再<code>scale</code>确实可能产生不同的效果：</p><ul><li>**先<code>scale</code>再<code>clip-path</code>**：先放大内容，再裁剪放大后的区域。</li><li>**先<code>clip-path</code>再<code>scale</code>**：先裁剪原始内容，再放大裁剪结果。</li></ul><p>然而，在CSS中，这种概念上的顺序无法直接实现，因为<code>clip-path</code>和<code>transform</code>的渲染顺序固定。</p><h3 id="嵌套元素的情况"><a href="#嵌套元素的情况" class="headerlink" title="嵌套元素的情况"></a>嵌套元素的情况</h3><p>如果通过嵌套元素间接实现不同顺序（例如，父元素应用<code>scale</code>，子元素应用<code>clip-path</code>，或者反过来），则可能会有视觉上的差异：</p><ul><li>**父元素<code>scale</code>，子元素<code>clip-path</code>**：子元素先被裁剪，然后整体随父元素放大。</li><li>**父元素<code>clip-path</code>，子元素<code>scale</code>**：子元素先放大，然后被父元素的裁剪区域限制。</li></ul><p>父元素 <code>scale</code>（缩放）、子元素 <code>clip-path</code>（裁剪路径）与父元素 <code>clip-path</code>、子元素 <code>scale</code> 的结果<strong>不一致</strong>。这两种情况在视觉效果上会有所不同，原因在于 CSS 中 <code>transform</code>（变换）和 <code>clip-path</code> 的应用顺序以及它们对元素及其子元素的影响方式不同。下面我将详细解释这两种情况的渲染过程和差异。</p><hr><h3 id="情况1：父元素-scale，子元素-clip-path"><a href="#情况1：父元素-scale，子元素-clip-path" class="headerlink" title="情况1：父元素 scale，子元素 clip-path"></a><strong>情况1：父元素 <code>scale</code>，子元素 <code>clip-path</code></strong></h3><ul><li>**父元素的 <code>scale</code>**：当父元素应用 <code>transform: scale()</code>（例如 <code>scale(2)</code>）时，它会缩放自身的尺寸以及所有子元素的视觉内容。假设子元素原始尺寸是 50px × 50px，父元素缩放 2 倍后，子元素的视觉尺寸会变成 100px × 100px。</li><li><strong>子元素的 <code>clip-path</code><strong>：子元素应用 <code>clip-path</code>（例如 <code>clip-path: circle(25px)</code>）时，裁剪是基于子元素</strong>缩放后</strong>的尺寸计算的。在这个例子中，子元素缩放后是 100px × 100px，<code>circle(25px)</code> 会裁剪出一个直径 50px 的圆形（因为半径 25px × 2 &#x3D; 50px），位于缩放后子元素的中心。</li><li><strong>最终效果</strong>：子元素被放大到 100px × 100px，然后在这个放大后的区域上裁剪出一个直径 50px 的圆形。</li></ul><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">circle</span>(<span class="hljs-number">25px</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="情况2：父元素-clip-path，子元素-scale"><a href="#情况2：父元素-clip-path，子元素-scale" class="headerlink" title="情况2：父元素 clip-path，子元素 scale"></a><strong>情况2：父元素 <code>clip-path</code>，子元素 <code>scale</code></strong></h3><ul><li><strong>父元素的 <code>clip-path</code><strong>：当父元素应用 <code>clip-path</code>（例如 <code>clip-path: circle(50px)</code>）时，它会基于父元素</strong>未缩放</strong>的尺寸裁剪内容。假设父元素尺寸是 100px × 100px，<code>circle(50px)</code> 会裁剪出一个直径 100px 的圆形，所有子元素的内容都会被限制在这个圆形区域内。</li><li>**子元素的 <code>scale</code>**：子元素应用 <code>transform: scale(2)</code> 时，其原始尺寸（例如 50px × 50px）会被放大到 100px × 100px。但由于父元素已经被裁剪为一个圆形，子元素的缩放效果只能在父元素的裁剪区域内显示，超出部分会被裁剪掉。</li><li><strong>最终效果</strong>：子元素放大到 100px × 100px，但只有父元素裁剪圆形（直径 100px）内的部分可见。</li></ul><h3 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">clip-path</span>: <span class="hljs-built_in">circle</span>(<span class="hljs-number">50px</span>);<br>&#125;<br><span class="hljs-selector-class">.child</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">2</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h3 id="两者的差异"><a href="#两者的差异" class="headerlink" title="两者的差异"></a><strong>两者的差异</strong></h3><ul><li><strong>情况1（父 <code>scale</code>，子 <code>clip-path</code>）</strong>：先缩放整个父元素（包括子元素），然后在缩放后的子元素上应用裁剪。裁剪区域是基于缩放后的尺寸计算的，因此裁剪效果与缩放比例直接相关。</li><li><strong>情况2（父 <code>clip-path</code>，子 <code>scale</code>）</strong>：先对父元素应用裁剪，然后在裁剪后的区域内缩放子元素。子元素的缩放效果会被父元素的裁剪边界限制，超出部分不可见。</li></ul><h3 id="视觉效果对比"><a href="#视觉效果对比" class="headerlink" title="视觉效果对比"></a><strong>视觉效果对比</strong></h3><ul><li>在情况1中，子元素的裁剪圆形直径是 50px，相对于缩放后的 100px × 100px，显得较小。</li><li>在情况2中，子元素放大到 100px × 100px，但被父元素的 100px 直径圆形裁剪，显示区域受到父元素限制。</li></ul><hr><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a><strong>结论</strong></h3><p>父元素 <code>scale</code>、子元素 <code>clip-path</code> 与父元素 <code>clip-path</code>、子元素 <code>scale</code> 的结果<strong>不一致</strong>。前者是先缩放再裁剪子元素，后者是先裁剪父元素再缩放子元素，这导致两者的视觉效果存在明显差异。</p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>对于同一个元素，在CSS中先<code>scale</code>再<code>clip-path</code>与先<code>clip-path</code>再<code>scale</code>没有区别。因为无论代码如何编写，CSS的渲染顺序总是先应用<code>clip-path</code>裁剪，再应用<code>transform</code>（包括<code>scale</code>）进行变换。这一顺序是由W3C的CSS规范所规定，浏览器厂商据此来实现其渲染引擎，确保了裁剪区域的定义基于一个稳定、未经变换的几何参考框，使得变换的效果符合直觉。</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>clip-path</tag>
      
      <tag>transform</tag>
      
      <tag>scale</tag>
      
      <tag>渲染机制</tag>
      
      <tag>浏览器渲染</tag>
      
      <tag>CSS布局</tag>
      
      <tag>视觉效果</tag>
      
      <tag>前端性能</tag>
      
      <tag>DOM渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 HTML 拖放 API：用 React Hook 打造交互式体验</title>
    <link href="/2025/04/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-HTML-%E6%8B%96%E6%94%BE-API%EF%BC%9A%E7%94%A8-React-Hook-%E6%89%93%E9%80%A0%E4%BA%A4%E4%BA%92%E5%BC%8F%E4%BD%93%E9%AA%8C/"/>
    <url>/2025/04/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-HTML-%E6%8B%96%E6%94%BE-API%EF%BC%9A%E7%94%A8-React-Hook-%E6%89%93%E9%80%A0%E4%BA%A4%E4%BA%92%E5%BC%8F%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<p>在现代 Web 开发中，提供直观且用户友好的交互是至关重要的。HTML 拖放（Drag and Drop）API 就是一个强大的工具，它允许用户通过鼠标（或其他指针设备）选择可拖动元素，将其拖动到可放置区域，并释放以完成放置操作。这为文件上传、列表排序、界面定制等场景提供了自然的交互方式。</p><p>本文将深入探讨 HTML 拖放 API 的核心概念，并通过一个实际的 React 自定义 Hook (<code>useDraggable</code>) 示例，展示如何封装和管理拖放逻辑，让你的应用更加生动有趣。</p><h3 id="HTML-拖放-API-核心事件"><a href="#HTML-拖放-API-核心事件" class="headerlink" title="HTML 拖放 API 核心事件"></a>HTML 拖放 API 核心事件</h3><p>整个拖放过程由一系列事件驱动，这些事件发生在<strong>被拖动的元素</strong>和<strong>潜在的放置目标</strong>上。理解这些事件是掌握拖放 API 的关键：</p><p><strong>发生在被拖动元素上的事件:</strong></p><ol><li><code>dragstart</code>: 当用户开始拖动一个元素时触发。这是设置拖动数据（例如被拖动项的 ID）和视觉效果（如半透明效果、自定义拖动图像）的理想时机。</li><li><code>drag</code>: 在元素被拖动期间连续触发。</li><li><code>dragend</code>: 当用户释放鼠标按钮，拖动操作结束时触发（无论是否成功放置）。用于清理状态，例如移除拖动时的特殊样式。</li></ol><p><strong>发生在放置目标上的事件:</strong></p><ol><li><code>dragenter</code>: 当被拖动的元素首次进入一个有效的放置目标元素的边界时触发。通常用于给放置目标添加高亮样式，提示用户此处可以放置。</li><li><code>dragover</code>: 当被拖动的元素在一个有效的放置目标元素上移动时连续触发。<strong>关键点：</strong> 必须在此事件的处理函数中调用 <code>event.preventDefault()</code>，否则浏览器默认不允许放置（drop）操作。同时，可以通过 <code>event.dataTransfer.dropEffect</code> 指定期望的放置效果（如 ‘move’, ‘copy’, ‘link’）。</li><li><code>dragleave</code>: 当被拖动的元素离开一个有效的放置目标元素的边界时触发。通常用于移除 <code>dragenter</code> 时添加的高亮样式。</li><li><code>drop</code>: 当用户在有效的放置目标上释放鼠标按钮时触发。这是执行实际放置逻辑的地方，例如获取拖动数据、重新排序列表项等。<strong>关键点：</strong> 也需要调用 <code>event.preventDefault()</code> 来阻止浏览器的默认行为（例如，对于链接或图片，默认行为可能是打开它们）。</li></ol><h3 id="实战：useDraggable-React-Hook-解析"><a href="#实战：useDraggable-React-Hook-解析" class="headerlink" title="实战：useDraggable React Hook 解析"></a>实战：<code>useDraggable</code> React Hook 解析</h3><p>现在，我们封装拖放逻辑的 React 自定义 Hook<code>src/hooks/useDraggble.ts</code> 代码。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> &#123; useRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useDraggable</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 使用 useRef 存储拖动过程中的状态，避免不必要的重渲染</span><br>  <span class="hljs-keyword">const</span> draggedItemIndex = useRef&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 记录被拖动项的 ID</span><br>  <span class="hljs-keyword">const</span> dragOverItemIndex = useRef&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 记录当前鼠标悬停在其上方的放置目标项的 ID</span><br><br>  <span class="hljs-comment">// --- 事件处理函数 ---</span><br><br>  <span class="hljs-comment">// 在放置目标上拖动时持续触发</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDragOver</span> = (<span class="hljs-params"><span class="hljs-attr">e</span>: <span class="hljs-title class_">React</span>.<span class="hljs-title class_">DragEvent</span>&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;</span>) =&gt; &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// 必须阻止默认行为，才允许 drop</span><br>    e.<span class="hljs-property">dataTransfer</span>.<span class="hljs-property">dropEffect</span> = <span class="hljs-string">&#x27;move&#x27;</span>; <span class="hljs-comment">// 设置放置效果为“移动”</span><br>    <span class="hljs-comment">//console.log(&#x27;DragOver:&#x27;, &#123; dragOverItemIndex: dragOverItemIndex.current &#125;);</span><br>  &#125;;<br><br>  <span class="hljs-comment">// 进入放置目标时触发</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDragEnter</span> = (<span class="hljs-params"><span class="hljs-attr">e</span>: <span class="hljs-title class_">React</span>.<span class="hljs-title class_">DragEvent</span>&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;, <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    e.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;drag-over&#x27;</span>); <span class="hljs-comment">// 添加高亮样式</span><br>    dragOverItemIndex.<span class="hljs-property">current</span> = id; <span class="hljs-comment">// 记录鼠标进入的目标 ID</span><br>    <span class="hljs-comment">// ... console.log ...</span><br>  &#125;;<br><br>  <span class="hljs-comment">// 离开放置目标时触发</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDragLeave</span> = (<span class="hljs-params"><span class="hljs-attr">e</span>: <span class="hljs-title class_">React</span>.<span class="hljs-title class_">DragEvent</span>&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;</span>) =&gt; &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    e.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;drag-over&#x27;</span>); <span class="hljs-comment">// 移除高亮样式</span><br>    <span class="hljs-comment">// ... console.log ...</span><br>  &#125;;<br><br>  <span class="hljs-comment">// 拖动结束时在被拖动元素上触发</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDragEnd</span> = (<span class="hljs-params"><span class="hljs-attr">e</span>: <span class="hljs-title class_">React</span>.<span class="hljs-title class_">DragEvent</span>&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> draggableElem = e.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">parentElement</span>; <span class="hljs-comment">// 获取父元素（假设父元素是真正被拖动的容器）</span><br><br>    e.<span class="hljs-property">dataTransfer</span>.<span class="hljs-title function_">clearData</span>(); <span class="hljs-comment">// 清理拖动数据（虽然本例没设置，但这是个好习惯）</span><br>    <span class="hljs-comment">// 移除所有可能存在的 drag-over 样式</span><br>    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;div[id^=&quot;column-edit-box-&quot;]&#x27;</span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>      item.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;drag-over&#x27;</span>);<br>    &#125;);<br>    e.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;drag-over&#x27;</span>); <span class="hljs-comment">// 确保自身也移除</span><br><br>    <span class="hljs-keyword">if</span> (draggableElem) &#123;<br>      draggableElem.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;dragging&#x27;</span>); <span class="hljs-comment">// 移除拖动过程中的样式</span><br>    &#125;<br>    <span class="hljs-comment">// ... console.log ...</span><br><br>    <span class="hljs-comment">// 重置状态</span><br>    draggedItemIndex.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;<br>    dragOverItemIndex.<span class="hljs-property">current</span> = <span class="hljs-literal">null</span>;<br>  &#125;;<br><br>  <span class="hljs-comment">// 开始拖动时在被拖动元素上触发</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDragStart</span> = (<span class="hljs-params"><span class="hljs-attr">e</span>: <span class="hljs-title class_">React</span>.<span class="hljs-title class_">DragEvent</span>&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;, <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> draggableElem = e.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">parentElement</span>;<br>    draggedItemIndex.<span class="hljs-property">current</span> = id; <span class="hljs-comment">// 记录被拖动项的 ID</span><br><br>    <span class="hljs-keyword">if</span> (draggableElem) &#123;<br>      draggableElem.<span class="hljs-property">classList</span>.<span class="hljs-title function_">add</span>(<span class="hljs-string">&#x27;dragging&#x27;</span>); <span class="hljs-comment">// 添加拖动过程中的样式</span><br>      <span class="hljs-comment">// --- 自定义拖动图像 ---</span><br>      <span class="hljs-keyword">const</span> rect = e.<span class="hljs-property">currentTarget</span>.<span class="hljs-title function_">getBoundingClientRect</span>();<br>      <span class="hljs-keyword">const</span> offsetX = e.<span class="hljs-property">clientX</span> - rect.<span class="hljs-property">left</span>;<br>      <span class="hljs-keyword">const</span> offsetY = e.<span class="hljs-property">clientY</span> - rect.<span class="hljs-property">top</span>;<br>      <span class="hljs-comment">// 使用父元素作为拖动预览图，并设置鼠标指针相对预览图的位置</span><br>      e.<span class="hljs-property">dataTransfer</span>.<span class="hljs-title function_">setDragImage</span>(draggableElem, offsetX, offsetY);<br>      <span class="hljs-comment">// --- ---</span><br>    &#125;<br>    e.<span class="hljs-property">dataTransfer</span>.<span class="hljs-property">effectAllowed</span> = <span class="hljs-string">&#x27;move&#x27;</span>; <span class="hljs-comment">// 允许的拖动效果</span><br>    <span class="hljs-comment">// ... console.log ...</span><br>  &#125;;<br><br>  <span class="hljs-comment">// 在放置目标上释放鼠标时触发</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDrop</span> = (<span class="hljs-params"><span class="hljs-attr">e</span>: <span class="hljs-title class_">React</span>.<span class="hljs-title class_">DragEvent</span>&lt;<span class="hljs-title class_">HTMLDivElement</span>&gt;, <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> startIndex = draggedItemIndex.<span class="hljs-property">current</span>; <span class="hljs-comment">// 获取拖动开始项的 ID</span><br>    <span class="hljs-keyword">const</span> endIndex = id; <span class="hljs-comment">// 获取放置目标项的 ID</span><br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    e.<span class="hljs-property">currentTarget</span>.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;drag-over&#x27;</span>); <span class="hljs-comment">// 移除放置目标的高亮</span><br><br>    <span class="hljs-comment">// ... console.log ...</span><br><br>    <span class="hljs-comment">// 拖拽到无效位置或自身则不处理</span><br>    <span class="hljs-keyword">if</span> (startIndex === <span class="hljs-literal">null</span> || startIndex === endIndex) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Invalid drop: same position or null start index&#x27;</span>);<br>      <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 在这里可以添加实际的列表项重新排序逻辑</span><br>    &#125;<br><br>    <span class="hljs-comment">// 在此处理实际的放置逻辑，例如更新状态、调用 API 等</span><br>    <span class="hljs-comment">// 例如： reorderList(startIndex, endIndex);</span><br>  &#125;;<br><br>  <span class="hljs-comment">// 返回所有事件处理函数和状态引用</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    draggedItemIndex,<br>    dragOverItemIndex,<br>    handleDragOver,<br>    handleDragEnter,<br>    handleDragLeave,<br>    handleDragEnd,<br>    handleDragStart,<br>    handleDrop,<br>  &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>代码亮点解析:</strong></p><ol><li><strong>状态管理 (<code>useRef</code>)</strong>: 使用 <code>useRef</code> 来存储 <code>draggedItemIndex</code> 和 <code>dragOverItemIndex</code>。这很巧妙，因为这些值的变化只在拖放操作的生命周期内重要，不需要触发组件的重新渲染。</li><li><strong>阻止默认行为 (<code>preventDefault</code>)</strong>: 在 <code>handleDragOver</code> 和 <code>handleDrop</code> 中调用 <code>e.preventDefault()</code> 是实现拖放的关键。忘记调用它会导致 <code>drop</code> 事件不会触发。</li><li><strong>视觉反馈 (CSS Classes)</strong>: 通过添加&#x2F;移除 <code>dragging</code> 和 <code>drag-over</code> CSS 类，为用户提供清晰的视觉反馈，告知哪个元素正在被拖动，以及哪个区域是有效的放置目标。</li><li><strong><code>dataTransfer</code> 对象</strong>:<ul><li><code>e.dataTransfer.effectAllowed = &#39;move&#39;</code>: 在 <code>handleDragStart</code> 中设置，表明允许的拖动类型是“移动”。</li><li><code>e.dataTransfer.dropEffect = &#39;move&#39;</code>: 在 <code>handleDragOver</code> 中设置，向用户指示如果在此处放置，将会发生“移动”操作。</li><li><code>e.dataTransfer.setDragImage(...)</code>: 在 <code>handleDragStart</code> 中，使用 <code>setDragImage</code> 创建了一个自定义的拖动预览图，而不是使用默认的浏览器效果。这提升了用户体验。</li><li><code>e.dataTransfer.clearData()</code>: 在 <code>handleDragEnd</code> 中调用，虽然这个例子没有显式设置数据，但清除 <code>DataTransfer</code> 对象是一个好习惯。在需要传递数据的场景下（例如拖动元素的 ID），会在 <code>dragstart</code> 时使用 <code>e.dataTransfer.setData(&#39;text/plain&#39;, id)</code> 设置数据，在 <code>drop</code> 时使用 <code>e.dataTransfer.getData(&#39;text/plain&#39;)</code> 获取数据。</li></ul></li><li><strong>逻辑分离</strong>: 将所有拖放相关的逻辑封装在一个 Hook 中，使得组件代码更清晰，并且这个 Hook 可以在项目的不同部分复用。</li><li><strong>放置逻辑 (<code>handleDrop</code>)</strong>: <code>handleDrop</code> 函数是执行最终操作的地方。它获取了拖动开始项 (<code>startIndex</code>) 和放置目标项 (<code>endIndex</code>) 的 ID。虽然示例代码中只打印了日志并做了基本校验，但在实际应用中，这里会包含更新数据状态（如数组重新排序）、调用 API 保存更改等核心逻辑。</li></ol><h3 id="如何在组件中使用-useDraggable"><a href="#如何在组件中使用-useDraggable" class="headerlink" title="如何在组件中使用 useDraggable"></a>如何在组件中使用 <code>useDraggable</code></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useDraggable &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./useDraggable&#x27;</span>; <span class="hljs-comment">// 引入 Hook</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">DraggableList</span>(<span class="hljs-params">&#123; items, setItems &#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> &#123;<br>    handleDragStart,<br>    handleDragEnter,<br>    handleDragLeave,<br>    handleDragOver,<br>    handleDrop,<br>    handleDragEnd,<br>  &#125; = <span class="hljs-title function_">useDraggable</span>(); <span class="hljs-comment">// 在组件中使用 Hook</span><br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleActualDrop</span> = (<span class="hljs-params">draggedId, targetId</span>) =&gt; &#123;<br>    <span class="hljs-comment">// 这里实现具体的列表项重排逻辑</span><br>    <span class="hljs-keyword">const</span> draggedIndex = items.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === draggedId);<br>    <span class="hljs-keyword">const</span> targetIndex = items.<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">id</span> === targetId);<br><br>    <span class="hljs-keyword">if</span> (draggedIndex === -<span class="hljs-number">1</span> || targetIndex === -<span class="hljs-number">1</span> || draggedIndex === targetIndex) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> newItems = [...items];<br>    <span class="hljs-keyword">const</span> [removed] = newItems.<span class="hljs-title function_">splice</span>(draggedIndex, <span class="hljs-number">1</span>);<br>    newItems.<span class="hljs-title function_">splice</span>(targetIndex, <span class="hljs-number">0</span>, removed);<br>    <span class="hljs-title function_">setItems</span>(newItems); <span class="hljs-comment">// 更新状态</span><br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      &#123;items.map((item) =&gt; (</span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;item.id&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">id</span>=<span class="hljs-string">&#123;</span>`<span class="hljs-attr">column-edit-box-</span>$&#123;<span class="hljs-attr">item.id</span>&#125;`&#125; // <span class="hljs-attr">ID</span> <span class="hljs-attr">用于</span> <span class="hljs-attr">Hook</span> <span class="hljs-attr">内部逻辑和样式选择器</span></span></span><br><span class="hljs-tag"><span class="language-xml">          <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;list-item-container&quot;</span> // <span class="hljs-attr">包含拖动手柄和内容的容器</span></span></span><br><span class="hljs-tag"><span class="language-xml">          // <span class="hljs-attr">style</span>=<span class="hljs-string">&#123;&#123;</span> <span class="hljs-attr">opacity:</span> <span class="hljs-attr">1</span> &#125;&#125; // <span class="hljs-attr">可以通过</span> <span class="hljs-attr">dragging</span> <span class="hljs-attr">类来控制透明度</span></span></span><br><span class="hljs-tag"><span class="language-xml">        &gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">div</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">draggable</span> // <span class="hljs-attr">使这个元素</span>（<span class="hljs-attr">通常是拖动图标或整个项</span>）<span class="hljs-attr">可拖动</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onDragStart</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> handleDragStart(e, item.id)&#125;</span><br><span class="language-xml">            onDragEnd=&#123;handleDragEnd&#125; // 监听拖动结束</span><br><span class="language-xml">            // --- 将放置事件监听器也放在这里，允许项目之间互相放置 ---</span><br><span class="language-xml">            onDragEnter=&#123;(e) =&gt; handleDragEnter(e, item.id)&#125;</span><br><span class="language-xml">            onDragLeave=&#123;handleDragLeave&#125;</span><br><span class="language-xml">            onDragOver=&#123;handleDragOver&#125; // 必须监听 Over 才能 Drop</span><br><span class="language-xml">            onDrop=&#123;(e) =&gt; &#123;</span><br><span class="language-xml">                // 从 Hook 的 useRef 中获取拖动源 ID</span><br><span class="language-xml">                const startIndex = handleDrop(e, item.id); // handleDrop 现在只做基础处理和返回 startIndex</span><br><span class="language-xml">                if (startIndex) &#123; // 确保 handleDrop 返回了有效的 startIndex</span><br><span class="language-xml">                    handleActualDrop(startIndex.current, item.id);</span><br><span class="language-xml">                &#125;</span><br><span class="language-xml">                // 重置 useRef 中的状态（或者在 handleDragEnd 中统一处理）</span><br><span class="language-xml">            &#125;&#125;</span><br><span class="language-xml">            className=&quot;drag-handle&quot; // 或者整个 list-item-content</span><br><span class="language-xml">          &gt;</span><br><span class="language-xml">             &#123;/* 拖动图标或可拖动内容 */&#125;</span><br><span class="language-xml">             &#123;item.content&#125;</span><br><span class="language-xml">          <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">          &#123;/* 其他列表项内容 */&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      ))&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">DraggableList</span>;<br><br></code></pre></td></tr></table></figure><p><em>注意：</em> 上述 <code>DraggableList</code> 组件代码需要根据 <code>useDraggable</code> hook 的返回值和内部逻辑进行调整，特别是 <code>handleDrop</code> 的处理方式。原始的 <code>handleDrop</code> 似乎直接在 hook 内部处理逻辑，但在 React 组件中，通常将状态更新逻辑放在组件内部，因此需要调整 hook 的 <code>handleDrop</code>，使其可能只负责 <code>preventDefault</code>、移除样式并返回必要的 ID，然后由组件的 <code>onDrop</code> 回调来调用实际的状态更新函数（如 <code>handleActualDrop</code>）。我在上面的示例代码中对此进行了假设性的修改。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HTML 拖放 API 提供了一套标准化的事件和属性，用于在网页中实现丰富的拖放交互。虽然原生 API 的事件处理可能略显繁琐，但通过像 <code>useDraggable</code> 这样的 React 自定义 Hook，我们可以有效地封装复杂性，将拖放逻辑与 UI 组件分离，提高代码的可维护性和复用性。</p><p>理解 <code>dragstart</code>, <code>dragenter</code>, <code>dragover</code>, <code>dragleave</code>, <code>drop</code>, <code>dragend</code> 这些核心事件，并掌握 <code>event.preventDefault()</code> 和 <code>event.dataTransfer</code> 对象的使用，是成功实现拖放功能的关键。希望本文和 <code>useDraggable</code> 的示例能帮助你更好地在项目中应用这一强大的 Web API！</p><hr>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>前端开发</tag>
      
      <tag>HTML5</tag>
      
      <tag>Drag and Drop API</tag>
      
      <tag>React Hooks</tag>
      
      <tag>TypeScript</tag>
      
      <tag>Web交互</tag>
      
      <tag>用户体验</tag>
      
      <tag>自定义Hook</tag>
      
      <tag>DOM事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解密 CSS overflow：为何 auto 滚动条会“捣乱”以及 visible 为何“失效”？</title>
    <link href="/2025/04/22/%E6%8D%A3%E4%B9%B1%E4%BB%A5%E5%8F%8A-visible-%E4%B8%BA%E4%BD%95%E5%A4%B1%E6%95%88%EF%BC%9F/"/>
    <url>/2025/04/22/%E6%8D%A3%E4%B9%B1%E4%BB%A5%E5%8F%8A-visible-%E4%B8%BA%E4%BD%95%E5%A4%B1%E6%95%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="解密-CSS-overflow：为何-auto-滚动条会“捣乱”以及-visible-为何“失效”？"><a href="#解密-CSS-overflow：为何-auto-滚动条会“捣乱”以及-visible-为何“失效”？" class="headerlink" title="解密 CSS overflow：为何 auto 滚动条会“捣乱”以及 visible 为何“失效”？"></a><strong>解密 CSS <code>overflow</code>：为何 <code>auto</code> 滚动条会“捣乱”以及 <code>visible</code> 为何“失效”？</strong></h2><p>大家好！今天我们来深入探讨 CSS 中一个既基础又充满“玄机”的属性——<code>overflow</code>。你可能遇到过这两种令人费解的情况：</p><ol><li>只设置了 <code>overflow-y: auto</code>，为什么有时会意外出现水平滚动条？</li><li>设置了 <code>overflow-y: auto</code>（或 <code>scroll</code>&#x2F;<code>hidden</code>），但同时设置的 <code>overflow-x: visible</code> 却好像没起作用，内容并没有像预期那样溢出容器？</li></ol><p>这些现象并非 Bug，而是由浏览器渲染机制和 CSS 规范共同决定的。让我们结合规范，一起揭开 <code>overflow</code> 的神秘面纱。</p><h3 id="现象一：overflow-y-auto-引发的“意外”水平滚动"><a href="#现象一：overflow-y-auto-引发的“意外”水平滚动" class="headerlink" title="现象一：overflow-y: auto 引发的“意外”水平滚动"></a><strong>现象一：<code>overflow-y: auto</code> 引发的“意外”水平滚动</strong></h3><p><strong>场景回顾：</strong> 你为一个固定宽高的容器设置了 <code>overflow-y: auto</code>，希望只在内容垂直超出时出现垂直滚动条。但有时，即使内容本身宽度没问题，一个水平滚动条也“不请自来”。</p><p><strong>根本原因：滚动条本身占据空间</strong></p><p>问题的核心在于，在许多桌面环境（尤其是 Windows、旧版 macOS 或未配置覆盖式滚动条的系统）下，当浏览器根据 <code>overflow-y: auto</code> 决定显示一个垂直滚动条时，<strong>这个滚动条本身需要占据容器内部的水平空间</strong>。</p><p>想象一个 <code>300px</code> 宽的容器：</p><p><strong>CSS</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">container</span> &#123;<br>  <span class="hljs-attr">width</span>: 300px;<br>  <span class="hljs-attr">height</span>: 200px;<br>  overflow-<span class="hljs-attr">y</span>: auto;<br>  overflow-<span class="hljs-attr">x</span>: auto; <span class="hljs-comment">/* 或者 hidden, scroll */</span><br>  <span class="hljs-attr">border</span>: 1px solid red;<br>&#125;<br>.<span class="hljs-property">content</span> &#123;<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>%; <span class="hljs-comment">/* 意图撑满容器 */</span><br>  <span class="hljs-comment">/* ...足够多的垂直内容... */</span><br>  <span class="hljs-attr">background</span>: lightblue;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>无垂直溢出时：</strong> <code>.content</code> 可用宽度为 <code>300px</code>。</li><li><strong>有垂直溢出时：</strong> 垂直滚动条出现（假设宽度 <code>15px</code>），它会占用右侧 <code>15px</code> 的空间。此时，<code>.content</code> 实际可用的水平空间**减少为 <code>300px - 15px = 285px</code>**。</li></ul><p><strong>后果：触发水平溢出检测</strong></p><p>如果你的 <code>.content</code>（或其他内部元素）原本恰好是 <code>300px</code> 宽，或者使用了 <code>width: 100%</code>，那么在垂直滚动条出现后，它相对于<strong>新的、减少后的可用宽度（<code>285px</code>）</strong> 就变成了水平溢出状态。</p><p>这时，<code>overflow-x</code> 的设置就决定了最终表现：</p><ul><li><strong><code>overflow-x: auto</code> (常见情况):</strong> 检测到水平溢出，于是显示水平滚动条。这就是“意外”滚动条的来源。</li><li><strong><code>overflow-x: scroll</code>:</strong> 始终显示水平滚动条，垂直滚动条出现后，它可能从仅占位变成实际可滚动。</li><li><strong><code>overflow-x: hidden</code>:</strong> 检测到水平溢出，直接裁剪掉超出的部分。</li></ul><p><strong>规范关联：</strong></p><p>虽然“滚动条占据空间”更多是用户代理（UA，即浏览器）的渲染实现细节，但其<strong>后果</strong>——即内容因可用空间减少而溢出，进而触发 <code>auto</code> 或 <code>scroll</code> 规则——是完全符合 <strong>CSS Overflow Module Level 3 (或 Level 4)</strong> 对 <code>auto</code> 和 <code>scroll</code> 值定义的。规范定义了 <code>auto</code> 在内容溢出时应提供滚动机制。</p><h3 id="现象二：overflow-x-visible-在-overflow-y-auto-下的“失效”"><a href="#现象二：overflow-x-visible-在-overflow-y-auto-下的“失效”" class="headerlink" title="现象二：overflow-x: visible 在 overflow-y: auto 下的“失效”"></a><strong>现象二：<code>overflow-x: visible</code> 在 <code>overflow-y: auto</code> 下的“失效”</strong></h3><p><strong>场景回顾：</strong> 你希望垂直方向滚动，但水平方向让内容自由溢出，所以写了 <code>overflow-y: auto; overflow-x: visible;</code>。结果发现，内容并没有在水平方向溢出容器，好像 <code>visible</code> 被忽略了。</p><p><strong>根本原因：CSS 规范的强制规则</strong></p><p>这次，答案直接藏在 CSS 规范里。<strong>CSS Overflow Module Level 3</strong>（以及后续版本）中明确规定了 <code>overflow-x</code> 和 <code>overflow-y</code> 的相互作用：</p><blockquote><p>“UAs must apply the ‘overflow’ property set on the root element to the viewport… However, the computed values of ‘overflow-x’ and ‘overflow-y’ may be adjusted based on the values of the other overflow property. If one is specified as ‘visible’ and the other is ‘scroll’ or ‘auto’, then the specified ‘visible’ value computes to ‘auto’.”</p></blockquote><p><strong>简单来说，规范规定：</strong></p><ul><li>当你为一个元素的某个轴（如 <code>y</code> 轴）设置 <code>overflow</code> 为 <code>auto</code>, <code>scroll</code> 或 <code>hidden</code> 时，**另一个轴（如 <code>x</code> 轴）的 <code>overflow</code> 的计算值（Computed Value）不能是 <code>visible</code>**。</li><li>如果你显式地写了 <code>overflow-x: visible</code>，浏览器在计算最终样式时会**强制将其计算值改为 <code>auto</code>**。</li></ul><p><strong>后果：行为等同于 <code>auto</code></strong></p><p>因为 <code>overflow-x: visible</code> 被强制计算为 <code>overflow-x: auto</code>，所以该元素在水平方向的行为完全遵循 <code>auto</code>：</p><ul><li>如果内容水平不溢出（即使考虑了垂直滚动条的空间），则内容被包含，无滚动条，无可见溢出。</li><li>如果内容水平溢出，则显示水平滚动条。</li></ul><p><strong>为何有此规则？与 BFC 的联系</strong></p><p><code>overflow</code> 的值不为 <code>visible</code> 时，该元素会创建一个<strong>新的块级格式化上下文（Block Formatting Context, BFC）</strong>。BFC 的核心特性之一就是“包含”，它像一个独立的布局环境，其内部渲染不应“泄露”到外部。如果允许一个轴滚动&#x2F;裁剪（非 <code>visible</code>），而另一轴无限可见溢出（<code>visible</code>），会破坏 BFC 的封装性，并可能导致渲染和逻辑上的复杂性。因此，规范通过将 <code>visible</code> 调整为 <code>auto</code> 来维持模型的一致性。</p><h3 id="解决方案与最佳实践"><a href="#解决方案与最佳实践" class="headerlink" title="解决方案与最佳实践"></a><strong>解决方案与最佳实践</strong></h3><p>理解了原理，解决起来就清晰了：</p><ol><li>**接受现实，使用 <code>overflow: auto;</code>**： 如果你的设计能接受两个方向都可能出现滚动条，这是最简单的方式，明确表达了意图。</li><li><strong>拥抱现代 CSS：<code>scrollbar-gutter: stable;</code></strong><ul><li><p>这是解决“现象一”（滚动条出现导致布局跳动&#x2F;意外溢出）的<strong>最佳方案</strong>。</p></li><li><p>它让浏览器<strong>始终为滚动条预留空间</strong>，无论滚动条当前是否显示。</p></li><li><p>这样，垂直滚动条出现时占用的是预留空间，<strong>不会挤压内容区域的宽度</strong>，从而避免了连锁触发水平滚动条或布局变化。</p></li><li><p><strong>示例:</strong></p><p>  <strong>CSS</strong></p>  <figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">container</span> &#123;<br>  overflow-<span class="hljs-attr">y</span>: auto;<br>  scrollbar-<span class="hljs-attr">gutter</span>: stable; <span class="hljs-comment">/* 关键！*/</span><br>  <span class="hljs-comment">/* overflow-x 可以是 auto, hidden 等 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>注意:</strong> 检查 <a href="https://caniuse.com/?search=scrollbar-gutter">caniuse.com</a> 上的浏览器兼容性（现代浏览器支持良好）。</p></li></ul></li><li><strong>（不推荐）Padding 补偿或 JS 计算</strong>： 这些方法不够健壮、难以维护，应尽量避免。</li></ol><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a><strong>结语</strong></h3><p>CSS <code>overflow</code> 的行为深刻体现了规范细节与浏览器实现之间的互动。</p><ul><li><strong><code>overflow-y: auto</code> 引发意外水平滚动</strong> 是因为滚动条实体占据了空间，减少了内容可用宽度，进而可能触发 <code>overflow-x</code> 的 <code>auto</code> 或 <code>scroll</code> 机制。</li><li><strong><code>overflow-x: visible</code> 在 <code>overflow-y: auto/scroll/hidden</code> 下“失效”</strong> 是因为 CSS 规范强制将这种情况下的 <code>visible</code> 计算为 <code>auto</code>，以维持布局模型的一致性并服务于 BFC 的特性。</li></ul><p>掌握这些知识，并善用 <code>scrollbar-gutter</code> 等现代 CSS 特性，你就能更自信地驾驭 <code>overflow</code>，构建出稳定、符合预期的用户界面。</p><p>希望这篇深入浅出的解析对你有所帮助！</p><p><strong>参考规范：</strong></p><ul><li><strong>CSS Overflow Module Level 3:</strong> <a href="https://www.w3.org/TR/css-overflow-3/">https://www.w3.org/TR/css-overflow-3/</a> (尤其关注 Section 3: Overflowing and Clipping 和对 <code>visible</code>, <code>auto</code> 值的定义及相互作用)</li><li><strong>CSS Display Module Level 3 (关于 BFC):</strong> <a href="https://www.google.com/search?q=https://www.w3.org/TR/css-display-3/%23block-formatting-contexts">https://www.w3.org/TR/css-display-3/#block-formatting-contexts</a></li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>浏览器渲染</tag>
      
      <tag>前端开发</tag>
      
      <tag>overflow</tag>
      
      <tag>布局</tag>
      
      <tag>BFC</tag>
      
      <tag>滚动条</tag>
      
      <tag>scrollbar-gutter</tag>
      
      <tag>CSS规范</tag>
      
      <tag>Web开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 css padding百分比规则</title>
    <link href="/2025/04/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-css-padding%E7%99%BE%E5%88%86%E6%AF%94%E8%A7%84%E5%88%99/"/>
    <url>/2025/04/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-css-padding%E7%99%BE%E5%88%86%E6%AF%94%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h2 id="深入理解-CSS-Padding-百分比计算规则"><a href="#深入理解-CSS-Padding-百分比计算规则" class="headerlink" title="深入理解 CSS Padding 百分比计算规则"></a><strong>深入理解 CSS Padding 百分比计算规则</strong></h2><h3 id="核心规则"><a href="#核心规则" class="headerlink" title="核心规则"></a><strong>核心规则</strong></h3><p>W3C 规范明确规定：</p><blockquote><p>Percentages: refer to width of containing block</p><p>(百分比值：参照包含块的宽度)</p></blockquote><p>这意味着，无论你设置的是 <code>padding-left</code>, <code>padding-right</code>, <code>padding-top</code> 还是 <code>padding-bottom</code> 的百分比值，其计算基准 <strong>始终</strong> 是该元素 <strong>包含块（Containing Block）的宽度（width）</strong>。</p><p><strong>什么是包含块 (Containing Block)？</strong></p><p>简单来说，一个元素的包含块通常是其<strong>最近的块级祖先元素的内容区域（content area）</strong>。但在某些情况下（如绝对定位或固定定位），包含块可能会有所不同。对于初学者而言，在大多数标准文档流布局中，你可以暂时将其理解为“父元素的宽度”。</p><h3 id="为什么-padding-top-和-padding-bottom-也参照宽度？"><a href="#为什么-padding-top-和-padding-bottom-也参照宽度？" class="headerlink" title="为什么 padding-top 和 padding-bottom 也参照宽度？"></a><strong>为什么 <code>padding-top</code> 和 <code>padding-bottom</code> 也参照宽度？</strong></h3><p>这确实是初学者容易混淆的地方。直觉上，我们可能会认为 <code>padding-top</code> 和 <code>padding-bottom</code> 的百分比应该参照父元素（或包含块）的 <em>高度</em>。但 CSS 规范选择了宽度作为统一的参照基准。</p><p>虽然官方没有给出明确的“为什么”这么设计的唯一原因，但有几种常见的解释和推测：</p><ol><li><strong>布局一致性与可预测性：</strong> 如果垂直和水平方向的百分比参照不同的基准（高度和宽度），可能会导致更复杂的布局计算和不可预测的行为，尤其是在响应式设计中，元素的宽度通常比高度更具决定性。</li><li><strong>避免循环依赖：</strong> 元素的高度往往受其内容影响，而内容又可能包含有百分比内边距的子元素。如果垂直内边距参照高度，可能会产生计算上的循环依赖问题（高度依赖内边距，内边距依赖高度）。参照宽度则打破了这种潜在的循环。</li><li><strong>实现特定布局技巧：</strong> 这个特性被开发者巧妙地利用来实现一些特定的布局效果，最著名的就是保持元素的宽高比。</li></ol><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a><strong>代码示例</strong></h3><p>让我们通过一个简单的例子来验证这一点：</p><p><strong>HTML:</strong></p><p><strong>HTML</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span></span><br><span class="language-xml">    这是一个子元素。它的 padding 上下左右都是 10%。</span><br><span class="language-xml">    请注意观察它的上下内边距是如何根据父元素的 *宽度* 计算的。</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><strong>CSS:</strong></p><p><strong>CSS</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">parent</span> &#123;<br>  <span class="hljs-attr">width</span>: 500px;<br>  <span class="hljs-attr">height</span>: 200px; <span class="hljs-comment">/* 父元素高度，注意这个值不影响子元素的百分比 padding 计算 */</span><br>  background-<span class="hljs-attr">color</span>: lightblue;<br>  <span class="hljs-attr">border</span>: 1px solid blue;<br>  margin-<span class="hljs-attr">bottom</span>: 20px; <span class="hljs-comment">/* 只是为了分隔 */</span><br>&#125;<br><br>.<span class="hljs-property">child</span> &#123;<br>  background-<span class="hljs-attr">color</span>: lightcoral;<br>  <span class="hljs-attr">border</span>: 1px solid red;<br><br>  <span class="hljs-comment">/* 设置所有方向的 padding 为 10% */</span><br>  <span class="hljs-attr">padding</span>: <span class="hljs-number">10</span>%;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * 计算过程：</span><br><span class="hljs-comment">   * 父元素宽度 = 500px</span><br><span class="hljs-comment">   * padding-top = 10% of 500px = 50px</span><br><span class="hljs-comment">   * padding-bottom = 10% of 500px = 50px</span><br><span class="hljs-comment">   * padding-left = 10% of 500px = 50px</span><br><span class="hljs-comment">   * padding-right = 10% of 500px = 50px</span><br><span class="hljs-comment">   */</span><br>&#125;<br><br><span class="hljs-comment">/* 对比：如果父元素宽度改变 */</span><br>.<span class="hljs-property">parent</span>.<span class="hljs-property">narrow</span> &#123;<br>    <span class="hljs-attr">width</span>: 300px;<br>&#125;<br><br>.<span class="hljs-property">parent</span>.<span class="hljs-property">narrow</span> .<span class="hljs-property">child</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 新的计算过程：</span><br><span class="hljs-comment">     * 父元素宽度 = 300px</span><br><span class="hljs-comment">     * padding-top = 10% of 300px = 30px</span><br><span class="hljs-comment">     * padding-bottom = 10% of 300px = 30px</span><br><span class="hljs-comment">     * padding-left = 10% of 300px = 30px</span><br><span class="hljs-comment">     * padding-right = 10% of 300px = 30px</span><br><span class="hljs-comment">     */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>你可以复制代码在浏览器中运行，并使用开发者工具检查 <code>.child</code> 元素的盒模型（Box Model），你会清晰地看到其 <code>padding-top</code>, <code>padding-bottom</code>, <code>padding-left</code>, <code>padding-right</code> 的计算值都是父元素宽度的 10%。当你改变父元素的宽度时（比如添加 <code>narrow</code> 类），所有的 <code>padding</code> 值会相应地等比例变化，而改变父元素的 <code>height</code> 则完全不影响这些 <code>padding</code> 的计算值。</p><hr><h2 id="工程实战场景"><a href="#工程实战场景" class="headerlink" title="工程实战场景"></a><strong>工程实战场景</strong></h2><p>理解了这个特性后，我们来看看它在实际开发中有什么用处：</p><h3 id="1-保持元素的宽高比（Aspect-Ratio-Box）-最经典的用法"><a href="#1-保持元素的宽高比（Aspect-Ratio-Box）-最经典的用法" class="headerlink" title="1. 保持元素的宽高比（Aspect Ratio Box） - 最经典的用法"></a><strong>1. 保持元素的宽高比（Aspect Ratio Box） - 最经典的用法</strong></h3><p>这是 <code>padding-top</code> &#x2F; <code>padding-bottom</code> 百分比特性最广为人知的应用场景。当你需要一个容器（比如用于嵌入视频、图片或其他内容）在不同屏幕宽度下始终保持固定的宽高比（如 16:9, 4:3）时，这个技巧非常有用。</p><p><strong>原理：</strong></p><ul><li>将元素的高度设置为 <code>0</code>。</li><li>设置 <code>padding-bottom</code> (或 <code>padding-top</code>) 的百分比值，该百分比等于 <code>(高度 / 宽度) * 100%</code>。因为这个百分比是基于 <em>宽度</em> 计算的，所以 <code>padding-bottom</code> 的实际像素值会随着宽度的变化而变化，从而“撑开”了元素的高度，使其与宽度保持固定的比例。</li><li>通常需要结合 <code>position: relative;</code> (父元素) 和 <code>position: absolute;</code> (子元素) 来将内容正确地放置在由 padding 撑开的区域内。</li></ul><p><strong>示例：创建一个 16:9 的响应式视频容器</strong></p><p><strong>HTML:</strong></p><p><strong>HTML</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;aspect-ratio-box sixteen-nine&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://www.youtube.com/embed/your_video_id&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">allowfullscreen</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><strong>CSS:</strong></p><p><strong>CSS</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">aspect</span>-ratio-box &#123;<br>  <span class="hljs-attr">position</span>: relative; <span class="hljs-comment">/* 为绝对定位的子元素提供定位上下文 */</span><br>  <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>%;       <span class="hljs-comment">/* 或者你需要的任何宽度 */</span><br>  <span class="hljs-attr">height</span>: <span class="hljs-number">0</span>;          <span class="hljs-comment">/* 关键：高度设置为 0 */</span><br>  <span class="hljs-attr">overflow</span>: hidden;   <span class="hljs-comment">/* 隐藏可能溢出的内容 */</span><br>&#125;<br><br>.<span class="hljs-property">aspect</span>-ratio-box.<span class="hljs-property">sixteen</span>-nine &#123;<br>  <span class="hljs-comment">/* 关键：padding-bottom = (9 / 16) * 100% = 56.25% */</span><br>  padding-<span class="hljs-attr">bottom</span>: <span class="hljs-number">56.25</span>%;<br>&#125;<br><br><span class="hljs-comment">/* 如果需要 4:3 的比例 */</span><br>.<span class="hljs-property">aspect</span>-ratio-box.<span class="hljs-property">four</span>-three &#123;<br>  <span class="hljs-comment">/* padding-bottom = (3 / 4) * 100% = 75% */</span><br>  padding-<span class="hljs-attr">bottom</span>: <span class="hljs-number">75</span>%;<br>&#125;<br><br>.<span class="hljs-property">aspect</span>-ratio-box .<span class="hljs-property">content</span> &#123;<br>  <span class="hljs-attr">position</span>: absolute; <span class="hljs-comment">/* 关键：绝对定位 */</span><br>  <span class="hljs-attr">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attr">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>%;<br>  <span class="hljs-attr">height</span>: <span class="hljs-number">100</span>%;     <span class="hljs-comment">/* 关键：填满由 padding 撑开的空间 */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，无论 <code>.aspect-ratio-box</code> 的宽度如何变化（例如在响应式布局中），它内部的高度（由 <code>padding-bottom</code> 决定）都会自动调整，始终保持 16:9 的比例，里面的 <code>iframe</code> 也会随之缩放。</p><h3 id="2-创建与宽度相关的等距边距"><a href="#2-创建与宽度相关的等距边距" class="headerlink" title="2. 创建与宽度相关的等距边距"></a><strong>2. 创建与宽度相关的等距边距</strong></h3><p>在某些设计中，你可能希望元素的内边距（特别是垂直方向的内边距）能够随着容器宽度的变化而等比例缩放，以保持视觉上的一致性。</p><p><strong>示例：响应式卡片</strong></p><p>假设你有一个卡片组件，希望卡片内部内容距离卡片边缘的间距（上下左右）在视觉上感觉是“相同”的，并且这个间距能随着卡片宽度的变化而调整。</p><p><strong>HTML:</strong></p><p><strong>HTML</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>卡片标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一段卡片内容...<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><strong>CSS:</strong></p><p><strong>CSS</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">card</span> &#123;<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">80</span>%; <span class="hljs-comment">/* 卡片宽度是响应式的 */</span><br>  max-<span class="hljs-attr">width</span>: 400px;<br>  <span class="hljs-attr">margin</span>: 20px auto;<br>  <span class="hljs-attr">border</span>: 1px solid #ccc;<br>  background-<span class="hljs-attr">color</span>: #f9f9f9;<br><br>  <span class="hljs-comment">/* 设置统一的、相对于卡片宽度的内边距 */</span><br>  <span class="hljs-attr">padding</span>: <span class="hljs-number">5</span>%; <span class="hljs-comment">/* 上下左右内边距都是卡片宽度的 5% */</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，无论卡片因为父容器或屏幕尺寸变化而变成多宽，其内部内容距离四个边缘的空白（<code>padding</code>）都会是当时卡片宽度的 5%。这有助于在不同尺寸下维持相似的内部空间感。</p><h3 id="3-全宽背景条带内的内容约束"><a href="#3-全宽背景条带内的内容约束" class="headerlink" title="3. 全宽背景条带内的内容约束"></a><strong>3. 全宽背景条带内的内容约束</strong></h3><p>有时你需要一个横跨整个页面宽度的背景色或背景图片条带，但内部的内容区域需要有一定的左右边距，并且这个边距也希望是响应式的。</p><p><strong>HTML:</strong></p><p><strong>HTML</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx">&lt;div <span class="hljs-keyword">class</span>=<span class="hljs-string">&quot;full-width-band&quot;</span>&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content-wrapper&quot;</span>&gt;</span></span><br><span class="language-xml">    这里是主要内容区域...</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><strong>CSS:</strong></p><p><strong>CSS</strong></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx">.<span class="hljs-property">full</span>-width-band &#123;<br>  <span class="hljs-attr">width</span>: <span class="hljs-number">100</span>%;<br>  background-<span class="hljs-attr">color</span>: #eee;<br>  <span class="hljs-comment">/* 注意：这里 padding 应用在内部容器上 */</span><br>&#125;<br><br>.<span class="hljs-property">content</span>-wrapper &#123;<br>  max-<span class="hljs-attr">width</span>: 1200px; <span class="hljs-comment">/* 限制内容最大宽度 */</span><br>  <span class="hljs-attr">margin</span>: <span class="hljs-number">0</span> auto;   <span class="hljs-comment">/* 内容居中 */</span><br><br>  <span class="hljs-comment">/* 使用 padding 百分比来创建响应式的左右内边距 */</span><br>  <span class="hljs-comment">/* 例如，左右各留出 5% 的边距 */</span><br>  padding-<span class="hljs-attr">left</span>: <span class="hljs-number">5</span>%;<br>  padding-<span class="hljs-attr">right</span>: <span class="hljs-number">5</span>%;<br><br>  <span class="hljs-comment">/* 如果也希望上下内边距与宽度相关 */</span><br>  <span class="hljs-comment">/* padding-top: 3%; */</span><br>  <span class="hljs-comment">/* padding-bottom: 3%; */</span><br><br>  <span class="hljs-comment">/* 如果 box-sizing 是 border-box，padding 不会增加总宽度 */</span><br>  box-<span class="hljs-attr">sizing</span>: border-box;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里，<code>.content-wrapper</code> 的左右 <code>padding</code> 是基于其包含块（很可能是 <code>.full-width-band</code> 或者更外层的元素，取决于布局，但通常是相对于一个明确宽度的祖先）的宽度计算的。这确保了即使在窄屏幕上，内容也不会紧贴屏幕边缘，并且这个间距是相对的。</p><hr><h3 id="注意事项与替代方案"><a href="#注意事项与替代方案" class="headerlink" title="注意事项与替代方案"></a><strong>注意事项与替代方案</strong></h3><ul><li><strong><code>box-sizing</code> 的影响：</strong> <code>box-sizing: border-box;</code> 是现代 CSS 开发中常用的设置。它使得元素的 <code>width</code> 和 <code>height</code> 属性定义的是元素边框（border）以内（包括 padding 和 border）的总尺寸。即使在这种模式下，<code>padding</code> 的百分比值仍然是基于包含块的 <em>宽度</em> 计算的，这一点不变。</li><li><strong>逻辑上的困惑：</strong> 记住 <code>padding-top</code> 和 <code>padding-bottom</code> 百分比参照的是宽度，这需要在使用时特别留意，避免直觉错误。</li><li><strong>替代方案：</strong><ul><li><strong>视口单位（Viewport Units）：</strong> 如果你希望内边距相对于视口（浏览器窗口）的宽度或高度，可以使用 <code>vw</code> (视口宽度的 1%) 或 <code>vh</code> (视口高度的 1%) 单位。例如 <code>padding: 5vw;</code>。</li><li><strong><code>calc()</code> 函数：</strong> 可以结合百分比和其他单位进行计算，<code>padding: calc(20px + 5%);</code>。</li><li><strong>Grid 和 Flexbox 的 <code>gap</code> 属性：</strong> 对于网格或弹性布局容器内的项目间距，<code>gap</code> 属性通常是更现代和方便的选择。</li></ul></li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>你对 <code>padding</code> 百分比计算规则的理解是完全正确的！这是一个非常基础但又极其重要的 CSS 特性。</p><p><strong>核心要点：</strong></p><ul><li><code>padding</code> 的所有四个方向（<code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code>）的百分比值，都参照其 <strong>包含块的宽度</strong> 进行计算。</li><li>这个特性最常用于创建 <strong>固定宽高比</strong> 的容器。</li><li>它也可以用来实现 <strong>与宽度相关的响应式内边距</strong>。</li></ul><p>掌握并理解这个特性，会让你在处理响应式布局和一些特殊布局需求时更加得心应手。继续加油，前端之路虽然细节繁多，但每一个知识点的掌握都会让你变得更强！</p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>前端开发</tag>
      
      <tag>布局技巧</tag>
      
      <tag>响应式设计</tag>
      
      <tag>padding</tag>
      
      <tag>盒模型</tag>
      
      <tag>W3C规范</tag>
      
      <tag>宽高比布局</tag>
      
      <tag>工程实践</tag>
      
      <tag>CSS计算规则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决 Chrome 扩展中 URL 参数解析问题：从 useParams 到 URLSearchParams 的优雅转变</title>
    <link href="/2025/04/22/extension%E4%B8%ADurl%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/"/>
    <url>/2025/04/22/extension%E4%B8%ADurl%E8%A7%A3%E6%9E%90%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="解决-Chrome-扩展中-URL-参数解析问题：从-useParams-到-URLSearchParams-的优雅转变"><a href="#解决-Chrome-扩展中-URL-参数解析问题：从-useParams-到-URLSearchParams-的优雅转变" class="headerlink" title="解决 Chrome 扩展中 URL 参数解析问题：从 useParams 到 URLSearchParams 的优雅转变"></a>解决 Chrome 扩展中 URL 参数解析问题：从 useParams 到 URLSearchParams 的优雅转变</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>在开发 Chrome 扩展时，我们遇到了一个有趣的问题：在扩展页面中无法正确获取 URL 参数。具体来说，当用户访问类似这样的 URL 时：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chrome</span>-extension://ikagihfgkipghifjdobklmpkhabjjmoi/index.html?full_result_table=true&amp;scraperId=<span class="hljs-number">39525222</span>-a483-<span class="hljs-number">4941</span>-b789-<span class="hljs-number">7961</span>b3ef3f93&amp;taskId=a1e246bd-<span class="hljs-number">872</span>b-<span class="hljs-number">4</span>ed7-<span class="hljs-number">842</span>d-ad6ec74f962f<br><br></code></pre></td></tr></table></figure><p>我们原本使用 React Router 的 <code>useParams</code> hook 来获取参数，但发现它无法正常工作。这促使我们寻找更合适的解决方案。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><h3 id="为什么-useParams-不工作？"><a href="#为什么-useParams-不工作？" class="headerlink" title="为什么 useParams 不工作？"></a>为什么 useParams 不工作？</h3><ol><li><strong>环境差异</strong>：Chrome 扩展运行在一个特殊的环境中，与普通的 web 应用不同</li><li><strong>路由机制</strong>：React Router 的 <code>useParams</code> 依赖于路由配置，而在扩展页面中，我们可能没有完整的路由配置</li><li><strong>URL 结构</strong>：Chrome 扩展的 URL 使用特殊的协议（<code>chrome-extension://</code>），这可能导致路由解析出现问题</li></ol><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>我们采用了 <code>URLSearchParams</code> API 来替代 <code>useParams</code>。这是一个更底层的、更通用的解决方案。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// 使用 URLSearchParams 获取参数</span><br><span class="hljs-keyword">const</span> searchParams = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>);<br><span class="hljs-keyword">const</span> scraperId = searchParams.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;scraperId&#x27;</span>);<br><span class="hljs-keyword">const</span> taskId = searchParams.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;taskId&#x27;</span>);<br><br></code></pre></td></tr></table></figure><h3 id="改进点"><a href="#改进点" class="headerlink" title="改进点"></a>改进点</h3><ol><li><strong>参数验证</strong>：</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">if</span> (!scraperId || !taskId) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Missing required parameters: scraperId or taskId&#x27;</span>);<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><strong>错误处理</strong>：</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">if</span> (!scraperId || !taskId) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Error: Missing required parameters<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol><li><strong>数据获取优化</strong>：</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (!scraperId || !taskId) <span class="hljs-keyword">return</span>;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchExecutionRecord</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// ... 数据获取逻辑</span><br>  &#125;;<br>  <span class="hljs-title function_">fetchExecutionRecord</span>();<br>&#125;, [scraperId, taskId]);<br><br></code></pre></td></tr></table></figure><h2 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h2><h3 id="URLSearchParams-的优势"><a href="#URLSearchParams-的优势" class="headerlink" title="URLSearchParams 的优势"></a>URLSearchParams 的优势</h3><ol><li><strong>原生支持</strong>：<code>URLSearchParams</code> 是 Web API 的一部分，不需要额外依赖</li><li><strong>简单直接</strong>：API 设计直观，易于使用</li><li><strong>跨环境兼容</strong>：在 Chrome 扩展、普通网页等环境中都能正常工作</li></ol><h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol><li><strong>参数验证</strong>：在使用参数前进行验证，避免潜在的错误</li><li><strong>错误处理</strong>：提供清晰的错误提示，提升用户体验</li><li><strong>依赖管理</strong>：正确处理 useEffect 的依赖项，避免不必要的重渲染</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这次问题解决，我们学到了：</p><ol><li>在特殊环境（如 Chrome 扩展）中，可能需要使用更底层的 API</li><li>参数验证和错误处理是提升应用健壮性的关键</li><li>选择适合当前环境的解决方案比坚持使用特定框架的特性更重要</li></ol><p>这个解决方案不仅解决了当前的问题，也为将来处理类似场景提供了参考。在开发过程中，我们应该保持开放的心态，根据具体场景选择最合适的工具和方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Chrome Extension</tag>
      
      <tag>React</tag>
      
      <tag>URLSearchParams</tag>
      
      <tag>React Router</tag>
      
      <tag>前端开发</tag>
      
      <tag>URL参数解析</tag>
      
      <tag>Web API</tag>
      
      <tag>错误处理</tag>
      
      <tag>最佳实践</tag>
      
      <tag>技术调试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 状态管理：优雅处理异步数据的初始化延迟</title>
    <link href="/2025/04/22/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BC%98%E9%9B%85%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BB%B6%E8%BF%9F/"/>
    <url>/2025/04/22/%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BC%98%E9%9B%85%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%BB%B6%E8%BF%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="React-状态管理：优雅处理异步数据的初始化延迟"><a href="#React-状态管理：优雅处理异步数据的初始化延迟" class="headerlink" title="React 状态管理：优雅处理异步数据的初始化延迟"></a>React 状态管理：优雅处理异步数据的初始化延迟</h1><p>在现代 Web 开发中，尤其是使用 React 构建的单页应用，异步数据获取是家常便饭。我们经常需要从后端 API 获取数据，然后更新组件状态以渲染 UI。然而，一个常见且容易被忽视的问题是：<strong>在异步数据返回之前，组件可能已经尝试访问这些数据，从而导致错误。</strong></p><p>本文将探讨一个具体的案例：<code>executionRecord</code> 状态初始化延迟导致的问题，并分享如何通过合理的 React 模式来优雅地解决它。</p><h2 id="问题场景：过早访问未初始化的状态"><a href="#问题场景：过早访问未初始化的状态" class="headerlink" title="问题场景：过早访问未初始化的状态"></a>问题场景：过早访问未初始化的状态</h2><p>假设我们有一个 React 组件，它需要获取一个名为 <code>executionRecord</code> 的对象，该对象包含渲染所需的信息。通常，我们会使用 <code>useState</code> 来管理这个状态，并使用 <code>useEffect</code> 来触发异步数据获取。</p><p>初始的代码可能看起来像这样：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// apps/crx/src/apps/fullTable/CrxFullResultTablePage.tsx (简化版 - 问题代码)</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// ... 其他导入 ...</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CrxFullResultTablePage</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> [executionRecord, setExecutionRecord] =<br>    useState&lt;<span class="hljs-title class_">IstWebScraperExecutionRecord</span> | <span class="hljs-literal">null</span>&gt;(); <span class="hljs-comment">// 初始可能是 undefined</span><br><br>  <span class="hljs-comment">// !! 问题所在：在数据获取完成前就尝试解构</span><br>  <span class="hljs-keyword">const</span> &#123; subTaskExecutionRecords, websiteUrl, websiteTitle, websiteIcon &#125; =<br>    executionRecord; <span class="hljs-comment">// 运行时可能因 executionRecord 为 null/undefined 而报错</span><br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-comment">// ... 模拟异步获取数据</span><br>      <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchExecutionRecordFromApi</span>();<br>      <span class="hljs-title function_">setExecutionRecord</span>(data);<br>    &#125;;<br>    <span class="hljs-title function_">fetchData</span>();<br>  &#125;, []);<br><br>  <span class="hljs-comment">// ... 后续渲染逻辑使用了解构出来的变量 ...</span><br><br>  <span class="hljs-comment">// 如果 executionRecord 尚未加载，这里会出错</span><br>  <span class="hljs-keyword">const</span> tab = &#123; <span class="hljs-comment">/* ... 使用 websiteUrl 等 */</span> &#125; <span class="hljs-keyword">as</span> chrome.<span class="hljs-property">tabs</span>.<span class="hljs-property">Tab</span>;<br><br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>问题分析：</strong></p><ol><li><strong>初始渲染：</strong> 组件首次渲染时，<code>executionRecord</code> 的状态是 <code>null</code> 或 <code>undefined</code>（取决于 <code>useState</code> 的初始值）。</li><li><strong>立即解构：</strong> 代码在组件顶部立即尝试从 <code>executionRecord</code> 解构属性（如 <code>subTaskExecutionRecords</code>）。</li><li><strong>运行时错误：</strong> 由于此时 <code>executionRecord</code> 还没有从 API 获取到有效值，试图访问 <code>null</code> 或 <code>undefined</code> 的属性会导致运行时错误，常见的如 <code>TypeError: Cannot read properties of null (reading &#39;subTaskExecutionRecords&#39;)</code>。</li><li><strong>异步延迟：</strong> <code>useEffect</code> 中的数据获取是异步的。在 <code>fetchData</code> 完成并调用 <code>setExecutionRecord</code> 之前，组件可能已经渲染（或尝试渲染）了一次或多次。</li></ol><h2 id="解决方案：条件渲染与延迟解构"><a href="#解决方案：条件渲染与延迟解构" class="headerlink" title="解决方案：条件渲染与延迟解构"></a>解决方案：条件渲染与延迟解构</h2><p>解决这个问题的关键在于确保<strong>只在数据有效时才访问它</strong>。我们可以结合以下几种策略：</p><ol><li><strong>明确的初始状态：</strong> 使用 <code>null</code> 作为 <code>useState</code> 的显式初始值，表示数据尚未加载。</li><li><strong>添加加载状态检查：</strong> 在尝试访问 <code>executionRecord</code> 的任何属性之前，检查它是否仍然是 <code>null</code>。如果是，则渲染一个加载指示器（Loading state）。</li><li><strong>延迟解构&#x2F;访问：</strong> 将解构赋值或者任何访问 <code>executionRecord</code> 属性的操作，<strong>移动到</strong>加载状态检查<strong>之后</strong>。</li></ol><p>改进后的代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// apps/crx/src/apps/fullTable/CrxFullResultTablePage.tsx (简化版 - 修复后)</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState, useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-comment">// ... 其他导入 ...</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">CrxFullResultTablePage</span>: <span class="hljs-title class_">React</span>.<span class="hljs-property">FC</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 1. 明确初始状态为 null</span><br>  <span class="hljs-keyword">const</span> [executionRecord, setExecutionRecord] =<br>    useState&lt;<span class="hljs-title class_">IstWebScraperExecutionRecord</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">const</span> &#123; scraperId, taskId &#125; = <span class="hljs-comment">/* ... 获取参数逻辑 ... */</span>; <span class="hljs-comment">// 假设参数已获取</span><br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!scraperId || !taskId) <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 确保依赖项有效</span><br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchExecutionRecordFromApi</span>(scraperId, taskId);<br>        <span class="hljs-title function_">setExecutionRecord</span>(data);<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;Failed to fetch execution record:&quot;</span>, error);<br>        <span class="hljs-comment">// 可以设置错误状态</span><br>      &#125;<br>    &#125;;<br>    <span class="hljs-title function_">fetchData</span>();<br>  &#125;, [scraperId, taskId]); <span class="hljs-comment">// 添加正确的依赖项</span><br><br>  <span class="hljs-comment">// 2. 添加加载状态检查</span><br>  <span class="hljs-keyword">if</span> (!executionRecord) &#123;<br>    <span class="hljs-comment">// 在数据加载完成前，显示加载状态</span><br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 3. 延迟解构：现在可以安全地访问 executionRecord</span><br>  <span class="hljs-keyword">const</span> &#123; subTaskExecutionRecords, websiteUrl, websiteTitle, websiteIcon &#125; =<br>    executionRecord;<br><br>  <span class="hljs-keyword">const</span> tab = &#123;<br>    <span class="hljs-attr">url</span>: websiteUrl,<br>    <span class="hljs-attr">title</span>: websiteTitle,<br>    <span class="hljs-attr">favIconUrl</span>: websiteIcon,<br>  &#125; <span class="hljs-keyword">as</span> chrome.<span class="hljs-property">tabs</span>.<span class="hljs-property">Tab</span>;<br><br>  <span class="hljs-comment">// ... 后续渲染逻辑 ...</span><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Container</span>&gt;</span></span><br><span class="language-xml">      &#123;/* ... 使用 tab 和 subTaskExecutionRecords 的渲染逻辑 ... */&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">Container</span>&gt;</span></span><br>  );<br>&#125;;<br><br></code></pre></td></tr></table></figure><p><strong>改进点解析：</strong></p><ul><li><strong>加载状态 (<code>if (!executionRecord)</code>)：</strong> 这是最关键的改进。它确保了只有当 <code>executionRecord</code> 确实包含从 API 返回的数据时，后续的代码（包括解构和使用其属性）才会被执行。在此之前，组件会提前返回一个加载指示器，避免了运行时错误。</li><li><strong>状态初始化 (<code>useState(null)</code>)：</strong> 明确地将初始状态设为 <code>null</code>，使得加载状态的判断 <code>!executionRecord</code> 更加清晰可靠。</li><li><strong>依赖项数组 (<code>useEffect</code> 的第二参数)：</strong> 确保 <code>useEffect</code> 在其依赖的 <code>scraperId</code> 或 <code>taskId</code> 变化时能够重新运行，获取最新的数据。</li><li><strong>错误处理（可选但推荐）：</strong> 在 <code>fetchData</code> 中添加 <code>try...catch</code> 可以捕获 API 请求可能发生的错误，并进行相应的处理（例如，显示错误消息给用户）。</li></ul><h2 id="总结与最佳实践"><a href="#总结与最佳实践" class="headerlink" title="总结与最佳实践"></a>总结与最佳实践</h2><p>处理 React 中的异步数据初始化延迟是一个常见的模式。关键在于理解组件的渲染周期和异步操作的本质。</p><ul><li><strong>始终为异步数据设置加载状态：</strong> 不要假设数据会立即或总是成功加载。</li><li><strong>显式初始化状态：</strong> 使用 <code>null</code> 或明确的默认值作为异步获取数据的初始状态。</li><li><strong>条件渲染：</strong> 根据加载状态、数据是否有效以及是否出错来决定渲染什么内容。</li><li><strong>延迟访问&#x2F;解构：</strong> 确保在数据确认有效之后再访问其属性。</li><li><strong>管理 <code>useEffect</code> 依赖项：</strong> 正确设置依赖项数组，以控制数据获取的时机。</li></ul><p>通过遵循这些实践，你可以编写出更健壮、用户体验更好的 React 应用，优雅地处理好异步数据带来的挑战。</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>前端开发</tag>
      
      <tag>错误处理</tag>
      
      <tag>最佳实践</tag>
      
      <tag>TypeScript</tag>
      
      <tag>状态管理</tag>
      
      <tag>异步编程</tag>
      
      <tag>useEffect</tag>
      
      <tag>useState</tag>
      
      <tag>组件设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫基本功——加密数据定位</title>
    <link href="/2024/10/11/%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E5%8A%9F%E2%80%94%E2%80%94%E4%BC%81x%E7%A7%91%E6%8A%80%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%BD%8D/"/>
    <url>/2024/10/11/%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E5%8A%9F%E2%80%94%E2%80%94%E4%BC%81x%E7%A7%91%E6%8A%80%E5%8A%A0%E5%AF%86%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011144612.png"></p><h1 id="企x科技——无混淆js的数据解密方法一："><a href="#企x科技——无混淆js的数据解密方法一：" class="headerlink" title="企x科技——无混淆js的数据解密方法一："></a>企x科技——无混淆js的数据解密方法一：</h1><p>打开抓包工具，切换列表抓取到数据后查看响应体发现有encrypt_data字段内容被加密。要找出加密函数可以在搜索栏直接搜索该字段<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011144326.png"><br>进入到js内格式化后搜索encrypt_data字段在可疑处打断点随后分析即可</p><h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>对于大部分请求如果断点断下后若不确定是否是自己跟踪的接口，可以使用调试工具的XHR功能来确定</p><h1 id="烯x数据——无混淆js的数据解密方法二"><a href="#烯x数据——无混淆js的数据解密方法二" class="headerlink" title="烯x数据——无混淆js的数据解密方法二"></a>烯x数据——无混淆js的数据解密方法二</h1><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011152152.png"></p><h2 id="解密请求响应"><a href="#解密请求响应" class="headerlink" title="解密请求响应"></a>解密请求响应</h2><p>特征1.在&#x2F;industry&#x2F;newest路径下的页面为静态页面<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011145911.png"><br>特征2.页面切换时会出现加密数据<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011150017.png"></p><p>检查发起程序时不存在js混淆，如果要按照方法一找出解密函数搜索关键字d显然不现实。此时可以尝试搜索JSON.parse函数。在全局搜索栏里搜索会有大量使用JSON.parse的函数出现。为了减小搜索范围，可以在请求处点击”发起程序”在函数调用处的文件里直接搜索JSON.parse。</p><p>然后分析代码，在疑似处理加密数据处的JSON.parse断点。随后加载数据，程序在第30行处停下。我们再在控制台输出JSON.parse(y)即可发现网页的明文数据，此处即为加密数据的处理段<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011150843.png"></p><h2 id="表单请求加密"><a href="#表单请求加密" class="headerlink" title="表单请求加密"></a>表单请求加密</h2><p>特征3.除此之外，同样的接口。在程序请求接口时依然会出现以下两个加密数据：payload、sig<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011151958.png"></p><p>要找出加密程序，老方法<strong>先搜索请求字段</strong>payload或者sig。结果搜不出来想要的结果<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011153914.png" alt="payload"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011154003.png" alt="sig"></p><p>接着尝试<strong>搜索请求路径</strong>，找到了唯一一个包含该路径的js文件。然后在响应面板中右键在源面板中打开<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011152654.png"><br>在industry-newest文件中搜索payload和sig分析js代码发现都不太像加密处理的位置。于是我们可以跳转到其它中，发现有一块可疑处。即可在此处添加断点<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011153310.png"><br>刷新页面调用接口后开发工具并没有断下，所以我们只能另寻他处。再搜索栏搜索sig &#x3D;时发现又一处比较可疑。所以我们添加断点并尝试请求接口<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011153429.png"><br>结果程序立马断下。观察源代码即可解出加密函数<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011153819.png"></p><h1 id="招标与企xx"><a href="#招标与企xx" class="headerlink" title="招标与企xx"></a>招标与企xx</h1><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241011154911.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>电子书列表功能开发</title>
    <link href="/2024/10/10/%E7%94%B5%E5%AD%90%E4%B9%A6%E5%88%97%E8%A1%A8%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/"/>
    <url>/2024/10/10/%E7%94%B5%E5%AD%90%E4%B9%A6%E5%88%97%E8%A1%A8%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="电子书资源"><a href="#电子书资源" class="headerlink" title="电子书资源"></a>电子书资源</h1><p>电子书资源：</p><ul><li>解压后的电子书：链接：<br><a href="https://pan.baidu.com/s/1kh_BS_oZS8GQMZkgplK_GA">链接</a><br>提取码：8p6d<br>解析epub文件：</li></ul><ol><li>根据META-INF找到content.opf文件，content.opf（xml）文件存放了电子书的配置<br>部分内容示例：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241010203516.png"><br>目录文件toc.inx<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241010203600.png"></li></ol><h1 id="静态资源服务器搭建（Nginx）"><a href="#静态资源服务器搭建（Nginx）" class="headerlink" title="静态资源服务器搭建（Nginx）"></a>静态资源服务器搭建（Nginx）</h1><p>将下载下来的电子书放置在静态资源服务器内管理</p><h1 id="电子书列表模块"><a href="#电子书列表模块" class="headerlink" title="电子书列表模块"></a>电子书列表模块</h1><p>在routes&#x2F;modules下新建book.ts路由并引入相关组件</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-keyword">const</span> <span class="hljs-attr">book</span>: <span class="hljs-title class_">AppRouteModule</span> = &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/book&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Book&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-variable constant_">LAYOUT</span>,<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/book/list&#x27;</span>,<br>    <span class="hljs-attr">meta</span>: &#123;<br>        <span class="hljs-attr">orderNo</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">icon</span>: <span class="hljs-string">&#x27;ion:grid-outline&#x27;</span>,<br>        <span class="hljs-attr">title</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;routes.book.manage&#x27;</span>),<br>    &#125;,<br>    <span class="hljs-attr">children</span>: [<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;list&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;List&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/demo/page/list/search/index.vue&#x27;</span>),<br>            <span class="hljs-attr">meta</span>: &#123;<br>                <span class="hljs-comment">// affix: true,</span><br>                <span class="hljs-attr">title</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;routes.book.list&#x27;</span>),<br>            &#125;,<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;create&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Create&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/demo/page/form/high/index.vue&#x27;</span>),<br>            <span class="hljs-attr">meta</span>: &#123;<br>                <span class="hljs-attr">title</span>: <span class="hljs-title function_">t</span>(<span class="hljs-string">&#x27;routes.book.create&#x27;</span>),<br>            &#125;,<br>        &#125;,<br>    ],<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> book;<br><br></code></pre></td></tr></table></figure><p>重构目录文件，将子组件放置在&#x2F;book目录下<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241014152359.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>Vue.js</tag>
      
      <tag>Typescript</tag>
      
      <tag>Vite</tag>
      
      <tag>Nest.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原神大地图——3.地图与UI交互</title>
    <link href="/2024/10/05/%E5%8E%9F%E7%A5%9E%E5%A4%A7%E5%9C%B0%E5%9B%BE%E2%80%94%E2%80%943-%E5%9C%B0%E5%9B%BE%E4%B8%8EUI%E4%BA%A4%E4%BA%92/"/>
    <url>/2024/10/05/%E5%8E%9F%E7%A5%9E%E5%A4%A7%E5%9C%B0%E5%9B%BE%E2%80%94%E2%80%943-%E5%9C%B0%E5%9B%BE%E4%B8%8EUI%E4%BA%A4%E4%BA%92/</url>
    
    <content type="html"><![CDATA[<h1 id="地名动态渲染"><a href="#地名动态渲染" class="headerlink" title="地名动态渲染"></a>地名动态渲染</h1><p>实现根据地图缩放大小不同，地名展示也不同。<br>home store中封装mapAnchorList</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setMapAnchorList</span>(<span class="hljs-params"><span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    mapAnchorList.<span class="hljs-property">value</span> = data<br>&#125;<br></code></pre></td></tr></table></figure><p>将其他组件中的mapAnchorList ref替换为store中的ref。然后渲染一级地名<br>显示效果：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241005203218.png"><br>接着开发动态渲染二级地名的逻辑，开发思路为监听缩放，在map construct中添加zoom的事件监听，然后重新封装renderAreaNames</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs typescript"> <span class="hljs-title function_">renderAreaNames</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">markers</span>: L.<span class="hljs-property">Marker</span>[] = []<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">getZoom</span>() &gt;= <span class="hljs-number">6</span>) &#123;<br>        <span class="hljs-comment">//渲染二级地名</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">mapAnchorList</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-attr">childrenList</span>: L.<span class="hljs-property">Marker</span>[] = []<br>            childrenList = val.<span class="hljs-property">children</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">const</span> &#123;lat, lng, name&#125; = val<br>                <span class="hljs-keyword">const</span> marker = L.<span class="hljs-title function_">marker</span>(L.<span class="hljs-title function_">latLng</span>([lat, lng,]), &#123;<br>                    <span class="hljs-attr">icon</span>: L.<span class="hljs-title function_">divIcon</span>(&#123;<br>                        <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;map-marker-item&#x27;</span>,<br>                        <span class="hljs-attr">html</span>: <span class="hljs-string">`&lt;div class=&quot;area-mark-item&quot;&gt;<span class="hljs-subst">$&#123;name&#125;</span>&lt;/div&gt;`</span><br>                    &#125;)<br>                &#125;)<br>                <span class="hljs-keyword">return</span> marker<br>            &#125;)<br>            markers = markers.<span class="hljs-title function_">concat</span>(childrenList)<br>        &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//渲染一级地名</span><br>        markers = <span class="hljs-variable language_">this</span>.<span class="hljs-property">mapAnchorList</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> &#123;lat, lng, name&#125; = item<br>            <span class="hljs-keyword">const</span> marker = L.<span class="hljs-title function_">marker</span>(L.<span class="hljs-title function_">latLng</span>([lat, lng,]), &#123;<br>                <span class="hljs-attr">icon</span>: L.<span class="hljs-title function_">divIcon</span>(&#123;<br>                    <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;map-marker-item&#x27;</span>,<br>                    <span class="hljs-attr">html</span>: <span class="hljs-string">`&lt;div class=&quot;area-mark-item&quot;&gt;<span class="hljs-subst">$&#123;name&#125;</span>&lt;/div&gt;`</span><br>                &#125;)<br>            &#125;)<br>            <span class="hljs-keyword">return</span> marker<br>        &#125;)<br>    &#125;<br><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">areaNameLayerGroup</span> = L.<span class="hljs-title function_">layerGroup</span>(markers)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">areaNameLayerGroup</span>.<span class="hljs-title function_">addTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>至此实现效果：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/QQ2024105-204720-HD-ezgif.com-video-to-webp-converter.webp"><br>有个小问题就是缩放到二级地名时，一级地名应当被清除。缩放到显示一级地名时，二级地名应当被清楚<strong>但实际没有</strong>。所以需要修复这个BUG<br>重新封装代码。新增getAreaNameMakerItem函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript">    <span class="hljs-title function_">getAreaNameMakerItem</span>(<span class="hljs-params"><span class="hljs-attr">config</span>: <span class="hljs-title class_">AreaNameConfig</span></span>)&#123;<br>    <span class="hljs-keyword">const</span> &#123;lat, lng, name&#125; = config<br>    <span class="hljs-keyword">return</span> L.<span class="hljs-title function_">marker</span>(L.<span class="hljs-title function_">latLng</span>([lat, lng,]), &#123;<br>        <span class="hljs-attr">icon</span>: L.<span class="hljs-title function_">divIcon</span>(&#123;<br>            <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;map-marker-item&#x27;</span>,<br>            <span class="hljs-attr">html</span>: <span class="hljs-string">`&lt;div class=&quot;area-mark-item&quot;&gt;<span class="hljs-subst">$&#123;name&#125;</span>&lt;/div&gt;`</span><br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>同时重构renderAreaNames</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript">    <span class="hljs-title function_">renderAreaNames</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">areaNameLayerGroup</span>?.<span class="hljs-title function_">clearLayers</span>()<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">markers</span>: L.<span class="hljs-property">Marker</span>[] = []<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">getZoom</span>() &gt;= <span class="hljs-number">6</span>) &#123;<br>        <span class="hljs-comment">//渲染二级地名</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">mapAnchorList</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-attr">childrenList</span>: L.<span class="hljs-property">Marker</span>[] = []<br>            childrenList = val.<span class="hljs-property">children</span>.<span class="hljs-title function_">map</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">getAreaNameMakerItem</span>)<br>            markers = markers.<span class="hljs-title function_">concat</span>(childrenList)<br>        &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">//渲染一级地名</span><br>        markers = <span class="hljs-variable language_">this</span>.<span class="hljs-property">mapAnchorList</span>.<span class="hljs-title function_">map</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">getAreaNameMakerItem</span>)<br>    &#125;<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">areaNameLayerGroup</span> = L.<span class="hljs-title function_">layerGroup</span>(markers)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">areaNameLayerGroup</span>.<span class="hljs-title function_">addTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>到此就正常展示地名了，但是有一个性能问题，当zoom在6，7内反复时。leaflet会不断重复渲染，实际上是没必要的。所以渲染逻辑改为当zoom处于一级与二级缩放临界值时才进行重渲染。<br>重构渲染时机。此处可解释为：curZoom与prevZoom不在同一个区间[4,5]，[6,7]时就渲染</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;zoom&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> curZoom = <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">getZoom</span>()<br>    <span class="hljs-keyword">if</span> (curZoom &gt;= <span class="hljs-number">6</span> != <span class="hljs-variable language_">this</span>.<span class="hljs-property">prevZoom</span> &gt;=<span class="hljs-number">6</span>)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;render&#x27;</span>)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">renderAreaNames</span>()<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">prevZoom</span> = curZoom<br>    &#125;<br><br>&#125;)<br></code></pre></td></tr></table></figure><p>最终效果：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/QQ2024105-204720-HD-ezgif.com-video-to-webp-converter.webp"></p><h1 id="标点动态渲染"><a href="#标点动态渲染" class="headerlink" title="标点动态渲染"></a>标点动态渲染</h1><p>在UI界面选择了标点后在地图上显示相应的标点<br>在home store中找到calcSelectedFilterItems，也即找到选择筛选标点后对于的处理事件。增加*处的代码，标记需要渲染的标点数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">calcSelectedFilterItems</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">any</span>[] = []<br>    <span class="hljs-keyword">let</span> <span class="hljs-attr">pointList</span>: <span class="hljs-built_in">any</span>[] = []   <span class="hljs-comment">//*</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; filterTree.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>; i++)&#123;<br>        <span class="hljs-keyword">const</span> item = filterTree.<span class="hljs-property">value</span>[i]<br>        <span class="hljs-keyword">const</span> activeItems = item.<span class="hljs-property">children</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-built_in">any</span></span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">return</span> child.<span class="hljs-property">active</span><br>        &#125;)<br>        activeItems.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-attr">points</span>: <span class="hljs-built_in">any</span> = item.<span class="hljs-property">children</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;    <span class="hljs-comment">//*</span><br>                <span class="hljs-keyword">return</span> &#123;<br>                    ...val,<br>                    <span class="hljs-attr">icon</span>: item.<span class="hljs-property">icon</span><br>                &#125;<br>            &#125;)<br>            pointList = pointList.<span class="hljs-title function_">concat</span>(points)<br>        &#125;)<br>        res = res.<span class="hljs-title function_">concat</span>(activeItems)<br>    &#125;<br>    selectedFilterItems.<span class="hljs-property">value</span> = res<br>&#125;<br></code></pre></td></tr></table></figure><p>接着创建用于通信的全局变量</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//src/ts/global-data.ts</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">MapManager</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./map-manager.ts&quot;</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalData</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-attr">instance</span>: <span class="hljs-title class_">GlobalData</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title function_">getInstance</span>(): <span class="hljs-title class_">GlobalData</span>&#123;<br>        <span class="hljs-keyword">if</span>(!<span class="hljs-title class_">GlobalData</span>.<span class="hljs-property">instance</span>)&#123;<br>            <span class="hljs-title class_">GlobalData</span>.<span class="hljs-property">instance</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GlobalData</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">GlobalData</span>.<span class="hljs-property">instance</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-attr">mapManager</span>: <span class="hljs-title class_">MapManager</span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> globalDataInst = <span class="hljs-title class_">GlobalData</span>.<span class="hljs-title function_">getInstance</span>()<br></code></pre></td></tr></table></figure><p>将mapManger存入global变量后再在calcSelectedFilterItems函数内合适的位置渲染标点</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript">        <span class="hljs-keyword">if</span> (globalDataInst.<span class="hljs-property">mapManager</span>) &#123;<br>    globalDataInst.<span class="hljs-property">mapManager</span>.<span class="hljs-title function_">renderPoints</span>(pointList)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在renderPoints中添加<code>this.pointerMarkersLayerGroup?.clearLayers()</code>以实现取消标点选择时在地图上清空未选中的标点<br>最终效果：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241007000948.png"></p><h1 id="地图缩放条功能"><a href="#地图缩放条功能" class="headerlink" title="地图缩放条功能"></a>地图缩放条功能</h1><p>使用已有的插件：Leaflet.zoomslider <code>npm i leaflet.zoomslider</code></p><p>引入插件<code>this.map.addControl(new L.control.Zoomslider())</code><br>插件兼容性比较差，遂放弃（</p><h1 id="修复标点偏移BUG"><a href="#修复标点偏移BUG" class="headerlink" title="修复标点偏移BUG"></a>修复标点偏移BUG</h1><p>地图在放大时默认情况下标点会基于左上角定位，也即是在放大时标点会一直往左上角偏移，所以我们重新定位标点的锚点<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241007004211.png"></p><h1 id="地图快速定位"><a href="#地图快速定位" class="headerlink" title="地图快速定位"></a>地图快速定位</h1><p>在LocationBtn中添加对应的事件即可<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241007010147.png"><br>最终效果：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/QQ2024107-1237-HD-ezgif.com-video-to-webp-converter.webp"></p><h1 id="标点点点击选中态"><a href="#标点点点击选中态" class="headerlink" title="标点点点击选中态"></a>标点点点击选中态</h1><p>首先为每个icon数据赋予唯一ID，然后根据id上是否由active类来更改样式<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241007014231.png"></p><p>然后编写样式,一个角的图片通过旋转操作变成四个角</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs css">:<span class="hljs-built_in">deep</span>(.arrow-icon)&#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">display</span>: none;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&quot;../assets/images/map/arrow-l.png&quot;</span>);<br>&#125;<br>:<span class="hljs-built_in">deep</span>(.arrow-icon.lb)&#123;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">6px</span>;<br>&#125;<br>:<span class="hljs-built_in">deep</span>(.arrow-icon.lt)&#123;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleY</span>(-<span class="hljs-number">1</span>);<br>  <span class="hljs-attribute">top</span>: -<span class="hljs-number">5px</span>;<br>&#125;<br>:<span class="hljs-built_in">deep</span>(.arrow-icon.rb)&#123;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scaleX</span>(-<span class="hljs-number">1</span>);<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">6px</span>;<br>&#125;<br>:<span class="hljs-built_in">deep</span>(.arrow-icon.rt)&#123;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(-<span class="hljs-number">1</span>);<br>  <span class="hljs-attribute">top</span>: -<span class="hljs-number">5px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>最终效果：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/QQ2024107-14455-HD-ezgif.com-video-to-webp-converter.webp"></p><h1 id="标点点击弹窗"><a href="#标点点击弹窗" class="headerlink" title="标点点击弹窗"></a>标点点击弹窗</h1><p>使用<a href="https://leafletjs.cn/reference.html#popup">popup</a>实现弹窗功能<br>在renderPoints中添加popupHTML结构和样式</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript">marker.<span class="hljs-title function_">bindPopup</span>(L.<span class="hljs-title function_">popup</span>(&#123;<br>    <span class="hljs-attr">content</span>:<br>        <span class="hljs-string">`&lt;div class=&quot;point-popup-container&quot;&gt;</span><br><span class="hljs-string">                        &lt;div class=&quot;popup-title&quot;&gt;传送锚点&lt;/div&gt;</span><br><span class="hljs-string">                        &lt;div class=&quot;popup-pic&quot; style=&quot;background-image: url(&#x27;https://webstatic.mihoyo.com/upload/wiki-ys-map/2023/01/18/306126220/a2c132b651daf17b7444bc575f2fa04d_790168931618739974.png?x-oss-process=image%2Fresize%2Cw_600%2Fquality%2CQ_90%2Fformat%2Cwebp&#x27;)&quot;&gt;&lt;/div&gt;</span><br><span class="hljs-string">                        &lt;div class=&quot;point-name&quot;&gt;传送锚点（蒙德）&lt;/div&gt;</span><br><span class="hljs-string">                        &lt;div class=&quot;contributor-container&quot;&gt;</span><br><span class="hljs-string">                            &lt;div class=&quot;contributor-label&quot;&gt;贡献者：&lt;/div&gt;</span><br><span class="hljs-string">                            &lt;div class=&quot;avatar-container&quot;&gt;</span><br><span class="hljs-string">                                &lt;div class=&quot;avatar-item&quot; style=&quot;background-image: url(&#x27;https://webstatic.mihoyo.com/upload/wiki-ys-map/2023/01/18/306126220/a2c132b651daf17b7444bc575f2fa04d_790168931618739974.png?x-oss-process=image%2Fresize%2Cw_600%2Fquality%2CQ_90%2Fformat%2Cwebp&#x27;)&quot;&gt;</span><br><span class="hljs-string">                                &lt;/div&gt;</span><br><span class="hljs-string">                            &lt;/div&gt;</span><br><span class="hljs-string">                        &lt;/div&gt;</span><br><span class="hljs-string">                        &lt;div class=&quot;point-time&quot;&gt;更新时间：2021-09&lt;/div&gt;</span><br><span class="hljs-string">                    &lt;/div&gt;`</span><br>&#125;), &#123;<br>    <span class="hljs-attr">maxWidth</span>: <span class="hljs-number">375</span><br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>接下来添加交互逻辑</p></blockquote><p>首先在mock文件中添加mock数据并封装好请求接口<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241007204410.png"><br>然后抽离出calcPopuoContent方法，用于动态生成popupcontent HTML字符串</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">calcPopuoContent</span>(<span class="hljs-params"><span class="hljs-attr">popupData</span>:<span class="hljs-built_in">any</span></span>)&#123;<br>    <span class="hljs-keyword">const</span> &#123;correct_user_list, last_update_time, info&#125; = popupData<br>    <span class="hljs-keyword">const</span> avatarElmStr = correct_user_list.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;div class=&quot;avatar-item&quot; style=&quot;background-image: url(<span class="hljs-subst">$&#123;val.img&#125;</span>)&quot;&gt;&lt;/div&gt;`</span><br>    &#125;)<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;div class=&quot;point-popup-container&quot;&gt;</span><br><span class="hljs-string">                    &lt;div class=&quot;popup-title&quot;&gt;传送锚点&lt;/div&gt;</span><br><span class="hljs-string">                    &lt;div class=&quot;popup-pic&quot; style=&quot;background-image: url(<span class="hljs-subst">$&#123;info.img&#125;</span>)&quot;&gt;&lt;/div&gt;</span><br><span class="hljs-string">                    &lt;div class=&quot;point-name&quot;&gt;<span class="hljs-subst">$&#123;info.content&#125;</span>&lt;/div&gt;</span><br><span class="hljs-string">                    &lt;div class=&quot;contributor-container&quot;&gt;</span><br><span class="hljs-string">                        &lt;div class=&quot;contributor-label&quot;&gt;贡献者：&lt;/div&gt;</span><br><span class="hljs-string">                        &lt;div class=&quot;avatar-container&quot;&gt;</span><br><span class="hljs-string">                            <span class="hljs-subst">$&#123;avatarElmStr&#125;</span></span><br><span class="hljs-string">                        &lt;/div&gt;</span><br><span class="hljs-string">                    &lt;/div&gt;</span><br><span class="hljs-string">                    &lt;div class=&quot;point-time&quot;&gt;更新时间：<span class="hljs-subst">$&#123;last_update_time&#125;</span>&lt;/div&gt;</span><br><span class="hljs-string">                &lt;/div&gt;`</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后在marker中监听popup事件并使用<code>marker.setPopupContent</code>方法重设popup content</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript">marker.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;popupopen&#x27;</span>, <span class="hljs-title function_">async</span>()=&gt;&#123;<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getMapPointDetail</span>(pointId)<br>    marker.<span class="hljs-title function_">setPopupContent</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">calcPopuoContent</span>(res.<span class="hljs-property">data</span>))<br>&#125;)<br></code></pre></td></tr></table></figure><p>注意优化关闭popup时的功能，地图上监听click事件，当popup关闭时，标点的激活态应该被移除</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-keyword">const</span> lastActivePoint = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">`mapPointItem<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.lastActivePointId&#125;</span>`</span>)<br>    lastActivePoint?.<span class="hljs-property">classList</span>.<span class="hljs-title function_">remove</span>(<span class="hljs-string">&#x27;active&#x27;</span>)<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastActivePointId</span> = -<span class="hljs-number">1</span><br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>BUG 修复： 目前的popup弹窗中左上角的标题没有被更改，在home store中的calcSelectedFilterItems需传入name: item.name，然后再在模板中渲染值</p></blockquote><p>最终效果：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/QQ2024107-205819-HD-ezgif.com-video-to-webp-converter.webp"></p><h1 id="屏幕外标点引导"><a href="#屏幕外标点引导" class="headerlink" title="屏幕外标点引导"></a>屏幕外标点引导</h1><p>新建calcOutScreenPoints函数用于渲染屏幕外标点的引导UI</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">calcOutScreenPoints</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">guideUIAry</span>: <span class="hljs-title class_">GuideUiItem</span>[]<br>        <span class="hljs-keyword">const</span> <span class="hljs-attr">calcPointMap</span>: &#123; [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span> &#125; = &#123;&#125;<br>        <span class="hljs-keyword">const</span> center = <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">getCenter</span>()<br>        <span class="hljs-comment">//遍历选中的标点，为选中的标点保存是否在屏幕中的信息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-keyword">const</span> pointItem = <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointList</span>[i]<br>            <span class="hljs-keyword">const</span> &#123;name, lat, lng&#125; = pointItem<br><br>            <span class="hljs-keyword">if</span> (!calcPointMap[name]) &#123;<br>                calcPointMap[name] = &#123;&#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (calcPointMap[name].<span class="hljs-property">inScreen</span>) &#123;<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            <span class="hljs-keyword">const</span> isContain = <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">getBounds</span>().<span class="hljs-title function_">contains</span>(pointItem)<br><br>            <span class="hljs-keyword">if</span> (!isContain) &#123;<br>                <span class="hljs-keyword">const</span> dist = <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>.<span class="hljs-title function_">getCenter</span>().<span class="hljs-title function_">distanceTo</span>(pointItem)<br>                <span class="hljs-keyword">if</span> (!calcPointMap[name].<span class="hljs-property">pointItem</span>) &#123;<br>                    calcPointMap[name] = &#123;dist, pointItem, <span class="hljs-attr">inScreen</span>: <span class="hljs-literal">false</span>&#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">const</span> curDist = calcPointMap[name].<span class="hljs-property">dist</span><br>                    <span class="hljs-keyword">if</span> (dist &lt; curDist) &#123;<br>                        calcPointMap[name] = &#123;dist, pointItem, <span class="hljs-attr">inScreen</span>: <span class="hljs-literal">false</span>&#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                calcPointMap[name].<span class="hljs-property">inScreen</span> = <span class="hljs-literal">true</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//将所有在屏幕外</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> calcPointMap) &#123;<br>            <span class="hljs-keyword">const</span> &#123;inScreen, pointItem&#125; = calcPointMap[key]<br>            <span class="hljs-keyword">if</span> (!inScreen) &#123;<br>                <span class="hljs-keyword">const</span> &#123;lat, lng, icon&#125; = pointItem<br>                <span class="hljs-keyword">const</span> directionVector = &#123;<span class="hljs-attr">x</span>: lng - center, <span class="hljs-attr">y</span>: lat - center.<span class="hljs-property">lat</span>&#125;<br>                <span class="hljs-keyword">const</span> xVector = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span>&#125;<br>                <span class="hljs-keyword">const</span> angle = <span class="hljs-title function_">calcVectorAngle</span>(xVector, directionVector)<br>                guideUIAry.<span class="hljs-title function_">push</span>(&#123;angle, icon, lat, lng&#125;)<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>搭建GuideMarker样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script lang=&quot;ts&quot; setup&gt;<br><br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div class=&quot;guide-marker-ui&quot;&gt;<br>    &lt;div v-for=&quot;item in 1&quot; :key=&quot;item&quot; class=&quot;guide-marker-item&quot;&gt;<br>      &lt;div class=&quot;marker-bg&quot;&gt;<br>        &lt;div class=&quot;arrows-icon&quot;&gt;&lt;/div&gt;<br>      &lt;/div&gt;<br>      &lt;div class=&quot;marker-img-container&quot;&gt;<br>        &lt;img :src=&quot;item.icon&quot; alt=&quot;&quot; class=&quot;item-icon&quot;&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.guide-marker-ui&#123;<br>  position: fixed;<br>  top: 0;<br>  left: 0;<br>  width: 100vw;<br>  height: 100vh;<br>  z-index: 999;<br>  pointer-events: none;<br>&#125;<br>.guide-marker-item&#123;<br>  pointer-events: auto;<br>  display: flex;<br>  justify-content: center;<br>  align-items: center;<br>  width: 53px;<br>  height: 53px;<br>  cursor: pointer;<br>  position: absolute;<br>  left: 50%;<br>  top: 50%;<br>  transform: translate(-50%, -50%);<br>&#125;<br>.marker-bg&#123;<br>  position: absolute;<br>  width: 100%;<br>  height: 100%;<br>  border-radius: 50%;<br>  background-color: rgba(0, 0, 0, 0.5);<br>  border: 1px solid hsla(0, 0%, 100%, 0.3);<br>&#125;<br>.arrows-icon&#123;<br>  position: absolute;<br>  left: -19px;<br>  top: 15px;<br>  width: 19px;<br>  height: 26px;<br>  background-image: url(&quot;../assets/images/ui/guide-arrow.png&quot;);<br>  background-size: cover;<br>&#125;<br>.marker-img-container&#123;<br>  position: relative;<br>  width: 48px;<br>  z-index: 999;<br>  height: 48px;<br>&#125;<br>.item-icon&#123;<br>width: 100%;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>GuideMarkerUI接收绘制UI事件<br>安装events库，并新建event-manager类管理事件<br>在calcOutScreenPoints中发布计算完毕事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script lang=&quot;ts&quot; setup&gt;<br>import &#123;EventManager&#125; from &quot;../ts/event-manager.ts&quot;;<br>import type &#123;GuideUiItem&#125; from &#x27;../ts/map-manager.ts&#x27;<br>import &#123;ref&#125; from &#x27;vue&#x27;<br><br>const guideUiAry = ref()<br><br>EventManager.on(&#x27;RenderMapGuideUI&#x27;, onRenderMapGuideUI)<br><br>function onRenderMapGuideUI(data: GuideUiItem[]) &#123;<br>  guideUiAry.value = data<br>&#125;<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><blockquote><p>之前文章中的q部分代码有BUG，注意识别</p></blockquote><p>编写guideUI位移计算函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">calcOffsetStyle</span>(<span class="hljs-params"><span class="hljs-attr">item</span>: <span class="hljs-built_in">any</span></span>)&#123;<br>  <span class="hljs-keyword">let</span> &#123;innerWidth, innerHeight&#125; = <span class="hljs-variable language_">window</span><br>  <span class="hljs-keyword">let</span> &#123;angle&#125; = item<br>  <span class="hljs-keyword">let</span> marginTop<br>  <span class="hljs-keyword">let</span> marginLeft<br>  <br>  <span class="hljs-keyword">if</span>(angle &gt; <span class="hljs-number">0</span>)&#123;<br>    marginTop = innerHeight / <span class="hljs-number">2</span><br>    marginLeft = marginTop / <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">tan</span>(angle)<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    marginTop = - innerHeight / <span class="hljs-number">2</span><br>    marginLeft = marginTop / <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">tan</span>(angle)<br>  &#125;<br>  <br>  <span class="hljs-keyword">let</span> finalX = <span class="hljs-string">`<span class="hljs-subst">$&#123;innerWidth / <span class="hljs-number">2</span> + marginLeft &#125;</span>`</span><br>  <span class="hljs-keyword">let</span> finalY = <span class="hljs-string">`<span class="hljs-subst">$&#123;innerHeight / <span class="hljs-number">2</span> - marginTop&#125;</span>`</span><br>    <br>    <span class="hljs-comment">//防止在外面</span><br>  finalX = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, finalX)<br>  finalY = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-number">0</span>, finalY)<br>    <br>  finalX = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(innerWidth - <span class="hljs-number">53</span>, finalX)<br>  finalY = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">min</span>(innerHeight - <span class="hljs-number">53</span>, finalY)<br><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(finalY)<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">transform</span>: <span class="hljs-string">`translate(<span class="hljs-subst">$&#123;finalX&#125;</span>px,<span class="hljs-subst">$&#123;finalY&#125;</span>px)`</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>坐标计算分析简图：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/1679167bfe0e338fcdead62ad87d85d.jpg"><br>实现效果：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241009205050.png"><br>接着旋转指针</p><blockquote><p>以上代码依然有BUG，有时间完善</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>Vue.js</tag>
      
      <tag>Typescript</tag>
      
      <tag>Vite</tag>
      
      <tag>Leaflet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原神大地图——2.UI交互层开发</title>
    <link href="/2024/10/01/%E5%8E%9F%E7%A5%9E%E5%A4%A7%E5%9C%B0%E5%9B%BE%E2%80%94%E2%80%942-UI%E4%BA%A4%E4%BA%92%E5%B1%82%E5%BC%80%E5%8F%91/"/>
    <url>/2024/10/01/%E5%8E%9F%E7%A5%9E%E5%A4%A7%E5%9C%B0%E5%9B%BE%E2%80%94%E2%80%942-UI%E4%BA%A4%E4%BA%92%E5%B1%82%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>** 注意！！！** map与ui-layer应该具有同一个父元素，而不是父子关系，否则map会捕获所有鼠标事件<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241002174719.png"></p></blockquote><p>本节将开发<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001204056.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001204116.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001204135.png"></p><h1 id="整体ui搭建"><a href="#整体ui搭建" class="headerlink" title="整体ui搭建"></a>整体ui搭建</h1><p>首先编写左侧filter-config代码<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001204507.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div id=&quot;map-container&quot;&gt;<br>    &lt;div id=&quot;map&quot;&gt;<br>      &lt;div class=&quot;ui-layer&quot;&gt;<br>        &lt;div class=&quot;filter-container&quot;&gt;<br><br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>  .ui-layer .filter-container&#123;<br>    position: absolute;<br>    left: 0;<br>    top: 0;<br>    bottom: 0;<br>    width: 415px;<br>    padding: 20px;<br>  &#125;<br>  .ui-layer .filter-container .filter-content&#123;<br>    position: relative;<br>    display: flex;<br>    flex-direction: column;<br>    background-color: #3b4354;<br>    width: 100%;<br>    height: 100%;<br>    border-radius: 12px;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001205523.png"><br>基本的ui框架搭建完成分析官网中的界面，可以进行组件拆分<br>在component下新建FilterHeader.vue组件并在filter-container中引入该组件<br>首先完成header部分效果<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001211122.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001211057.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;style scoped&gt;<br>.filter-header &#123;<br>  display: flex;<br>  align-items: center;<br>  padding: 12px 7px 7px 10px;<br>  color: #d3bc8e;<br>&#125;<br>.header-icon &#123;<br>  width: 40px;<br>  height: 40px;<br>  background-image: url(&quot;../assets/images/ui/xumi-icon.png&quot;);<br>  background-size: cover;<br>  margin-right: 5px;<br>&#125;<br>.header-name&#123;<br>  font-size: 18px;<br>  font-weight: bold;<br><br>  margin-right: 10px;<br>&#125;<br>.switch-btn&#123;<br>  display: flex;<br>  align-items: center;<br>  padding: 4px 8px 4px 4px;<br>  border-radius: 12px;<br>  background-color: rgb(74, 83, 102);<br>&#125;<br>.switch-icon&#123;<br>  width: 16px;<br>  height: 16px;<br>  background-image: url(&quot;../assets/images/ui/switch-btn.png&quot;);<br>  background-size: cover;<br>&#125;<br>.switch-text&#123;<br>  font-size: 12px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>编写关闭按钮代码和样式<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001212656.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001212754.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">.close-btn&#123;<br>  position: absolute;<br>  top: 32px;<br>  right: -44px;<br>  width: 64px;<br>  height: 40px;<br>  background-image: url(&quot;../assets/images/ui/close-bg.png&quot;);<br>  background-size: cover;<br>  display: flex;<br>  align-items: center;<br>  padding-left: 18px;<br>  box-sizing: border-box;<br>  z-index: 10;<br>&#125;<br>.close-icon&#123;<br>  width: 24px;<br>  height: 24px;<br>  background-image: url(&quot;../assets/images/ui/close-icon.png&quot;);<br>  background-size: cover;<br>&#125;<br></code></pre></td></tr></table></figure><p>新建LocationBtn.vue并在Filter-header上方引入。实现一个占位组件<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001213219.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;location-btn&quot;&gt;<br><br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.location-btn&#123;<br>  position: absolute;<br>  top: 84px;<br>  right: -30px;<br>  width: 40px;<br>  height: 40px;<br>  background-color: rgba(50,57,71,0.8);<br>  border-radius: 8px;<br>  cursor: pointer;<br>&#125;<br></code></pre></td></tr></table></figure><p>新建SelectedArea组件，内容与LocationBtn类似，调整以下top值到合适的位置即可<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001213520.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001213543.png"></p><p>新建FilterMain组件，编写相应UI代码并引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;div class=&quot;filter-main&quot;&gt;<br>  &lt;div class=&quot;filter-main-left&quot;&gt;<br><br>  &lt;/div&gt;<br>  &lt;div class=&quot;filter-main-right&quot;&gt;&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.filter-main&#123;<br>  flex: 1;<br>  display: flex;<br><br>&#125;<br>.filter-main-left&#123;<br>  width: 97px;<br>  background: #323947;<br>&#125;<br>.filter-main-right&#123;<br>  flex: 1;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>最终的filter区域HTML结构：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001214042.png"><br>效果展示：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001214105.png"></p><h1 id="交互栏开发"><a href="#交互栏开发" class="headerlink" title="交互栏开发"></a>交互栏开发</h1><p>本节搭建搜索框和左侧的筛选列表<br>搜索框HTML部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div class=&quot;search-container&quot;&gt;<br>  &lt;div class=&quot;search-icon&quot;&gt;&lt;/div&gt;<br>  &lt;div class=&quot;search-tip&quot;&gt;搜索&lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>CSS部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vue">.search-container &#123;<br>  height: 32px;<br>  width:355px;<br>  display: flex;<br>  align-items: center;<br>  background-color: #323947;<br>  border-radius: 22px;<br>  padding-left: 10px;<br>  margin: 10px auto;<br>  font-size: 12px;<br>  color: #9b9c9f;<br>&#125;<br>.search-icon &#123;<br>  width: 16px;<br>  height: 16px;<br>  background-image: url(&quot;../assets/images/ui/search-icon.png&quot;);<br>  background-size: cover;<br>  margin: 0 5px 0 1px;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241002212939.png"><br>接着开发筛选列表部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs vue"><br>&lt;template&gt;<br>&lt;div class=&quot;filter-main&quot;&gt;<br>  &lt;div class=&quot;filter-main-left&quot;&gt;<br>    &lt;div class=&quot;filter-type-item&quot; v-for=&quot;item in 20&quot; :key=&quot;item&quot;&gt;<br>      &lt;div class=&quot;item-name&quot;&gt;传送点&lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>  &lt;div class=&quot;filter-main-right&quot;&gt;&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.filter-main&#123;<br>  flex: 1;<br>  display: flex;<br>  overflow: hidden;<br>&#125;<br><br>.filter-main-left&#123;<br>  width: 97px;<br>  background: #323947;<br>  overflow-y: auto;<br>&#125;<br>.filter-main-left::-webkit-scrollbar&#123;<br>  display: none;<br>&#125;<br>.filter-main-right&#123;<br>  flex: 1;<br>&#125;<br>.filter-type-item&#123;<br>  display: flex;<br>  align-items: center;<br>  padding: 16px 16px;<br>&#125;<br>.item-name&#123;<br>  color: hsla(39, 34%, 89%, 0.75);<br>  font-size: 12px<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>增加小角标</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">.item-count&#123;<br>  position: absolute;<br>  top: 5px;<br>  right: 4px;<br>  border-radius: 6px;<br>  line-height: 12px;<br>  font-size: 9px;<br>  color: #d3bc8e;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003190155.png"><br>添加筛选列表点击功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup lang=&quot;ts&quot;&gt;<br>import &#123;ref&#125; from &quot;vue&quot;;<br><br>const activeTypeIndex = ref(0)<br><br>function onTypeItemClick(index: number) &#123;<br>  activeTypeIndex.value=index<br><br>&#125;<br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div class=&quot;filter-main&quot;&gt;<br>    &lt;div class=&quot;filter-main-left&quot;&gt;<br>      &lt;div class=&quot;filter-type-item&quot; :class=&quot;&#123;active: item === activeTypeIndex&#125;&quot; v-for=&quot;item in 20&quot; :key=&quot;item&quot; @click=&quot;onTypeItemClick(item)&quot;&gt;<br>        &lt;div class=&quot;item-name&quot;&gt;传送点&lt;/div&gt;<br>        &lt;div class=&quot;item-count&quot;&gt;3&lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>    &lt;div class=&quot;filter-main-right&quot;&gt;&lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;style&gt;<br>  //...<br>  .active &#123;<br>    background-image: url(&quot;../assets/images/ui/filter-item-dec.png&quot;), url(&quot;../assets/images/ui/filter-item-dec2.png&quot;);<br>    background-size: 5px 100%, 24px 100%;<br>    background-position: 0 0, 5px 0;<br>    background-repeat: no-repeat;<br>    background-color: #3b4354;<br>    //将文字往右边推一点空间，显示出动态<br>    padding:  16px 20px;<br>    color: #d3bc8e !important;<br>  &#125;<br>  <br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003191840.png"></p><h1 id="标点列表展示"><a href="#标点列表展示" class="headerlink" title="标点列表展示"></a>标点列表展示</h1><p>实现这部分内容首先分析数据结构需要用两个数组<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003192007.png"><br>可先完成UI界面搭建，即在filter-main-right部分编写代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">  &lt;div class=&quot;filter-main-right&quot;&gt;<br>&lt;!--  此处编写  ...--&gt;<br>  &lt;/div&gt;<br></code></pre></td></tr></table></figure><p>搭建好基本结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div class=&quot;filter-main-right&quot;&gt;<br>  &lt;div class=&quot;filter-content-item&quot; v-for=&quot;i in 10&quot; :key = &quot;i&quot;&gt;<br>    &lt;div class=&quot;content-head&quot;&gt;<br>      &lt;div class=&quot;head-title&quot;&gt;露天宝箱&lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003192309.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;style&gt;<br>  .filter-main-right&#123;<br>    flex: 1;<br>    padding: 0 3px;<br>  &#125;<br>  .filter-content-item&#123;<br><br>  &#125;<br>  .content-head&#123;<br>    padding: 16px 0 0 2px<br>  &#125;<br>  .head-title&#123;<br>    color: #d3bc8e;<br>    font-size: 14px;<br><br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003192957.png"><br>完成title部分继续完善body部分<br>完成列表布局<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003193606.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vue">.content-body&#123;<br>display: flex;<br>  flex-wrap: wrap;<br>&#125;<br>.content-item&#123;<br><br>&#125;<br>.item-icon-container&#123;<br>  position: relative;<br>  width: 57px;<br>  height:57px;<br>  border-radius: 6px;<br>  background: #323947;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003193717.png"><br>完成item角标布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs vue">.icon-count&#123;<br>  position: absolute;<br>  font-size: 10px;<br>  right: 0;<br>  bottom: 0;<br>  line-height: 13px;<br>  color: #9b9c9f;<br>  background-color: #323947;<br>  padding: 0 4px;<br>  border-radius: 6px 0 6px 0;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003194346.png"><br>完成列表文字布局</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">.content-item-name&#123;<br>  margin-top: 5px;<br>  font-size:12px;<br>  color: hsla(39, 34%, 89%, 0.75);<br>  max-width: 57px;<br>  overflow: hidden;<br>  white-space: nowrap;<br>  text-overflow: ellipsis;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003194726.png"><br>然后给content-body以及content-item加margin以美化显示效果</p><blockquote><p>部分美化效果没有写全，最终效果如下图所示<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003195935.png"></p></blockquote><p>添加滚动</p><h1 id="axios及mockjs引入"><a href="#axios及mockjs引入" class="headerlink" title="axios及mockjs引入"></a>axios及mockjs引入</h1><p>封装axios请求,建立一下目录结构：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003204814.png"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//@/ts/api/base-request.ts</span><br><br><span class="hljs-keyword">import</span> axios, &#123;<span class="hljs-keyword">type</span> <span class="hljs-title class_">AxiosInstance</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseRequest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">axiosInst</span>: <span class="hljs-title class_">AxiosInstance</span>;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">host</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">axiosInst</span> = axios.<span class="hljs-title function_">create</span>(&#123;<br>            <span class="hljs-attr">baseURL</span>: host,<br>            <span class="hljs-attr">withCredentials</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">headers</span>: &#123;<br>                <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span>,<br>            &#125;,<br>            <span class="hljs-attr">timeout</span>: <span class="hljs-number">15000</span>,<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-title function_">sendRequest</span>(<span class="hljs-attr">method</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">params</span>: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>, <span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>): <span class="hljs-title class_">AxiosInstance</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">axiosInst</span>.<span class="hljs-title function_">request</span>(&#123;method, <span class="hljs-attr">url</span>:path, params,data&#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> mainRequest = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseRequest</span>(<span class="hljs-string">&#x27;http://127.0.0.1/map&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//@/ts/api/index.ts</span><br><span class="hljs-keyword">import</span> &#123;mainRequest&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./base-request.ts&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getMapFilterTree</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> mainRequest.<span class="hljs-title function_">sendRequest</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;/label/tree&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>withCredentials字段解读：有些时候我们会发一些跨域请求，比如 domain-a.com 站点发送一个 api.domain-b.com&#x2F;get 的请求，默认情况下，浏览器会根据同源策略限制这种跨域请求，但是可以通过 CORS (opens new window)技术解决跨域问题。</p></blockquote><blockquote><p>widthCredentials在同源下(相同域下是无效的)，也就是相同域下都会请求写在cookie。</p><p>在同域的情况下，我们发送请求会默认携带当前域下的 cookie，但是在跨域的情况下，默认是不会携带请求域下的 cookie 的，比如 domain-a.com 站点发送一个 api.domain-b.com&#x2F;get 的请求，默认是不会携带 api.domain-b.com 域下的 cookie，如果我们想携带（很多情况下是需要的），只需要设置请求的 xhr 对象的 withCredentials 为 true 即可。</p></blockquote><blockquote><p>跨域情况下，需要携带请求域下的cookie那么就需要配置xhr对象的withCredentials。</p></blockquote><p>然后在@&#x2F;mock&#x2F;index.ts下面引入mock,并在main.ts中执行mock<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003210146.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003210225.png"><br>执行后正确输出响应内容，但是data部分需要优化<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241003210347.png"><br>切换到@&#x2F;ts&#x2F;api&#x2F;base-request.ts文件，修改sendRequest方法为：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">sendRequest</span>(<span class="hljs-attr">method</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">params</span>: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>, <span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span> = <span class="hljs-literal">null</span>): <span class="hljs-title class_">AxiosInstance</span> &#123;<br>    <span class="hljs-comment">// return this.axiosInst.request(&#123;method, url:path, params,data&#125;)</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">axiosInst</span><br>            .<span class="hljs-title function_">request</span>(&#123;method, <span class="hljs-attr">url</span>:path, params,data&#125;)<br>            .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>)=&gt;</span>&#123;<br>                <span class="hljs-title function_">resolve</span>(res.<span class="hljs-property">data</span>)<br>            &#125;)<br>            .<span class="hljs-title function_">catch</span>(reject)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="替换静态标点列表"><a href="#替换静态标点列表" class="headerlink" title="替换静态标点列表"></a>替换静态标点列表</h1><p>根据请求数据结构替换template中的占位数据就行。此处掠过<br>接下来开发标点选中功能<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241004161719.png"><br>通过给响应式数据添加属性的方式确定被选中的元素，所以在content-item上添加点击事件，并将传进来的数据用Reflecct.set设置属性<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241004161929.png"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onFilterItemClick</span>(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-built_in">any</span></span>)&#123;<br>  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(child, <span class="hljs-string">&#x27;active&#x27;</span>, !child.<span class="hljs-property">active</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后给itemActive添加CSS属性，使用after伪类添加边框</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs vue">.itemActive .item-icon-container::after&#123;<br>  position: absolute;<br>  display: block;<br>  content: &#x27;&#x27;;<br>  top: 0;<br>  left: 0;<br>  width: 100%;<br>  height: 100%;<br>  border: 0.5px solid #d3bc8e;<br>  box-sizing: border-box;<br>  z-index: 2;<br>&#125;<br></code></pre></td></tr></table></figure><p>完善细节，添加selected-icon</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>//...<br>&lt;div class=&quot;item-icon-container&quot;&gt;<br>  &lt;div :style=&quot;&#123;backgroundImage: `url($&#123;child.icon&#125;)`&#125;&quot; class=&quot;icon-pic&quot;&gt;&lt;/div&gt;<br>  &lt;div class=&quot;icon-count&quot;&gt;11161&lt;/div&gt;<br>  &lt;div class=&quot;selected-icon&quot; v-if=&quot;child.active&quot; &gt;&lt;/div&gt;<br>&lt;/div&gt;<br>&lt;/template&gt;<br>&lt;style&gt;<br>  .selected-icon&#123;<br>    position: absolute;<br>    top: 0;<br>    right: -1px;<br>    width: 24px;<br>    height: 14px;<br>    background-image: url(&quot;../assets/images/ui/select-icon.png&quot;);<br>    background-size: cover;<br>  &#125;<br>  <br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241004162916.png"></p><p>接着联动左侧筛选列表的右上角标点选中数量。<br>在item-count处添加getActiveCount函数。统计思路即为统计所有child中active的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>  function getActiveCount(item: any)&#123;<br>    let res = 0<br>    for (let i = 0; i &lt; item.children.length; i++) &#123;<br>      let child = item.children[i]<br>      if(child.active)&#123;<br>        res++<br>      &#125;<br>    &#125;<br>    return res<br>  &#125;<br>&lt;/script&gt;<br>&lt;template&gt;<br>  &lt;div class=&quot;filter-main-left&quot;&gt;<br>    &lt;div v-for=&quot;item in filterTree&quot; :key=&quot;item.id&quot; :class=&quot;&#123;active: item === activeTypeIndex&#125;&quot; class=&quot;filter-type-item&quot;<br>         @click=&quot;onTypeItemClick(item)&quot;&gt;<br>      &lt;div class=&quot;item-name&quot;&gt;&#123;&#123;item.name&#125;&#125;&lt;/div&gt;<br>      &lt;div class=&quot;item-count&quot; v-if=&quot;getActiveCount(item) != 0&quot;&gt;&#123;&#123;getActiveCount(item)&#125;&#125;&lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241004163847.png"></p><p>然后实现选中左侧筛选列表是右侧滚动到指定区域，使用scrollIntoView方法即可<br>首先需要标记滚动锚点，我们在filter-content-item上使用filterContentItem${index}做滚动锚点<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241004175349.png"><br>然后在onTypeItemClick事件中添加响应的处理事件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vue">function onTypeItemClick(index: number) &#123;<br>  activeTypeIndex.value = index<br><br>  document.querySelector(`#filterContentItem$&#123;index&#125;`)?.scrollIntoView(&#123;behavior: &#x27;smooth&#x27;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/QQ2024104-16476.gif"></p><h2 id="BUG修复：Flex元素最后一行靠左显示"><a href="#BUG修复：Flex元素最后一行靠左显示" class="headerlink" title="BUG修复：Flex元素最后一行靠左显示"></a>BUG修复：Flex元素最后一行靠左显示</h2><p>由于flex容器的justify-content的值设置为space-bewteen，当容器类元素数量大于1且小于4时会导致布局异常，如下图<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241004175955.png"><br>为了解决这个问题，可以在容器上添加::after伪类并设flex为1或auto解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vue">.content-body::after&#123;<br>  content: &#x27;&#x27;;<br>  flex: 1;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241004180238.png"><br>可参考：<a href="https://www.zhangxinxu.com/wordpress/2019/08/css-flex-last-align/">让CSS flex布局最后一行列表左对齐的N种方法</a></p><h1 id="快速定位展示"><a href="#快速定位展示" class="headerlink" title="快速定位展示"></a>快速定位展示</h1><p>本节开发<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241004200313.png"><br>转到LocationBtn组件首先绘制UI部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script lang=&quot;ts&quot; setup&gt;<br><br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div class=&quot;location-btn&quot;&gt;<br>    &lt;div class=&quot;location-icon&quot;&gt;<br>    &lt;/div&gt;<br>    &lt;div class=&quot;location-content&quot;&gt;<br>      &lt;div class=&quot;location-title&quot;&gt;<br>        快速定位<br>      &lt;/div&gt;<br>      &lt;div class=&quot;content-areas&quot;&gt;<br>        &lt;div class=&quot;area-item&quot; v-for=&quot;item in 10&quot; :key=&quot;item&quot;&gt;<br>          &lt;div class=&quot;area-parent&quot;&gt;<br>            &lt;div class=&quot;parent-icon&quot;&gt;&lt;/div&gt;<br>            &lt;div class=&quot;parent-name&quot;&gt;莱因山&lt;/div&gt;<br>          &lt;/div&gt;<br>          &lt;div class=&quot;area-child&quot; v-for=&quot;i in 5&quot;:key=&quot;i&quot;&gt;赤望台&lt;/div&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.location-btn &#123;<br>  position: absolute;<br>  top: 84px;<br>  right: -30px;<br>  width: 40px;<br>  height: 40px;<br>  background-color: rgba(50, 57, 71, 0.8);<br>  border-radius: 8px;<br>  cursor: pointer;<br>  display: flex;<br>  justify-content: center;<br>  align-items: center;<br>&#125;<br>.location-btn:hover .location-content &#123;<br>  visibility: visible;<br>&#125;<br>.location-icon&#123;<br>  height: 24px;<br>  width: 24px;<br>  background-image: url(&quot;../assets/images/ui/location-btn.png&quot;);<br>  background-size: cover;<br>&#125;<br>.location-content&#123;<br>  transition: all 0.5s ease;<br>  visibility: hidden;<br>  position: absolute;<br>  top: 0;<br>  width: 192px;<br>  padding: 10px 20px;<br>  left: 60px;<br>  background-color: #3b4354;<br>  border-radius: 12px;<br>&#125;<br>.location-title&#123;<br>  font-size: 16px;<br>  color: #d3bc8e;<br>&#125;<br>.content-areas&#123;<br>  height: 500px;<br>  overflow-y: auto;<br>&#125;<br>.content-areas::-webkit-scrollbar &#123;<br>  display: none;<br>&#125;<br>.area-item&#123;<br><br>&#125;<br>.area-parent&#123;<br>  display: flex;<br>  align-items: center;<br>  height: 48px;<br>&#125;<br>.area-parent:hover .parent-name,.area-child&#123;<br>  color: #ece5d8;<br>&#125;<br>.area-parent:hover .parent-icon&#123;<br>  background-image: url(&quot;../assets/images/ui/location-icon-h.png&quot;);<br>&#125;<br>.parent-icon&#123;<br>  width: 12px;<br>  height: 12px;<br>  background-image: url(&quot;../assets/images/ui/location-icon-n.png&quot;);<br>  background-size: cover;<br>  margin-right: 5px;<br>&#125;<br>.parent-name&#123;<br>  color: #d3bc8e;<br>  font-size: 14px;<br>&#125;<br>.area-child&#123;<br>  display: flex;<br>  align-items: center;<br>  height: 48px;<br>  color: hsla(39, 34%, 89%, 0.75);<br>  padding: 0 17px;<br>  font-size: 14px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><blockquote><p>难点：在location-btn进行hover时，快速定位面板因为visibility的属性会消失的很快。所以可以用一个小技巧，在location-content处添加<code>transition: all 0.5s ease;</code>这样hover在location-btn的时候再移出，location-content面板就不会立马消失了</p></blockquote><p>最终效果：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/QQ2024104-203919-HD.webp"></p><p>最后对快速定位模块接入接口</p><p>1.编写接口mock</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//src/mock/index.ts</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mockMapAnchorList</span>(<span class="hljs-params"></span>) &#123;<br>    mock.<span class="hljs-title function_">mock</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;MAIN_HOST&#125;</span>/map_anchor/list($|\\?.*)`</span>), &#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>        <span class="hljs-attr">data</span>: <span class="hljs-title class_">MapAnchorList</span>,<br>        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;成功&#x27;</span><br>    &#125;)<br><br>&#125;<br><br><br><span class="hljs-comment">//src/ts/api/index.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getMapAnchorList</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> mainRequest.<span class="hljs-title function_">sendRequest</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;/map_anchor/list&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>2.替换静态数据为动态数据<br>（略</p><h1 id="已选中区域开发"><a href="#已选中区域开发" class="headerlink" title="已选中区域开发"></a>已选中区域开发</h1><p>1.ui搭建<br>转至selectedArea组件，进行静态页面搭建</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;selected-area&quot;&gt;<br>    &lt;div class=&quot;selected-count&quot;&gt;2&lt;/div&gt;<br>    &lt;div class=&quot;selected-icon&quot;&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>.selected-area &#123;<br>  position: absolute;<br>  top: 136px;<br>  right: -30px;<br>  width: 40px;<br>  height: 40px;<br>  background-color: rgba(50, 57, 71, 0.8);<br>  border-radius: 8px;<br>  cursor: pointer;<br>  display: flex;<br>  justify-content: center;<br>  align-items: center;<br>&#125;<br>.selected-count&#123;<br>  position: absolute;<br>  top: -4px;<br>  right: -4px;<br>  background-color: #ff5e41;<br>  height: 12px;<br>  width: 12px;<br>  text-align: center;<br>  line-height: 12px;<br>  font-size: 11px;<br>  border-radius: 6px;<br>  padding: 0 3px;<br>  color: #ece5d8;<br>&#125;<br>.selected-icon &#123;<br>  width: 24px;<br>  height: 24px;<br>  background-image: url(&quot;../assets/images/ui/cart-icon.png&quot;);<br>  background-size: cover;<br><br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>效果展示：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241004230548.png"><br>接着开发下拉列表，开发之前可以先将selected-count与selected-icon部分注释掉<br>下拉列表代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;selected-area&quot;&gt;<br>    &lt;!--    &lt;div class=&quot;selected-count&quot;&gt;2&lt;/div&gt;--&gt;<br>    &lt;!--    &lt;div class=&quot;selected-icon&quot;&gt;--&gt;<br>    &lt;!--    &lt;/div&gt;--&gt;<br>    &lt;div class=&quot;list-container&quot;&gt;<br>      &lt;div class=&quot;up-container&quot;&gt;<br>        &lt;div class=&quot;up-icon&quot;&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>      &lt;div class=&quot;selected-item&quot; v-for=&quot;item in 3&quot; :key=&quot;item&quot;&gt;<br>        &lt;div class=&quot;item-container&quot;&gt;<br>          &lt;div class=&quot;item-icon&quot;&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br>        &lt;div class=&quot;icon-delete&quot;&gt;&lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>  .selected-area &#123;<br>    position: absolute;<br>    top: 136px;<br>    right: -30px;<br>    width: 40px;<br>    height: fit-content;<br>    padding: 12px 0;<br>    background-color: rgba(50, 57, 71, 0.8);<br>    border-radius: 8px;<br>    cursor: pointer;<br>    display: flex;<br>    justify-content: center;<br>    align-items: center;<br>  &#125;<br>  .up-container&#123;<br>    margin-bottom: 8px;<br>    display: flex;<br>    justify-content: center;<br>  &#125;<br>  .up-icon&#123;<br>    width: 12px;<br>    height: 12px;<br>    background-image: url(&quot;../assets/images/ui/arrow-top.png&quot;);<br>    background-size: cover;<br>  &#125;<br>  .selected-item&#123;<br>    width: 40px;<br>    height: 40px;<br>    display: flex;<br>    justify-content: center;<br>    align-items: center;<br>    cursor: pointer;<br>    position: relative;<br>  &#125;<br>  .selected-item:hover .item-container&#123;<br>    border-color: #d3bc8e;<br>  &#125;<br>  .selected-item:hover .icon-delete&#123;<br>    display: block;<br>  &#125;<br>  .item-container&#123;<br>    width: 32px;<br>    height: 32px;<br>    display: flex;<br>    justify-content: center;<br>    align-items: center;<br>    border-radius: 4px;<br>    border: 1px solid hsla(0, 0%, 100%, 0.16);<br>    overflow: hidden;<br><br>  &#125;<br>  .icon-delete&#123;<br>    display: none;<br>    position: absolute;<br>    top: 0;<br>    right: 2px;<br>    width: 12px;<br>    height: 12px;<br>    background-repeat: no-repeat;<br>    background-position: 50%;<br>    background-size: 100%;<br>    background-image: url(&quot;../assets/images/ui/delete-icon.svg&quot;);<br>  &#125;<br>  .item-icon&#123;<br>    width: 100%;<br>    height: 100%;<br>    background-size: cover;<br>    background-image: url(&quot;../assets/images/ui/arrow-top.png&quot;);<br>  &#125;<br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241004232254.png"></p><p>接着编写交互逻辑<br>因为涉及到不同组件的数据交流，所以使用pinia进行管理</p><p>创建home.ts文件，对filterTree进行封装</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//src/stores/home.ts</span><br><span class="hljs-keyword">import</span> &#123;defineStore&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;pinia&quot;</span>;<br><span class="hljs-keyword">import</span> &#123;ref, watch&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useHomeStore = <span class="hljs-title function_">defineStore</span>(<span class="hljs-string">&#x27;home&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> filterTree = ref&lt;<span class="hljs-built_in">any</span>[]&gt;([])<br>    <span class="hljs-keyword">const</span> selectedFilterItems = ref&lt;<span class="hljs-built_in">any</span> []&gt;([])<br><br>    <span class="hljs-title function_">watch</span>(filterTree, <span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-title function_">calcSelectedFilterItems</span>()<br>    &#125;,&#123;<span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span>&#125;)<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">setFilterTree</span>(<span class="hljs-params"><span class="hljs-attr">data</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>        filterTree.<span class="hljs-property">value</span> = data<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">calcSelectedFilterItems</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">any</span>[] = []<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; filterTree.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>; i++)&#123;<br>            <span class="hljs-keyword">const</span> item = filterTree.<span class="hljs-property">value</span>[i]<br>            <span class="hljs-keyword">const</span> activeItems = item.<span class="hljs-property">children</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">child</span>: <span class="hljs-built_in">any</span></span>)=&gt;</span>&#123;<br>                <span class="hljs-keyword">return</span> child.<span class="hljs-property">active</span><br>            &#125;)<br>            res = res.<span class="hljs-title function_">concat</span>(activeItems)<br>        &#125;<br>        selectedFilterItems.<span class="hljs-property">value</span> = res<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(selectedFilterItems)<br>    &#125;<br>    <span class="hljs-keyword">return</span> &#123;<br>        filterTree,<br>        setFilterTree<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后在FilterMain.vue中更改filterTree的数据源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script&gt;<br>const &#123;filterTree&#125; = storeToRefs(store)<br>//...<br>async function init()&#123;<br>const res = await getMapFilterTree()<br>store.setFilterTree(res.data)<br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>打印验证程序正常后即可在SelectedArea.vue组件中引入。在实现左右组件联动之前可以先实现展开与关闭的逻辑<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241005001531.png"><br>效果展示：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/ezgif-3-f7b62ef013.webp"></p><p>继续实现数据渲染逻辑<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241005003227.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;selected-area&quot; v-if=&quot;selectedFilterItems.length &gt; 0&quot;&gt;<br>    &lt;div v-if=&quot;!expanded&quot; class=&quot;selected-count&quot;&gt;&#123;&#123; selectedFilterItems.length &#125;&#125;&lt;/div&gt;<br>    &lt;div v-if=&quot;!expanded&quot; class=&quot;selected-icon&quot; @click=&quot;onSelectedClick&quot;&gt;&lt;/div&gt;<br><br>    &lt;div v-else class=&quot;list-container&quot;&gt;<br>      &lt;div class=&quot;up-container&quot; @click=&quot;onSelectedClick&quot;&gt;<br>        &lt;div class=&quot;up-icon&quot;&gt;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>      &lt;div v-for=&quot;item in selectedFilterItems&quot; :key=&quot;item.id&quot; class=&quot;selected-item&quot; @click=&quot;onSelectedItemClick(item)&quot;&gt;<br>        &lt;div class=&quot;item-container&quot;&gt;<br>          &lt;div class=&quot;item-icon&quot; :style=&quot;&#123;<br>            backgroundImage: `url($&#123;item.icon&#125;)`<br>          &#125;&quot;&gt;&lt;/div&gt;<br>        &lt;/div&gt;<br>        &lt;div class=&quot;icon-delete&quot;&gt;&lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>最后注意删除选中项的逻辑为</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onSelectedItemClick</span>(<span class="hljs-params">item</span>)&#123;<br>  <span class="hljs-comment">//移除选中项的逻辑</span><br>  <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(item, <span class="hljs-string">&#x27;active&#x27;</span>, <span class="hljs-literal">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>效果展示：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/QQ2024105-03454-HD-ezgif.com-video-to-webp-converter%20(1).webp"></p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>Vue.js</tag>
      
      <tag>Typescript</tag>
      
      <tag>Vite</tag>
      
      <tag>Leaflet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原神大地图——1.绘制大地图</title>
    <link href="/2024/10/01/%E5%8E%9F%E7%A5%9E%E5%A4%A7%E5%9C%B0%E5%9B%BE%E2%80%94%E2%80%941-%E7%BB%98%E5%88%B6%E5%A4%A7%E5%9C%B0%E5%9B%BE/"/>
    <url>/2024/10/01/%E5%8E%9F%E7%A5%9E%E5%A4%A7%E5%9C%B0%E5%9B%BE%E2%80%94%E2%80%941-%E7%BB%98%E5%88%B6%E5%A4%A7%E5%9C%B0%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-快速使用leaflet"><a href="#1-快速使用leaflet" class="headerlink" title="1.快速使用leaflet"></a>1.快速使用leaflet</h1><p><a href="https://leafletjs.cn/examples/quick-start/">使用leaflet</a><br>a.新建地图<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001150407.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001150456.png"><br>b.在地图上绘制图形<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001150524.png"><br>c.使用提示信息<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001150603.png"><br>d.处理画布事件<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001150634.png"></p><h1 id="2-项目工程准备"><a href="#2-项目工程准备" class="headerlink" title="2.项目工程准备"></a>2.项目工程准备</h1><p>准备如下的目录结构<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001152756.png"><br>并安装好leaflet依赖，初始化leaflet画布</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> map = L.<span class="hljs-title function_">map</span>(<span class="hljs-string">&#x27;map&#x27;</span>, &#123;<br>        <span class="hljs-attr">center</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>],<br>        <span class="hljs-attr">crs</span>: L.<span class="hljs-property">CRS</span>.<span class="hljs-property">Simple</span>,<br>        <span class="hljs-attr">zoom</span>: <span class="hljs-number">5</span><br>    &#125;)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(map)<br>&#125;<br><br><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-title function_">init</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><p>然后将静态的瓦片资源放在public目录中,初始化瓦片地图,添加点击事件<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001155440.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001155257.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs vue"><br>&lt;script&gt;<br>  function init() &#123;<br>    let map = L.map(&#x27;map&#x27;, &#123;<br>      center: [0, 0],<br>      crs: L.CRS.Simple,<br>      zoom: 5<br>    &#125;)<br>    map.on(&#x27;click&#x27;, (workingLayer) =&gt; &#123;<br>      const coordinate = workingLayer.latlng<br>      console.log(coordinate)<br>    &#125;)<br>    L.tileLayer(&#x27;images/map/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&#x27;, &#123;<br>      maxZoom: 7,<br>    &#125;).addTo(map);<br>  &#125;<br><br>  onMounted(() =&gt; &#123;<br>    init()<br>  &#125;)<br><br>&lt;/script&gt;<br><br>&lt;template&gt;<br>  &lt;div id=&quot;map-container&quot;&gt;<br>    &lt;div id=&quot;map&quot;&gt;<br><br>    &lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;style scoped&gt;<br>  #map-container &#123;<br>    height: 100vh;<br>    width: 100vw;<br>    position: relative;<br>  &#125;<br><br>  #map &#123;<br>    position: absolute;<br>    height: 100%;<br>    width: 100%;<br>  &#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h1 id="3-实现控制"><a href="#3-实现控制" class="headerlink" title="3.实现控制"></a>3.实现控制</h1><p>地图初始化完成后需要优化现有逻辑，比如地图拖拽范围太大，以及缩放太大。翻阅官方文档可知配置Map函数中的option即可<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001155826.png"><br>所以配置map option</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> bounds = L.<span class="hljs-title function_">latLngBounds</span>(L.<span class="hljs-title function_">latLng</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), L.<span class="hljs-title function_">latLng</span>(-<span class="hljs-number">256</span>, <span class="hljs-number">256</span>))<br><span class="hljs-keyword">let</span> map = L.<span class="hljs-title function_">map</span>(<span class="hljs-string">&#x27;map&#x27;</span>, &#123;<br>    <span class="hljs-attr">maxBounds</span>: bounds,<br>    <span class="hljs-attr">center</span>: [-<span class="hljs-number">102</span>, <span class="hljs-number">148</span>],<br>    <span class="hljs-attr">crs</span>: L.<span class="hljs-property">CRS</span>.<span class="hljs-property">Simple</span>,<br>    <span class="hljs-attr">zoomControl</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">attributionControl</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">zoom</span>: <span class="hljs-number">5</span>,<br>    <span class="hljs-attr">minZoom</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-attr">maxZoom</span>: <span class="hljs-number">7</span><br>&#125;)<br>map.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">workingLayer</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> coordinate = workingLayer.<span class="hljs-property">latlng</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(coordinate)<br>&#125;)<br>L.<span class="hljs-title function_">tileLayer</span>(<span class="hljs-string">&#x27;images/map/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&#x27;</span>, &#123;<br>    bounds,<br>    <span class="hljs-attr">maxZoom</span>: <span class="hljs-number">7</span>,<br>&#125;).<span class="hljs-title function_">addTo</span>(map);<br></code></pre></td></tr></table></figure><p>最终效果：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001160819.png"></p><h1 id="5-在大地图中展示地名"><a href="#5-在大地图中展示地名" class="headerlink" title="5.在大地图中展示地名"></a>5.在大地图中展示地名</h1><p>在地图中展示地名可用maker方法<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001161038.png"><br>并且注意到maker方法中可以使用divIcon,所以我们可以创建divIcon<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001161435.png"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript">  L.<span class="hljs-title function_">marker</span>(L.<span class="hljs-title function_">latLng</span>([-<span class="hljs-number">99.96875</span>, <span class="hljs-number">125.769</span>]), &#123;<br>    <span class="hljs-attr">icon</span>: L.<span class="hljs-title function_">divIcon</span>(&#123;<br>        <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;map-marker-item&#x27;</span>,<br>        <span class="hljs-attr">html</span>: <span class="hljs-string">`&lt;div class=&quot;area-mark-item&quot;&gt;碧水源&lt;/div&gt;`</span><br>    &#125;)<br>&#125;).<span class="hljs-title function_">addTo</span>(map)<br></code></pre></td></tr></table></figure><p>注意在scope上加样式穿透，相关的RFC可以参考<a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0023-scoped-styles-changes.md">scoped-styles-changes</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">:deep(.area-mark-item)&#123;<br>font-size: 18px;<br>color: #fff;<br>font-weight: bold;<br>text-shadow: 0 0 3px #333;<br>white-space: nowrap;<br>&#125;<br></code></pre></td></tr></table></figure><p>刷新即可看见效果<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001162932.png"><br>增加完一个地名证实效果后就可以批量生成地名了。添加一个markerList用于保存地名信息，使用<a href="https://leafletjs.cn/reference.html#layergroup">LayerGroup</a><br>管理marker</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs typescript">  <span class="hljs-keyword">const</span> markerList = [&#123;<br>    <span class="hljs-attr">lat</span>: -<span class="hljs-number">99.96875</span>,<br>    <span class="hljs-attr">lng</span>: <span class="hljs-number">125.71875</span>,<br>    <span class="hljs-attr">areaName</span>: <span class="hljs-string">&#x27;碧水原&#x27;</span><br>&#125;, &#123;<br>    <span class="hljs-attr">lat</span>: -<span class="hljs-number">88.125</span>,<br>    <span class="hljs-attr">lng</span>: <span class="hljs-number">139.40625</span>,<br>    <span class="hljs-attr">areaName</span>: <span class="hljs-string">&#x27;苍风高地&#x27;</span><br>&#125;]<br><br><span class="hljs-keyword">let</span> markers = markerList.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123;lat, lng, areaName&#125; = item<br>    <span class="hljs-keyword">const</span> marker = L.<span class="hljs-title function_">marker</span>(L.<span class="hljs-title function_">latLng</span>([lat, lng,]), &#123;<br>        <span class="hljs-attr">icon</span>: L.<span class="hljs-title function_">divIcon</span>(&#123;<br>            <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;map-marker-item&#x27;</span>,<br>            <span class="hljs-attr">html</span>: <span class="hljs-string">`&lt;div class=&quot;area-mark-item&quot;&gt;<span class="hljs-subst">$&#123;areaName&#125;</span>&lt;/div&gt;`</span><br>        &#125;)<br>    &#125;)<br>    <span class="hljs-keyword">return</span> marker<br>&#125;)<br><br><span class="hljs-keyword">let</span> areaNameLayerGroup = L.<span class="hljs-title function_">layerGroup</span>(markers)<br>areaNameLayerGroup.<span class="hljs-title function_">addTo</span>(map)<br></code></pre></td></tr></table></figure><p>刷新即可看见效果<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001163948.png"></p><h1 id="6-在大地图中添加标点"><a href="#6-在大地图中添加标点" class="headerlink" title="6.在大地图中添加标点"></a>6.在大地图中添加标点</h1><p>效果展示：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20241001195630.png"><br>添加标点的实现与添加地名类似，都是在地图上添加marker<br>首先创建管理数据的<code>pointMarkerList</code></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> pointMarkerList = [&#123;<br>    <span class="hljs-attr">lat</span>: -<span class="hljs-number">90.5625</span>,<br>    <span class="hljs-attr">lng</span>: <span class="hljs-number">144.65625</span>,<br>    <span class="hljs-attr">iconId</span>: <span class="hljs-number">1</span><br>&#125;,<br>    &#123;<br>        <span class="hljs-attr">lat</span>: -<span class="hljs-number">99.53125</span>,<br>        <span class="hljs-attr">lng</span>: <span class="hljs-number">131.65625</span>,<br>        <span class="hljs-attr">iconId</span>: <span class="hljs-number">1</span><br>    &#125;]<br></code></pre></td></tr></table></figure><p>然后动态生成标点</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> pointerMarkers = pointMarkerList.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> &#123;lat, lng, iconId&#125; = item<br>    <span class="hljs-keyword">let</span> iconUrl = <span class="hljs-string">`images/map-icon/<span class="hljs-subst">$&#123;iconId&#125;</span>.png`</span><br><br>    <span class="hljs-keyword">const</span> marker = L.<span class="hljs-title function_">marker</span>(L.<span class="hljs-title function_">latLng</span>([lat, lng,]), &#123;<br>        <span class="hljs-attr">icon</span>: L.<span class="hljs-title function_">divIcon</span>(&#123;<br>            <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;map-pointer-item&#x27;</span>,<br>            <span class="hljs-attr">html</span>: <span class="hljs-string">`</span><br><span class="hljs-string">        &lt;div class=&quot;point-item-container&quot;&gt;</span><br><span class="hljs-string">            &lt;div class=&quot;point-pic&quot; style=&quot;background-image: url(<span class="hljs-subst">$&#123;iconUrl&#125;</span>);&quot;&gt;</span><br><span class="hljs-string">            &lt;/div&gt;</span><br><span class="hljs-string">        &lt;/div&gt;`</span><br>        &#125;)<br>    &#125;)<br>    <span class="hljs-keyword">let</span> pointerMarkersLayerGroup = L.<span class="hljs-title function_">layerGroup</span>(pointerMarkers)<br>    pointerMarkersLayerGroup.<span class="hljs-title function_">addTo</span>(map)<br></code></pre></td></tr></table></figure><p>设置标点样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs vue">:deep(.point-item-container) &#123;<br>  width: 37px;<br>  height: 40px;<br>  background-size: cover;<br>  background-image: url(&quot;../assets/images/map/icon-bg.png&quot;);<br>  display: flex;<br>  justify-content: center;<br>  align-items: center;<br>&#125;<br><br>:deep(.point-pic) &#123;<br>  width: 29px;<br>  height: 29px;<br>  background-size: cover;<br>  margin-bottom: 8px;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-代码封装与重构"><a href="#7-代码封装与重构" class="headerlink" title="7.代码封装与重构"></a>7.代码封装与重构</h1><p>到目前位置已经初步实现了地图的展示，完成测试后需要及时重构。重构思路为抽离地图创建，地名显示，地标显示<br>首先抽离地图创建模块，建立map-manager.ts文件并新建MapManager class</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapManager</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-attr">map</span>: L.<span class="hljs-property">Map</span><br>    <span class="hljs-comment">//private areaNameLayerGroup: L.LayerGroup | undefined</span><br>    <span class="hljs-comment">//private pointerMarkersLayerGroup: L.LayerGroup | undefined</span><br><br><span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">domID</span>:<span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">const</span> bounds = L.<span class="hljs-title function_">latLngBounds</span>(L.<span class="hljs-title function_">latLng</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), L.<span class="hljs-title function_">latLng</span>(-<span class="hljs-number">256</span>, <span class="hljs-number">256</span>))<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span> = L.<span class="hljs-title function_">map</span>(domID, &#123;<br>        <span class="hljs-attr">maxBounds</span>: bounds,<br>        <span class="hljs-attr">center</span>: [-<span class="hljs-number">102</span>, <span class="hljs-number">148</span>],<br>        <span class="hljs-attr">crs</span>: L.<span class="hljs-property">CRS</span>.<span class="hljs-property">Simple</span>,<br>        <span class="hljs-attr">zoomControl</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">attributionControl</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">zoom</span>: <span class="hljs-number">5</span>,<br>        <span class="hljs-attr">minZoom</span>: <span class="hljs-number">4</span>,<br>        <span class="hljs-attr">maxZoom</span>: <span class="hljs-number">7</span><br>    &#125;)<br><br>    L.<span class="hljs-title function_">tileLayer</span>(<span class="hljs-string">&#x27;images/map/&#123;z&#125;/&#123;x&#125;/&#123;y&#125;.png&#x27;</span>, &#123;<br>        bounds,<br>        <span class="hljs-attr">maxZoom</span>: <span class="hljs-number">7</span>,<br>    &#125;).<span class="hljs-title function_">addTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>);<br>&#125;&#125;<br></code></pre></td></tr></table></figure><p>然后添加renderAreaNames、renderPoints</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title function_">renderAreaNames</span>(<span class="hljs-params"><span class="hljs-attr">configList</span>: <span class="hljs-title class_">AreaNameConfig</span>[]</span>) &#123;<br><br>    <span class="hljs-keyword">const</span> markers = configList.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> &#123;lat, lng, areaName&#125; = item<br>        <span class="hljs-keyword">const</span> marker = L.<span class="hljs-title function_">marker</span>(L.<span class="hljs-title function_">latLng</span>([lat, lng,]), &#123;<br>            <span class="hljs-attr">icon</span>: L.<span class="hljs-title function_">divIcon</span>(&#123;<br>                <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;map-marker-item&#x27;</span>,<br>                <span class="hljs-attr">html</span>: <span class="hljs-string">`&lt;div class=&quot;area-mark-item&quot;&gt;<span class="hljs-subst">$&#123;areaName&#125;</span>&lt;/div&gt;`</span><br>            &#125;)<br>        &#125;)<br>        <span class="hljs-keyword">return</span> marker<br>    &#125;)<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">areaNameLayerGroup</span> = L.<span class="hljs-title function_">layerGroup</span>(markers)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">areaNameLayerGroup</span>.<span class="hljs-title function_">addTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>)<br>&#125;,<br><br><span class="hljs-title function_">renderPoints</span>(<span class="hljs-params"><span class="hljs-attr">pointList</span>: <span class="hljs-title class_">PointConfig</span>[]</span>)&#123;<br>    <span class="hljs-keyword">const</span> pointerMarkers = pointList.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> &#123;lat, lng, iconId&#125; = item<br>        <span class="hljs-keyword">let</span> iconUrl = <span class="hljs-string">`images/map-icon/<span class="hljs-subst">$&#123;iconId&#125;</span>.png`</span><br><br>        <span class="hljs-keyword">const</span> marker = L.<span class="hljs-title function_">marker</span>(L.<span class="hljs-title function_">latLng</span>([lat, lng,]), &#123;<br>            <span class="hljs-attr">icon</span>: L.<span class="hljs-title function_">divIcon</span>(&#123;<br>                <span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;map-pointer-item&#x27;</span>,<br>                <span class="hljs-attr">html</span>: <span class="hljs-string">`</span><br><span class="hljs-string">              &lt;div class=&quot;point-item-container&quot;&gt;</span><br><span class="hljs-string">                  &lt;div class=&quot;point-pic&quot; style=&quot;background-image: url(<span class="hljs-subst">$&#123;iconUrl&#125;</span>);&quot;&gt;</span><br><span class="hljs-string">                  &lt;/div&gt;</span><br><span class="hljs-string">              &lt;/div&gt;`</span><br>            &#125;)<br>        &#125;)<br><br>        <span class="hljs-keyword">return</span> marker<br>    &#125;)<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointerMarkersLayerGroup</span> = L.<span class="hljs-title function_">layerGroup</span>(pointerMarkers)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">pointerMarkersLayerGroup</span>.<span class="hljs-title function_">addTo</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">map</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>最后在Home.vue中调用manager</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript">  <span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MapManager</span>(<span class="hljs-string">&#x27;map&#x27;</span>)<br><span class="hljs-keyword">const</span> markerList = [&#123;<br>    <span class="hljs-attr">lat</span>: -<span class="hljs-number">99.96875</span>,<br>    <span class="hljs-attr">lng</span>: <span class="hljs-number">125.71875</span>,<br>    <span class="hljs-attr">areaName</span>: <span class="hljs-string">&#x27;碧水原&#x27;</span><br>&#125;, &#123;<br>    <span class="hljs-attr">lat</span>: -<span class="hljs-number">88.125</span>,<br>    <span class="hljs-attr">lng</span>: <span class="hljs-number">139.40625</span>,<br>    <span class="hljs-attr">areaName</span>: <span class="hljs-string">&#x27;苍风高地&#x27;</span><br>&#125;]<br><br>map.<span class="hljs-title function_">renderAreaNames</span>(markerList)<br><br><span class="hljs-keyword">const</span> pointMarkerList = [&#123;<br>    <span class="hljs-attr">lat</span>: -<span class="hljs-number">90.5625</span>,<br>    <span class="hljs-attr">lng</span>: <span class="hljs-number">144.65625</span>,<br>    <span class="hljs-attr">iconId</span>: <span class="hljs-number">1</span><br>&#125;,<br>    &#123;<br>        <span class="hljs-attr">lat</span>: -<span class="hljs-number">99.53125</span>,<br>        <span class="hljs-attr">lng</span>: <span class="hljs-number">131.65625</span>,<br>        <span class="hljs-attr">iconId</span>: <span class="hljs-number">1</span><br>    &#125;]<br><br>map.<span class="hljs-title function_">renderPoints</span>(pointMarkerList)<br><br>map.<span class="hljs-title function_">enableClickDebug</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>Vue.js</tag>
      
      <tag>Typescript</tag>
      
      <tag>Vite</tag>
      
      <tag>Leaflet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书管理后台开发项目-8.菜单权限新增编辑API开发</title>
    <link href="/2024/09/29/%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-8-%E8%8F%9C%E5%8D%95%E6%9D%83%E9%99%90%E6%96%B0%E5%A2%9E%E7%BC%96%E8%BE%91API%E5%BC%80%E5%8F%91/"/>
    <url>/2024/09/29/%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-8-%E8%8F%9C%E5%8D%95%E6%9D%83%E9%99%90%E6%96%B0%E5%A2%9E%E7%BC%96%E8%BE%91API%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="新增菜单功能前端开发"><a href="#新增菜单功能前端开发" class="headerlink" title="新增菜单功能前端开发"></a>新增菜单功能前端开发</h1><p>开发此处页面：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240929144155.png"><br>阅读代码发现页面由 formSchema 变量动态生成,于是将其改造为如下数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs typescript"> <span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">formSchema</span>: <span class="hljs-title class_">FormSchema</span>[] = [&#123;<br>    <span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;path&#x27;</span>,<br>    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;菜单路径&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;Input&#x27;</span>,<br>    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>&#125;,<br>    &#123;<br>        <span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;menuName&#x27;</span>,<br>        <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;菜单名称&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;Input&#x27;</span>,<br>        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;redirect&#x27;</span>,<br>        <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;重定向&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;Input&#x27;</span>,<br>        <span class="hljs-attr">required</span>: <span class="hljs-literal">false</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;meta&#x27;</span>,<br>        <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;元数据&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;Input&#x27;</span>,<br>        <span class="hljs-attr">required</span>: <span class="hljs-literal">false</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;parentMenu&#x27;</span>,<br>        <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;上级菜单&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;TreeSelect&#x27;</span>,<br>        <span class="hljs-attr">componentProps</span>: &#123;<br>            <span class="hljs-attr">fieldNames</span>: &#123;<br>                <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;name&#x27;</span>,<br>                <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;id&#x27;</span>,<br>            &#125;,<br>            <span class="hljs-attr">getPopupContainer</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>,<br>        &#125;,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;status&#x27;</span>,<br>        <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;状态&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;RadioButtonGroup&#x27;</span>,<br>        <span class="hljs-attr">defaultValue</span>: <span class="hljs-string">&#x27;1&#x27;</span>,<br>        <span class="hljs-attr">componentProps</span>: &#123;<br>            <span class="hljs-attr">options</span>: [<br>                &#123;<span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;启用&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>                &#123;<span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;禁用&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;0&#x27;</span>&#125;,<br>            ],<br>        &#125;,<br>    &#125;, &#123;<br>        <span class="hljs-attr">field</span>: <span class="hljs-string">&#x27;show&#x27;</span>,<br>        <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;是否显示&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-string">&#x27;RadioButtonGroup&#x27;</span>,<br>        <span class="hljs-attr">defaultValue</span>: <span class="hljs-string">&#x27;0&#x27;</span>,<br>        <span class="hljs-attr">componentProps</span>: &#123;<br>            <span class="hljs-attr">options</span>: [<br>                &#123;<span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;是&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;0&#x27;</span>&#125;,<br>                &#123;<span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;否&#x27;</span>, <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;,<br>            ],<br>        &#125;,<br>        <span class="hljs-attr">ifShow</span>: <span class="hljs-function">(<span class="hljs-params">&#123;values&#125;</span>) =&gt;</span> !<span class="hljs-title function_">isButton</span>(values.<span class="hljs-property">type</span>),<br>    &#125;,]<br></code></pre></td></tr></table></figure><p>点击新增菜单填入数据并点击确认后即可在控制台看见新增菜单的数据<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240929145835.png"><br>翻阅代码可在handleSubmit处找到调用新增菜单的Api。<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240929150250.png"><br>接着在后端进行开发新建菜单接口<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240929171413.png"><br>在前端handleSubmit处给新增的菜单添加pid<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240930185432.png"><br>然后配置前端请求接口<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240930190734.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240930190827.png"></p><h2 id="update-menu开发"><a href="#update-menu开发" class="headerlink" title="update menu开发"></a>update menu开发</h2><p>编写nest.js后端接口<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240930192300.png"><br>测试接口：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240930192321.png"></p><p>配置好前端表单字段：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240930195459.png"><br>在打开抽屉时做判断决定<br>执行更新菜单还是新增菜单<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240930195551.png"></p><h2 id="修复禁用启用状态显示异常"><a href="#修复禁用启用状态显示异常" class="headerlink" title="修复禁用启用状态显示异常"></a>修复禁用启用状态显示异常</h2><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240930195752.png"><br>注意字段值的类型：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240930195829.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240930195904.png"><br>除此之外还有一个BUG：可以直接禁用一级菜单。如果直接禁用顶级菜单则会导致页面出错所以需要优化禁用逻辑</p><h2 id="优化菜单禁用逻辑"><a href="#优化菜单禁用逻辑" class="headerlink" title="优化菜单禁用逻辑"></a>优化菜单禁用逻辑</h2><p>只有在所有子菜单都被禁用，父菜单才能禁用<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240930202757.png"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">if</span>(<span class="hljs-title function_">checkAllChildrenMenuDisabled</span>(values))&#123;<br>  <span class="hljs-keyword">await</span> <span class="hljs-title function_">updateMenu</span>(&#123; <span class="hljs-attr">data</span>: values &#125;);<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>  createMessage.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请禁用所有子菜单后，再禁用主菜单&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="修复编辑菜单时父菜单丢失"><a href="#修复编辑菜单时父菜单丢失" class="headerlink" title="修复编辑菜单时父菜单丢失"></a>修复编辑菜单时父菜单丢失</h2><p>再menu&#x2F;index.vue下的handleEdit中将pid与parentMenu做映射即可</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleEdit</span>(<span class="hljs-params"><span class="hljs-attr">record</span>: <span class="hljs-title class_">Recordable</span></span>) &#123;<br>  record.<span class="hljs-property">parentMenu</span> = record.<span class="hljs-property">pid</span><br>  <span class="hljs-title function_">openDrawer</span>(<span class="hljs-literal">true</span>, &#123;<br>    record,<br>    <span class="hljs-attr">isUpdate</span>: <span class="hljs-literal">true</span>,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>Vue.js</tag>
      
      <tag>Typescript</tag>
      
      <tag>Vite</tag>
      
      <tag>Nest.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书管理后台开发项目-7.菜单权限页面开发</title>
    <link href="/2024/09/26/%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-7-%E8%8F%9C%E5%8D%95%E6%9D%83%E9%99%90%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    <url>/2024/09/26/%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-7-%E8%8F%9C%E5%8D%95%E6%9D%83%E9%99%90%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="前端组件配置"><a href="#前端组件配置" class="headerlink" title="前端组件配置"></a>前端组件配置</h1><p>将vben中的权限管理路由添加至后端目录的data文件中，再在前端的views&#x2F;system&#x2F;permission中添加菜单管理组件（vben中已经封装好了，可以直接复制）<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240927153409.png"></p><p>然后在routes&#x2F;modules&#x2F;demo&#x2F;permission.ts中添加路由配置，并关联对应名称的组件<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240927153916.png"><br>最后记得配置i18n的国际化语言库</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs typescript">&#123;<br>    <span class="hljs-string">&quot;path&quot;</span><br>:<br>    <span class="hljs-string">&quot;/permission&quot;</span>,<br>        <span class="hljs-string">&quot;name&quot;</span><br>:<br>    <span class="hljs-string">&quot;Permission&quot;</span>,<br>        <span class="hljs-string">&quot;redirect&quot;</span><br>:<br>    <span class="hljs-string">&quot;/permission/menu&quot;</span>,<br>        <span class="hljs-string">&quot;meta&quot;</span><br>:<br>    &#123;<br>        <span class="hljs-string">&quot;orderNo&quot;</span><br>    :<br>        <span class="hljs-number">15</span>,<br>            <span class="hljs-string">&quot;icon&quot;</span><br>    :<br>        <span class="hljs-string">&quot;ion:key-outline&quot;</span>,<br>            <span class="hljs-string">&quot;title&quot;</span><br>    :<br>        <span class="hljs-string">&quot;routes.demo.permission.permission&quot;</span><br>    &#125;<br>,<br>    <span class="hljs-string">&quot;children&quot;</span><br>:<br>    [<br>        &#123;<br>            <span class="hljs-string">&quot;path&quot;</span>: <span class="hljs-string">&quot;menu&quot;</span>,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;PermissionMenu&quot;</span>,<br>            <span class="hljs-string">&quot;meta&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;routes.demo.permission.menu&quot;</span><br>            &#125;<br>        &#125;<br>    ]<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="后端利用ORM框架同步建表"><a href="#后端利用ORM框架同步建表" class="headerlink" title="后端利用ORM框架同步建表"></a>后端利用ORM框架同步建表</h1><p>开启AppModule中Typeorm的<code>synchronize: true</code>，在menu模块下配置menu实体，以及在module中导入menu实体</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Column</span>, <span class="hljs-title class_">Entity</span>, <span class="hljs-title class_">PrimaryGeneratedColumn</span>, <span class="hljs-title class_">Unique</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;typeorm&#x27;</span>;<br><br><span class="hljs-meta">@Entity</span>(<span class="hljs-string">&#x27;admin_menu&#x27;</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Menu</span> &#123;<br>    <span class="hljs-meta">@Column</span>()<br>    <span class="hljs-meta">@PrimaryGeneratedColumn</span>()<br>    <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br><br>    <span class="hljs-meta">@Column</span>()<br>    <span class="hljs-attr">path</span>: <span class="hljs-built_in">string</span>;<br><br>    <span class="hljs-meta">@Column</span>()<br>    <span class="hljs-meta">@Unique</span>([<span class="hljs-string">&#x27;name&#x27;</span>])<br>    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;<br><br>    <span class="hljs-meta">@Column</span>()<br>    <span class="hljs-attr">redirect</span>: <span class="hljs-built_in">string</span>;<br><br>    <span class="hljs-meta">@Column</span>()<br>    <span class="hljs-attr">meta</span>: <span class="hljs-built_in">string</span>;<br><br>    <span class="hljs-meta">@Column</span>()<br>    <span class="hljs-attr">pid</span>: <span class="hljs-built_in">number</span>;<br><br>    <span class="hljs-comment">//1 - 可用， 0 - 不可用</span><br>    <span class="hljs-meta">@Column</span>()<br>    <span class="hljs-attr">active</span>: <span class="hljs-built_in">number</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动Nest后即可在数据库中看见menu表<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240927154905.png"><br>配置menu的service与controller<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240928143540.png"><br>改造MENU_LIST后需要在前端进行兼容<br>编写converMenuTree对从后端传来的数据进行转换</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs typescript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">convertMenuTree</span> = (<span class="hljs-params">menuList</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> menus = [];<br>    menuList.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">menu</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (menu.<span class="hljs-property">meta</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                menu.<span class="hljs-property">meta</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(menu.<span class="hljs-property">meta</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (menu.<span class="hljs-property">pid</span> === <span class="hljs-number">0</span>) &#123;<br>            menus.<span class="hljs-title function_">push</span>(menu);<br>            <span class="hljs-keyword">if</span> (!menu.<span class="hljs-property">children</span>) &#123;<br>                menu.<span class="hljs-property">children</span> = [];<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">const</span> parentMenu = menuList.<span class="hljs-title function_">find</span>(<span class="hljs-function">(<span class="hljs-params">m</span>) =&gt;</span> m.<span class="hljs-property">id</span> === menu.<span class="hljs-property">pid</span>);<br>            <span class="hljs-keyword">if</span> (!parentMenu.<span class="hljs-property">children</span>) &#123;<br>                parentMenu.<span class="hljs-property">children</span> = [];<br>            &#125;<br>            parentMenu.<span class="hljs-property">children</span>.<span class="hljs-title function_">push</span>(menu);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">return</span> menus;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">getAllMenuData</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">getAllMenus</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">menu_</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// console.log(menu_);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">convertMenuTree</span>(menu_);<br>    &#125;);<br>&#125;;<br><span class="hljs-keyword">let</span> backendRouteList;<br></code></pre></td></tr></table></figure><p>最后调用其他的路由处理函数<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240928151255.png"></p><h1 id="前端菜单页面管理开发"><a href="#前端菜单页面管理开发" class="headerlink" title="前端菜单页面管理开发"></a>前端菜单页面管理开发</h1><p>完成了路由的后端下发并在前端展示功能后开始开发菜单管理页面</p><h2 id="1-菜单列表查询和渲染"><a href="#1-菜单列表查询和渲染" class="headerlink" title="1.菜单列表查询和渲染"></a>1.菜单列表查询和渲染</h2><p>在@&#x2F;views&#x2F;demo&#x2F;system&#x2F;permission&#x2F;index.vue下即为要开发的菜单页面组件</p><p>首先改动的第一个点为菜单接口查询方式，如图所示<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240928152700.png"></p><p>更改Api文件下的查询目录地址为&#x2F;menu<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240928153235.png"><br>更改从成功后菜单数据结构并不符合现成的组件，所以需要进一步做兼容处理<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240928153409.png"><br>分析源码可知维护菜单Table的关键数据在menu.data中<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240928153602.png"><br>配置菜单列</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-attr">columns</span>: <span class="hljs-title class_">BasicColumn</span>[] = [<br>    &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;菜单id&#x27;</span>,<br>        <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;id&#x27;</span>,<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">80</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;父菜单ID&#x27;</span>,<br>        <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;pid&#x27;</span>,<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">80</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;菜单路径&#x27;</span>,<br>        <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;path&#x27;</span>,<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">180</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;菜单名称&#x27;</span>,<br>        <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;menuName&#x27;</span>,<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,<br>        <span class="hljs-attr">align</span>: <span class="hljs-string">&#x27;left&#x27;</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;重定向&#x27;</span>,<br>        <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;redirect&#x27;</span>,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;元数据&#x27;</span>,<br>        <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;meta&#x27;</span>,<br>        <span class="hljs-attr">customRender</span>: <span class="hljs-function">(<span class="hljs-params">&#123; text &#125;</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">Tooltip</span>, &#123; <span class="hljs-attr">title</span>: text, <span class="hljs-attr">placement</span>: <span class="hljs-string">&#x27;top&#x27;</span> &#125;, <span class="hljs-function">() =&gt;</span> text.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>) + <span class="hljs-string">&#x27;...&#x27;</span>);<br>        &#125;,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;状态&#x27;</span>,<br>        <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;status&#x27;</span>,<br>        <span class="hljs-attr">width</span>: <span class="hljs-number">80</span>,<br>        <span class="hljs-attr">customRender</span>: <span class="hljs-function">(<span class="hljs-params">&#123; record &#125;</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">const</span> status = record.<span class="hljs-property">active</span> === <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">const</span> enable = ~~status === <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">const</span> color = enable ? <span class="hljs-string">&#x27;green&#x27;</span> : <span class="hljs-string">&#x27;red&#x27;</span>;<br>            <span class="hljs-keyword">const</span> text = enable ? <span class="hljs-string">&#x27;启用&#x27;</span> : <span class="hljs-string">&#x27;停用&#x27;</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-title class_">Tag</span>, &#123; <span class="hljs-attr">color</span>: color &#125;, <span class="hljs-function">() =&gt;</span> text);<br>        &#125;,<br>    &#125;,<br>];<br><br></code></pre></td></tr></table></figure><p>注意meta列中使用到了customRender<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240928155758.png"></p><blockquote><p>注意，findAllmenu根据字面意思，后端服务就不能在查询数据库的时候添加where条件了<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240928154002.png"></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>Vue.js</tag>
      
      <tag>Typescript</tag>
      
      <tag>Vite</tag>
      
      <tag>Nest.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书管理后台开发项目-6.管理后台前端权限</title>
    <link href="/2024/09/25/%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-6-%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF%E6%9D%83%E9%99%90/"/>
    <url>/2024/09/25/%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-6-%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%89%8D%E7%AB%AF%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<p>前端的权限管理通常是左侧菜单部分的展示权限，以及基于功能的权限<br>vben实际上是动态生成了路由，然后再展示在左边的菜单栏，所以要编写权限相关的代码可以从动态生成路由处着手<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240925205325.png"></p><h1 id="buildRoutesAction方法分析"><a href="#buildRoutesAction方法分析" class="headerlink" title="buildRoutesAction方法分析"></a>buildRoutesAction方法分析</h1><blockquote><p>vben通过动态生成路由，控制菜单栏展示权限。核心方法是buildRoutesAction，该方法根据路由的meta.role属性过滤路由，从而生成不同角色的菜单。<br>搜索这个方法的签名可以发现被多个地方调用<br>此外，该方法还将多级路由简化为两级路由。</p></blockquote><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240925205456.png"><br>通过调试路由生成过程可以发现方法会检查路由下的meta.role属性来过滤路由，最后生成菜单<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240925210124.png"><br>并且还对路由进行了操作，将多级路由转为两级路由</p><p><del>首先我们获取角色信息，在user.ts下的getUserInfoAction中vben已经撰写好了用户信息的获取逻辑。我们从这里开始编写代码。<br>1.将roles改为role</del></p><h1 id="后端动态生成前端菜单方案"><a href="#后端动态生成前端菜单方案" class="headerlink" title="后端动态生成前端菜单方案"></a>后端动态生成前端菜单方案</h1><blockquote><p>由于前端路由列表中的component字段无法直接转换为JSON并传递给后端，我们需要在router&#x2F;route-map.ts中映射路由与组件的关系。</p></blockquote><p>如果把前端的routeList直接转换成JSON，由后端来下发数据会有一个component字段丢失的问题。所以我们可以在router下建立一个route-map.ts文件用于映射路由与组件的关系</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-variable constant_">EXCEPTION_COMPONENT</span>, <span class="hljs-variable constant_">LAYOUT</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/router/constant&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ROUTE_MAP</span> = &#123;<br>  <span class="hljs-title class_">Dashboard</span>: <span class="hljs-variable constant_">LAYOUT</span>,<br>  <span class="hljs-title class_">Analysis</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/dashboard/analysis/index.vue&#x27;</span>),<br>  <span class="hljs-title class_">Workbench</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/views/dashboard/workbench/index.vue&#x27;</span>),<br>  <span class="hljs-attr">NOT_FOUND</span>: <span class="hljs-variable constant_">EXCEPTION_COMPONENT</span>,<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>在user.ts文件中兼容数据库角色字段的逻辑<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240926194648.png"></p><blockquote><p>接下来，通过硬编码的方式配置路由，并使用wrapperRouteComponent函数，将路由的name与组件关联。parseRouteRoles函数则解析roles字段，将其转为数组。</p></blockquote><p>用硬编码的方式写入路由配置，通过wrapperRouteComponent函数将路由配置中的name属性与route-map中的component属性关联起来。并通过parseRouteRoles函数将roles字段文本转数组</p><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240926194818.png"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">wrapperRouteComponent</span> = (<span class="hljs-params">routes</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> routes.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (route.<span class="hljs-property">children</span> &amp;&amp; route.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            route.<span class="hljs-property">children</span> = <span class="hljs-title function_">wrapperRouteComponent</span>(route.<span class="hljs-property">children</span>);<br>        &#125;<br>        route.<span class="hljs-property">component</span> = <span class="hljs-variable constant_">ROUTE_MAP</span>[route.<span class="hljs-property">name</span>] || <span class="hljs-variable constant_">ROUTE_MAP</span>.<span class="hljs-property">NOT_FOUND</span>;<br>        <span class="hljs-keyword">return</span> route;<br>    &#125;);<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">parseRouteRoles</span> = (<span class="hljs-params">routes</span>) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> routes.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">route</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (route.<span class="hljs-property">children</span> &amp;&amp; route.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            route.<span class="hljs-property">children</span> = <span class="hljs-title function_">parseRouteRoles</span>(route.<span class="hljs-property">children</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (route?.<span class="hljs-property">meta</span>?.<span class="hljs-property">roles</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                route.<span class="hljs-property">meta</span>.<span class="hljs-property">roles</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(route.<span class="hljs-property">meta</span>.<span class="hljs-property">roles</span>)<br>            &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(e)<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> route;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>对于PAGE_NOT_FOUND这类父路由名与子路由名相同的情况，我们可以通过addPageNotFoundAtFirst函数特殊处理：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240926200838.png"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">addPageNotFoundAtFirst</span> = (<span class="hljs-params">routes</span>) =&gt; &#123;<br>    routes.<span class="hljs-title function_">unshift</span>(<span class="hljs-variable constant_">PAGE_NOT_FOUND_ROUTE</span>);<br>    <span class="hljs-keyword">return</span> routes;<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="优化：使用现有的路由映射"><a href="#优化：使用现有的路由映射" class="headerlink" title="优化：使用现有的路由映射"></a>优化：使用现有的路由映射</h1><p>手动添加路由与组件的映射关系会很繁琐。为简化操作，我们可以利用asyncRoutes变量，该变量已经包含了完整的路由和组件映射信息。通过遍历asyncRoutes，我们可以自动生成ROUTE_MAP。<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240926201257.png"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123;asyncRoutes&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@/router/routes&quot;</span>;<br><br><span class="hljs-comment">// export const ROUTE_MAP = &#123;</span><br><span class="hljs-comment">//   PageNotFound: () =&gt; import(&#x27;@/views/sys/exception/Exception.vue&#x27;),</span><br><span class="hljs-comment">//   Dashboard: LAYOUT,</span><br><span class="hljs-comment">//   Analysis: () =&gt; import(&#x27;@/views/dashboard/analysis/index.vue&#x27;),</span><br><span class="hljs-comment">//   Workbench: () =&gt; import(&#x27;@/views/dashboard/workbench/index.vue&#x27;),</span><br><span class="hljs-comment">//   NOT_FOUND: EXCEPTION_COMPONENT,</span><br><span class="hljs-comment">//   Charts: LAYOUT,</span><br><span class="hljs-comment">//   BaiduMap: () =&gt; import(&#x27;@/views/demo/charts/map/Baidu.vue&#x27;),</span><br><span class="hljs-comment">//   AMap: () =&gt; import(&#x27;@/views/demo/charts/map/Gaode.vue&#x27;),</span><br><span class="hljs-comment">//   GoogleMap: () =&gt; import(&#x27;@/views/demo/charts/map/Google.vue&#x27;),</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// &#125;;</span><br><span class="hljs-keyword">const</span> flatRoutes = &#123;&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">generateRouteMap</span>(<span class="hljs-params">routes</span>) &#123;<br>  <span class="hljs-keyword">return</span> routes.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (item.<span class="hljs-property">children</span> &amp;&amp; item.<span class="hljs-property">children</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-title function_">generateRouteMap</span>(item.<span class="hljs-property">children</span>);<br>    &#125;<br>    flatRoutes[item.<span class="hljs-property">name</span>] = item[<span class="hljs-string">&#x27;component&#x27;</span>];<br>  &#125;);<br>&#125;<br><br><span class="hljs-title function_">generateRouteMap</span>(asyncRoutes);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ROUTE_MAP</span> = flatRoutes<br><br></code></pre></td></tr></table></figure><h1 id="后端菜单数据查询API开发"><a href="#后端菜单数据查询API开发" class="headerlink" title="后端菜单数据查询API开发"></a>后端菜单数据查询API开发</h1><p>在menu目录下建立好menu entity、module、data文件并做好接口开发，然后在前端中对接</p><p>src&#x2F;api&#x2F;sys&#x2F;menu 目录下现有获取菜单接口，所以在此处改造即可</p><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240926210955.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>Vue.js</tag>
      
      <tag>Typescript</tag>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书管理后台开发项目-5.登录功能后端开发</title>
    <link href="/2024/09/24/%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-5-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    <url>/2024/09/24/%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-5-%E7%99%BB%E5%BD%95%E5%8A%9F%E8%83%BD%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-登录时序图"><a href="#1-登录时序图" class="headerlink" title="1.登录时序图"></a>1.登录时序图</h1><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240924213041.png"></p><h1 id="2-请求守卫开发"><a href="#2-请求守卫开发" class="headerlink" title="2.请求守卫开发"></a>2.请求守卫开发</h1><p>建立如下auth目录结构<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240924214824.png"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//public.decorator.ts</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">SetMetadata</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IS_PUBLIC_KEY</span> = <span class="hljs-string">&#x27;isPublic&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">Public</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title class_">SetMetadata</span>(<span class="hljs-variable constant_">IS_PUBLIC_KEY</span>, <span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//auth.guard.ts</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">CanActivate</span>, <span class="hljs-title class_">ExecutionContext</span>, <span class="hljs-title class_">Injectable</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Observable</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;rxjs&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Reflector</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-variable constant_">IS_PUBLIC_KEY</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./public.decorator&#x27;</span>;<br><br><span class="hljs-meta">@Injectable</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthGuard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CanActivate</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-attr">reflector</span>: <span class="hljs-title class_">Reflector</span></span>) &#123;<br>    &#125;<br><br>    <span class="hljs-title function_">canActivate</span>(<span class="hljs-attr">context</span>: <span class="hljs-title class_">ExecutionContext</span>): <span class="hljs-built_in">boolean</span> | <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">boolean</span>&gt; | <span class="hljs-title class_">Observable</span>&lt;<span class="hljs-built_in">boolean</span>&gt; &#123;<br>        <span class="hljs-keyword">const</span> isPublic = <span class="hljs-variable language_">this</span>.<span class="hljs-property">reflector</span>.<span class="hljs-title function_">getAllAndOverride</span>(<span class="hljs-variable constant_">IS_PUBLIC_KEY</span>, [<br>            context.<span class="hljs-title function_">getHandler</span>(),<br>            context.<span class="hljs-title function_">getClass</span>()<br>        ])<br>        <span class="hljs-keyword">return</span> isPublic<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//auth.module.ts</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Module</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">AuthController</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./auth.controller&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">AuthService</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./auth.service&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-variable constant_">APP_GUARD</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/core&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">AuthGuard</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./auth.guard&#x27;</span>;<br><br><span class="hljs-meta">@Module</span>(&#123;<br>    <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">AuthController</span>],<br>    <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">AuthService</span>, &#123;<br>        <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">APP_GUARD</span>,<br>        <span class="hljs-attr">useClass</span>: <span class="hljs-title class_">AuthGuard</span><br>    &#125;],<br><br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthModule</span> &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="5-2登录鉴权接口的调用链路"><a href="#5-2登录鉴权接口的调用链路" class="headerlink" title="5.2登录鉴权接口的调用链路"></a>5.2登录鉴权接口的调用链路</h2><p>继续开发登录鉴权接口的调用链路<br>首先在auth.module中引入UserModule方便我们使用UserService中的查询用户操作,注意引入UserModule时需要先export UserService</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Module</span>(&#123;<br>    <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">UserModule</span>],<br>    <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">AuthController</span>],<br>    <span class="hljs-attr">providers</span>: [<br>        <span class="hljs-title class_">AuthService</span>,<br>        &#123;<br>            <span class="hljs-attr">provide</span>: <span class="hljs-variable constant_">APP_GUARD</span>,<br>            <span class="hljs-attr">useClass</span>: <span class="hljs-title class_">AuthGuard</span>,<br>        &#125;,<br>    ],<br>&#125;)<br></code></pre></td></tr></table></figure><p>随后在auth.controller中编写调用authService的逻辑</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Public</span>()<br><span class="hljs-meta">@Post</span>(<span class="hljs-string">&#x27;login&#x27;</span>)<br><span class="hljs-keyword">async</span><br><span class="hljs-title function_">login</span>(<span class="hljs-params"><span class="hljs-meta">@Body</span>()</span><br><span class="hljs-params">params</span><br><span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">authService</span>.<span class="hljs-title function_">login</span>(params.<span class="hljs-property">username</span>, params.<span class="hljs-property">password</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;authed&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>authService的逻辑便是调用userService查询是否有传入的username</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Injectable</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthService</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-attr">userService</span>: <span class="hljs-title class_">UserService</span></span>) &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">login</span>(<span class="hljs-params">username, password</span>) &#123;<br>        <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">userService</span>.<span class="hljs-title function_">findByUsername</span>(username);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>至此登录鉴权的调用链路逻辑编写完毕</p><h2 id="5-3-登录密码校验逻辑实实现"><a href="#5-3-登录密码校验逻辑实实现" class="headerlink" title="5.3 登录密码校验逻辑实实现"></a>5.3 登录密码校验逻辑实实现</h2><p>传进来的password需要进行md5加密转换，所以我们先安装md5库<code>npm install md5</code>,然后编写逻辑</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript">  <span class="hljs-keyword">async</span><br><span class="hljs-title function_">login</span>(<span class="hljs-params">username, password</span>)<br>&#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">userService</span>.<span class="hljs-title function_">findByUsername</span>(username);<br>    <span class="hljs-keyword">const</span> md5Password = <span class="hljs-title function_">md5</span>(password).<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">toUpperCase</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user, md5Password);<br>    <span class="hljs-keyword">if</span> (user.<span class="hljs-property">password</span> !== md5Password) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">BAD_REQUEST</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就要在密码验证成功时发送token</p><h2 id="5-4-JWT跨域身份验证"><a href="#5-4-JWT跨域身份验证" class="headerlink" title="5.4 JWT跨域身份验证"></a>5.4 JWT跨域身份验证</h2><p>安装nestjs提供的jwt模块<code>npm install @nestjs/jwt</code>,然后在auth.module中引入该模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Module</span>(&#123;<br>    <span class="hljs-attr">imports</span>: [<br>        <span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forRoot</span>(&#123;<br>            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;mysql&#x27;</span>,<br>            <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>            <span class="hljs-attr">port</span>: <span class="hljs-number">3306</span>,<br>            <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>            <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>            <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;vben-book-dev&#x27;</span>,<br>            <span class="hljs-attr">autoLoadEntities</span>: <span class="hljs-literal">true</span>,<br>        &#125;),<br>        <span class="hljs-title class_">UserModule</span>,<br>        <span class="hljs-title class_">AuthModule</span>,<br>        <span class="hljs-title class_">BookModule</span>,<br>    ],<br><span class="hljs-comment">//...</span><br>)<br></code></pre></td></tr></table></figure><p>编写service登录逻辑</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript">  <span class="hljs-keyword">async</span><br><span class="hljs-title function_">login</span>(<span class="hljs-params">username, password</span>)<br>&#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">userService</span>.<span class="hljs-title function_">findByUsername</span>(username);<br>    <span class="hljs-keyword">if</span> (user === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(<span class="hljs-string">&#x27;No User&#x27;</span>, <span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">BAD_REQUEST</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> md5Password = <span class="hljs-title function_">md5</span>(password).<span class="hljs-title function_">toString</span>().<span class="hljs-title function_">toUpperCase</span>();<br>    <span class="hljs-keyword">if</span> (user.<span class="hljs-property">password</span> !== md5Password) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpException</span>(<span class="hljs-string">&#x27;PasswordError&#x27;</span>, <span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">BAD_REQUEST</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> payload = &#123;<span class="hljs-attr">username</span>: user.<span class="hljs-property">username</span>, <span class="hljs-attr">userid</span>: user.<span class="hljs-property">id</span>&#125;;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">token</span>: <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">jwtService</span>.<span class="hljs-title function_">signAsync</span>(payload),<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了统一响应结果，可以在utils下编写success和error函数规范响应体</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">success</span>(<span class="hljs-params">data, msg</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">code</span>: <span class="hljs-number">0</span>,<br>        data,<br>        msg,<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">error</span>(<span class="hljs-params">msg</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">code</span>: -<span class="hljs-number">1</span>,<br>        msg<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>并在controller中应用</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Public</span>()<br><span class="hljs-meta">@Post</span>(<span class="hljs-string">&#x27;login&#x27;</span>)<br><span class="hljs-keyword">async</span><br><span class="hljs-title function_">login</span>(<span class="hljs-params"><span class="hljs-meta">@Body</span>()</span><br><span class="hljs-params">params</span><br><span class="hljs-params"></span>)<br>&#123;<br>    <span class="hljs-keyword">let</span> err;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">authService</span><br>        .<span class="hljs-title function_">login</span>(params.<span class="hljs-property">username</span>, params.<span class="hljs-property">password</span>)<br>        .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> (err = e));<br>    <span class="hljs-keyword">if</span> (!err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">success</span>(data, <span class="hljs-string">&#x27;登录成功&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">error</span>(err.<span class="hljs-title function_">toString</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>成功响应结果：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240925155817.png"></p><h2 id="5-5前后端login接口联调"><a href="#5-5前后端login接口联调" class="headerlink" title="5.5前后端login接口联调"></a>5.5前后端login接口联调</h2><p>改动全局API_URL配置为域名+端口号地址<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240925160932.png"></p><blockquote><p>注意如果开启代理软件会导致host失效</p></blockquote><p>然后解决前端兼容性问题,通过调试可知API响应格式为result，message。所以更改后端的响应格式即可兼容</p><h1 id="5-6后端请求首位token验证逻辑开发"><a href="#5-6后端请求首位token验证逻辑开发" class="headerlink" title="5.6后端请求首位token验证逻辑开发"></a>5.6后端请求首位token验证逻辑开发</h1><p>在查询用户操作应该在user.service中提供，所以在service和controller中添加getUserByToken方法.<br>在发送user&#x2F;info请求时，请求会先发送到auth守卫中，然后再发给usercontroller。所以我们再auth守卫中首先校验token是否有效</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Injectable</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthGuard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CanActivate</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> <span class="hljs-attr">reflector</span>: <span class="hljs-title class_">Reflector</span>, <span class="hljs-keyword">private</span> <span class="hljs-attr">jwtService</span>: <span class="hljs-title class_">JwtService</span></span>) &#123;<br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">canActivate</span>(<span class="hljs-attr">context</span>: <span class="hljs-title class_">ExecutionContext</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-built_in">boolean</span>&gt; &#123;<br><br>        <span class="hljs-comment">// const isPublic = this.reflector.getAllAndOverride(IS_PUBLIC_KEY, [</span><br>        <span class="hljs-comment">//     context.getHandler(),</span><br>        <span class="hljs-comment">//     context.getClass()</span><br>        <span class="hljs-comment">// ])</span><br>        <span class="hljs-comment">// if (isPublic)&#123;</span><br>        <span class="hljs-comment">//     return isPublic</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// const request = context.switchToHttp().getRequest()</span><br><br>        <span class="hljs-comment">//关注以下代码</span><br>        <span class="hljs-keyword">const</span> token = <span class="hljs-title function_">extractTokenFromHeader</span>(request)<br>        <span class="hljs-keyword">if</span> (!token) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnauthorizedException</span>()<br>        &#125;<br>        <span class="hljs-comment">//验证jwt的可行性</span><br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">const</span> payload = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">jwtService</span>.<span class="hljs-title function_">verifyAsync</span>(token, &#123;<br>                <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;abcdefg&#x27;</span><br>            &#125;)<br>            <span class="hljs-comment">//将解析出来的的用户信息放在所有API的请求头里方便调用用户信息</span><br>            request[<span class="hljs-string">&#x27;user&#x27;</span>] = payload<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnauthorizedException</span>()<br>        &#125;<br><br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">extractTokenFromHeader</span>(<span class="hljs-params">request</span>) &#123;<br>    <span class="hljs-comment">// console.log(request);</span><br>    <span class="hljs-keyword">const</span> token = request.<span class="hljs-property">headers</span>.<span class="hljs-property">authorization</span>;<br>    <span class="hljs-keyword">return</span> token<br>&#125;<br></code></pre></td></tr></table></figure><p>使用extractTokenFromHeader提取出请求头中的<strong>authorization</strong>字段中的<strong>token</strong>后再调用<strong>jwtService.verify</strong><br>解出jwt的payload。如果是有效的则payload会被添加到请求头中的’user’字段方便Api调用用户信息。若不成功则会抛出异常</p><p>最后再user.controller中获取请求体并调用service查询用户信息</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript">  <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;info&#x27;</span>)<br><span class="hljs-title function_">getUserByToken</span>(<span class="hljs-params"><span class="hljs-meta">@Req</span>()</span><br><span class="hljs-params">request</span><br><span class="hljs-params"></span>)<br>&#123;<br><br>    <span class="hljs-keyword">const</span> user = request.<span class="hljs-property">user</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">wrapperResponse</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">userService</span>.<span class="hljs-title function_">findByUsername</span>(user.<span class="hljs-property">username</span>), <span class="hljs-string">&#x27;获取用户信息成功&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>Typescript</tag>
      
      <tag>Nest.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书管理后台开发项目-4.数据库接入</title>
    <link href="/2024/09/24/%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5/"/>
    <url>/2024/09/24/%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-4-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A5%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="1-后端业务模块设计与拆分"><a href="#1-后端业务模块设计与拆分" class="headerlink" title="1.后端业务模块设计与拆分"></a>1.后端业务模块设计与拆分</h1><p>模块设计：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240924160218.png"></p><p>创建用户模块</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">nest g controller user<br>nest g module user<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Controller</span>, <span class="hljs-title class_">Get</span>, <span class="hljs-title class_">Param</span>, <span class="hljs-title class_">ParseIntPipe</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><br><span class="hljs-meta">@Controller</span>(<span class="hljs-string">&#x27;user&#x27;</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>  <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;:id&#x27;</span>)<br>  <span class="hljs-title function_">getUser</span>(<span class="hljs-params"><span class="hljs-meta">@Param</span>(<span class="hljs-string">&#x27;id&#x27;</span>, ParseIntPipe) <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;get user:&#x27;</span> + id;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240924161639.png"></p><p>创建鉴权模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Controller</span>(<span class="hljs-string">&#x27;auth&#x27;</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthController</span> &#123;<br>    <span class="hljs-meta">@Get</span>()<br>    <span class="hljs-title function_">auth</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;auth&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建book模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Controller</span>(<span class="hljs-string">&#x27;book&#x27;</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BookController</span> &#123;<br>    <span class="hljs-meta">@Get</span>(<span class="hljs-string">&#x27;:id&#x27;</span>)<br>    <span class="hljs-title function_">getBok</span>(<span class="hljs-params"><span class="hljs-meta">@Param</span>(<span class="hljs-string">&#x27;id&#x27;</span>, ParseIntPipe) id</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;get book:&#x27;</span>+id<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="2导入数据库与连接数据库"><a href="#2导入数据库与连接数据库" class="headerlink" title="2导入数据库与连接数据库"></a>2导入数据库与连接数据库</h1><p>创建vben-book-dev数据库，并导入SQL。</p><p>然后集成TypeOrm</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install --save @nestjs/typeorm typeorm mysql2<br></code></pre></td></tr></table></figure><p>在app.module中引入TypeormModule模块</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Module</span>(&#123;<br>    <span class="hljs-attr">imports</span>: [<span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forRoot</span>(&#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;mysql&#x27;</span>,<br>        <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>        <span class="hljs-attr">port</span>: <span class="hljs-number">3306</span>,<br>        <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>        <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>        <span class="hljs-attr">database</span>: <span class="hljs-string">&#x27;vben-book-dev&#x27;</span><br>    &#125;),<span class="hljs-title class_">UserModule</span>, <span class="hljs-title class_">AuthModule</span>, <span class="hljs-title class_">BookModule</span>],<br>    <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">AppController</span>, <span class="hljs-title class_">UserController</span>, <span class="hljs-title class_">AuthController</span>, <span class="hljs-title class_">BookController</span>],<br>    <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">AppService</span>],<br>&#125;)<br></code></pre></td></tr></table></figure><h1 id="3-数据库实体的使用"><a href="#3-数据库实体的使用" class="headerlink" title="3.数据库实体的使用"></a>3.数据库实体的使用</h1><p>首先创建user的实体，在user目录下新建user.entity.ts.</p><blockquote><p>注意：TypeOrmModule中的synchronize: true不能被用于生产环境，否则会导致生产环境数据丢失。因为它会根据项目中的entity文件在数据库中重新生成表</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Column</span>, <span class="hljs-title class_">Entity</span>, <span class="hljs-title class_">PrimaryGeneratedColumn</span>, <span class="hljs-title class_">Unique</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;typeorm&#x27;</span>;<br><span class="hljs-meta">@Entity</span>(<span class="hljs-string">&#x27;admin_user&#x27;</span>)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>  <span class="hljs-meta">@Column</span>()<br>  <span class="hljs-meta">@PrimaryGeneratedColumn</span>()<br>  <span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-meta">@Column</span>()<br>  <span class="hljs-meta">@Unique</span>([<span class="hljs-string">&#x27;username&#x27;</span>])<br>  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-meta">@Column</span>()<br>  <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-meta">@Column</span>()<br>  <span class="hljs-attr">role</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-meta">@Column</span>()<br>  <span class="hljs-attr">nickname</span>: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-meta">@Column</span>()<br>  <span class="hljs-attr">active</span>: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-meta">@Column</span>()<br>  <span class="hljs-attr">avatar</span>: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在usermodule中引入TypeormModule</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Module</span>(&#123;<br>    <span class="hljs-attr">imports</span>:[<span class="hljs-title class_">TypeOrmModule</span>.<span class="hljs-title function_">forFeature</span>([<span class="hljs-title class_">User</span>])],<br>    <span class="hljs-attr">controllers</span>: [<span class="hljs-title class_">UserController</span>],<br>    <span class="hljs-attr">providers</span>: [<span class="hljs-title class_">UserService</span>]<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserModule</span> &#123;&#125;<br><br></code></pre></td></tr></table></figure><p>并在userService中编写代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">        <span class="hljs-meta">@InjectRepository</span>(User)</span><br><span class="hljs-params">        <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> <span class="hljs-attr">usersRepository</span>: <span class="hljs-title class_">Repository</span>&lt;<span class="hljs-title class_">User</span>&gt;,</span><br><span class="hljs-params">    </span>) &#123;<br>    &#125;<br><br>    <span class="hljs-title function_">findOne</span>(<span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">User</span>&gt; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">usersRepository</span>.<span class="hljs-title function_">findOneBy</span>(&#123; id &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后记得在Appmodule的typeormmodule工厂函数中设置<code>autoLoadEntities: true</code><br>最后调用即可<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240924165922.png"></p><h2 id="3-2-增删改的代码"><a href="#3-2-增删改的代码" class="headerlink" title="3.2 增删改的代码"></a>3.2 增删改的代码</h2><p>1.增<br>创建一个create-user.dto.ts用于校验,注意create-user.dto.ts中的字段与entity中的字段并不完全一致</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateUserDto</span>&#123;<br>  <span class="hljs-attr">username</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">password</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">role</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">nickname</span>:<span class="hljs-built_in">string</span>;<br>  <span class="hljs-attr">avatar</span>:<span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>随后写入create服务</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//...</span><br>  <span class="hljs-title function_">create</span>(<span class="hljs-attr">createUserDto</span>: <span class="hljs-title class_">CreateUserDto</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">User</span>&gt; &#123;<br>    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.<span class="hljs-property">username</span> = createUserDto.<span class="hljs-property">username</span>;<br>    user.<span class="hljs-property">password</span> = createUserDto.<span class="hljs-property">password</span><br>    user.<span class="hljs-property">role</span> = createUserDto.<span class="hljs-property">role</span><br>    user.<span class="hljs-property">avatar</span> = createUserDto.<span class="hljs-property">avatar</span><br>    user.<span class="hljs-property">active</span> = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">usersRepository</span>.<span class="hljs-title function_">save</span>(user)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>Typescript</tag>
      
      <tag>Nest.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>读书管理后台开发项目-3.Nest框架搭建</title>
    <link href="/2024/09/23/%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-3-Nest%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/09/23/%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-3-Nest%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Nest框架搭建"><a href="#1-Nest框架搭建" class="headerlink" title="1.Nest框架搭建"></a>1.Nest框架搭建</h1><p>使用官方推荐的CLI搭建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm i -g @nestjs/cli<br>nest new imooc-nest-admin<br></code></pre></td></tr></table></figure><h1 id="2-Nest实现Restful-API"><a href="#2-Nest实现Restful-API" class="headerlink" title="2.Nest实现Restful API"></a>2.Nest实现Restful API</h1><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240924153648.png"></p><h2 id="2-1-Get方法传参方式：Param"><a href="#2-1-Get方法传参方式：Param" class="headerlink" title="2.1 Get方法传参方式：Param"></a>2.1 Get方法传参方式：Param</h2><p>获得Get方法中的参数如果使用Param装饰器则对应获取restful Api参数<br>使用方法是直接在get方法函数中@param<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240924154059.png"><br>级联参数同样使用@param<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240924154229.png"></p><h2 id="2-1-Post方法传参方式：Body"><a href="#2-1-Post方法传参方式：Body" class="headerlink" title="2.1 Post方法传参方式：Body"></a>2.1 Post方法传参方式：Body</h2><p>获取Post方法中的参数可以使用Body装饰器获取如：<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240924154409.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240924154425.png"><br>同样，Post方法也可以在URL中添加Query参数<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240924154510.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240924154545.png"></p><h2 id="2-2-Put方法传参方式"><a href="#2-2-Put方法传参方式" class="headerlink" title="2.2 Put方法传参方式"></a>2.2 Put方法传参方式</h2><p>Put方法和Post方法使用一致，可以用@Body接收数据，也可以在URL中Query参数</p><h1 id="3-Provider"><a href="#3-Provider" class="headerlink" title="3.Provider"></a>3.Provider</h1><p>保存了服务的实例化的容器，如AppService中会有一个Injectable装饰器标识这个类可以被注入。这样controller可以引入服务</p><h1 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4.异常处理"></a>4.异常处理</h1><p>当访问接口时，若抛出异常。使用自定义一茶馆可以用装饰器：@UseFilters()</p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>Typescript</tag>
      
      <tag>Nest.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小慕读书管理后台开发项目-2.前端框架搭建</title>
    <link href="/2024/09/23/%E5%B0%8F%E6%85%95%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-2-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/"/>
    <url>/2024/09/23/%E5%B0%8F%E6%85%95%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-2-%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="1-前端框架下载和启动"><a href="#1-前端框架下载和启动" class="headerlink" title="1.前端框架下载和启动"></a>1.前端框架下载和启动</h1><p>在<a href="https://github.com/vbenjs/vue-vben-admin">vue-vben-admin</a>官方仓库中克隆代码到本地磁盘<br>然后安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pnpm install<br></code></pre></td></tr></table></figure><h1 id="2-vben三种运行模式"><a href="#2-vben三种运行模式" class="headerlink" title="2.vben三种运行模式"></a>2.vben三种运行模式</h1><h2 id="2-1-npm-run-serve"><a href="#2-1-npm-run-serve" class="headerlink" title="2.1 npm run serve"></a>2.1 npm run serve</h2><p>很常见的运行方式，实际上就是调用vite运行</p><h2 id="2-2-preview模式"><a href="#2-2-preview模式" class="headerlink" title="2.2 preview模式"></a>2.2 preview模式</h2><p><code>&quot;preview:&quot; npm run build &amp;&amp; vite preview</code> 会先构建然后用vite进行preview.在开发模式下会很慢，但通常用在生产环境</p><h2 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h2><p><code>npm run build:analyze</code> 可以对构建包的大小进行分析</p><h1 id="3-vben项目发布的方式"><a href="#3-vben项目发布的方式" class="headerlink" title="3.vben项目发布的方式"></a>3.vben项目发布的方式</h1><p>若项目发布在非根目录的域名下，则需要在vite config中编辑。如：localhost&#x2F;vben&#x2F;<br>vben在vite config文件中做了一些封裝，也即写进了vite-config依赖中<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923172918.png"></p><blockquote><p>package依赖里面的workspace版本号为pnpm的特殊写法，表明了这个项目的依赖需要在本地的workspace中查找，不在网络上下载。也即在interal&#x2F;vite-config中会有这个依赖<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923173230.png"></p></blockquote><p>跟踪配置函数的源文件，找到了如下图的代码。我们接着跟进application文件中</p><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923173657.png"></p><p>即可看见UserConfig interface，关键的就是base字段。</p><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923211356.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923211525.png"></p><p>设置值为&#x2F;vben启动后则可以在控制台看出前后的区别</p><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923211804.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923212257.png"><br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923212412.png"></p><h1 id="4-vben-esmodule-特性支持"><a href="#4-vben-esmodule-特性支持" class="headerlink" title="4.vben esmodule 特性支持"></a>4.vben esmodule 特性支持</h1><p>vben使用了module特性加载资源文件<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923212648.png"></p><p>深入来说，在一个index.html使用import语句引入一个js脚本会报错<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923212921.png"></p><p>index.html</p><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923212950.png"></p><p>test.js：</p><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923212824.png"><br>如果加上type&#x3D;module则能正常运行</p><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923213035.png"><br>这也是vite快速启动的原因，没有对文件进行编译。只有在对资源进行访问时才拦截然后处理相应资源，例如App.vue会在运行时才被构建编译</p><h1 id="4-1-vitejs-plugin-vue深入"><a href="#4-1-vitejs-plugin-vue深入" class="headerlink" title="4.1 vitejs&#x2F;plugin-vue深入"></a>4.1 vitejs&#x2F;plugin-vue深入</h1><p>该插件的核心用途就是在应用启动后将vue文件进行编译。使用时直接调用即可<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923213505.png"></p><p>Vite在启动时仅仅生成了配置文件，然后在运行过程中才对Vue文件进行编译</p><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923213700.png"></p><p>想了解程序流程，可以在<strong>开发模式</strong>下在vue()函数调用处断点然后调试。</p><h2 id="4-1-Vite-vue插件原理解析"><a href="#4-1-Vite-vue插件原理解析" class="headerlink" title="4.1 Vite-vue插件原理解析"></a>4.1 Vite-vue插件原理解析</h2><p>在defineApplicationConfig函数处下断点后跟进程序到CreatePlugins<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923214434.png"><br>CreatePlugin出即可看见Vue()方法的调用<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923214545.png"><br>首先也可以看一下VitePlugin的工作流程<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923214754.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>Vue.js</tag>
      
      <tag>Typescript</tag>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小慕读书管理后台开发项目-1.需求分析与技术架构</title>
    <link href="/2024/09/23/%E5%B0%8F%E6%85%95%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/09/23/%E5%B0%8F%E6%85%95%E8%AF%BB%E4%B9%A6%E7%AE%A1%E7%90%86%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91%E9%A1%B9%E7%9B%AE-1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="1-管理后台需求分析"><a href="#1-管理后台需求分析" class="headerlink" title="1.管理后台需求分析"></a>1.管理后台需求分析</h1><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923164423.png" alt="管理后台需求分析"></p><h2 id="1-1-登录页面"><a href="#1-1-登录页面" class="headerlink" title="1.1 登录页面"></a>1.1 登录页面</h2><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923164631.png" alt="登录页面"></p><h2 id="1-2-权限控制"><a href="#1-2-权限控制" class="headerlink" title="1.2 权限控制"></a>1.2 权限控制</h2><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923164717.png" alt="权限控制"></p><h2 id="1-3-图书管理"><a href="#1-3-图书管理" class="headerlink" title="1.3 图书管理"></a>1.3 图书管理</h2><p><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923164742.png" alt="图书管理"></p><h1 id="2-管理后台项目架构设计"><a href="#2-管理后台项目架构设计" class="headerlink" title="2.管理后台项目架构设计"></a>2.管理后台项目架构设计</h1><ul><li>域名：阿里云租用域名</li><li>服务器：租用阿里云服务器</li><li>Web服务：Nginx<br><img src="https://picbed-1251050137.cos.ap-nanjing.myqcloud.com/20240923164917.png" alt="项目架构"></li></ul><h1 id="2-1技术选型"><a href="#2-1技术选型" class="headerlink" title="2.1技术选型"></a>2.1技术选型</h1><h2 id="2-2-前端"><a href="#2-2-前端" class="headerlink" title="2.2 前端"></a>2.2 前端</h2><ul><li>框架：vue-ven-admin</li><li>核心库： Vue3全家桶（Vue+vue+router4+pinia）、Vite、ant-design-vue、windicss</li></ul><h2 id="2-3-后端"><a href="#2-3-后端" class="headerlink" title="2.3 后端"></a>2.3 后端</h2><ul><li>框架：NestJS<ul><li>依赖注入</li><li>Restful API</li><li>JWT 鉴权</li><li>CORS跨域</li><li>ORM模型</li></ul></li><li>数据库：Mysql</li></ul><h1 id="3-项目开发阶段"><a href="#3-项目开发阶段" class="headerlink" title="3.项目开发阶段"></a>3.项目开发阶段</h1><h2 id="3-1框架搭建"><a href="#3-1框架搭建" class="headerlink" title="3.1框架搭建"></a>3.1框架搭建</h2><p>前后端搭建框架</p><h2 id="3-2登录模块开发"><a href="#3-2登录模块开发" class="headerlink" title="3.2登录模块开发"></a>3.2登录模块开发</h2><p>完成登录模块前后端开发</p><h2 id="3-3前端控制权限模块开发"><a href="#3-3前端控制权限模块开发" class="headerlink" title="3.3前端控制权限模块开发"></a>3.3前端控制权限模块开发</h2><p>完成基于前端的权限模块开发</p><h2 id="3-4图书模块开发"><a href="#3-4图书模块开发" class="headerlink" title="3.4图书模块开发"></a>3.4图书模块开发</h2><p>完成图书管理和图书新增模块开发</p><h2 id="3-5后端控制权限模块开发"><a href="#3-5后端控制权限模块开发" class="headerlink" title="3.5后端控制权限模块开发"></a>3.5后端控制权限模块开发</h2><p>完成基于后端的权限模块开发</p><h2 id="3-6基于无界微前端的项目架构升级"><a href="#3-6基于无界微前端的项目架构升级" class="headerlink" title="3.6基于无界微前端的项目架构升级"></a>3.6基于无界微前端的项目架构升级</h2><p>完成微前端主应用和子应用的拆解和项目升级</p>]]></content>
    
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>Vue.js</tag>
      
      <tag>Typescript</tag>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/09/23/hello-world/"/>
    <url>/2024/09/23/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用IIFE优化性能</title>
    <link href="/2023/07/16/%E4%BD%BF%E7%94%A8IIFE%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/"/>
    <url>/2023/07/16/%E4%BD%BF%E7%94%A8IIFE%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="1-问题引入"><a href="#1-问题引入" class="headerlink" title="1.问题引入"></a>1.问题引入</h2><p>考虑一个兼容浏览器事件添加的代码段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addEvent</span>(<span class="hljs-params">ele, eventName, handler</span>)&#123;<br>    <span class="hljs-keyword">if</span>(ele.<span class="hljs-property">addEventListener</span>)&#123;<br>        ele.<span class="hljs-title function_">addEventListener</span>(eventName, handler)<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ele.<span class="hljs-property">attachEvent</span>)&#123;<br>        ele.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&#x27;on&#x27;</span>+eventName, handler)<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        ele[<span class="hljs-string">&#x27;on&#x27;</span>+eventName] = handler<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码实现了兼容包括谷歌浏览器、IE浏览器等的事件监听方法。代码本身不存在BUG，但是在执行时会有性能问题。用户在每次添加事件时都需要走一遍if-else流程，但实际上我们在第一次调用 <code>addEvent</code> 方法甚至在脚本加载时就得知当前浏览器环境适用的事件监听方法。我们可以使用添加flag的方法来跳过后续重复调用函数时的性能损耗</p><h2 id="2-flagFunction优化"><a href="#2-flagFunction优化" class="headerlink" title="2.flagFunction优化"></a>2.flagFunction优化</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//flagFunction</span><br><span class="hljs-keyword">let</span> flagFunction<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addEvent</span>(<span class="hljs-params">ele, eventName, handler</span>)&#123;<br>    <span class="hljs-keyword">if</span>(flagFunction)&#123;<br>        flagFunction.<span class="hljs-title function_">call</span>(ele, eventName, handler)<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>(ele.<span class="hljs-property">addEventListener</span>)&#123;<br>            ele.<span class="hljs-title function_">addEventListener</span>(eventName, handler)<br>            flagFunction = ele.<span class="hljs-property">addEventListener</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(ele.<span class="hljs-property">attachEvent</span>)&#123;<br>            ele.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&#x27;on&#x27;</span>+eventName, handler)<br>            flagFunction = ele.<span class="hljs-property">attachEvent</span><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ele[<span class="hljs-string">&#x27;on&#x27;</span>+eventName] = handler<br>            flagFunction = <span class="hljs-keyword">function</span> (<span class="hljs-params">eventName, handler</span>)&#123;<br>                ele[<span class="hljs-string">&#x27;on&#x27;</span>+eventName] = handler<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-IIFE方式优化"><a href="#3-IIFE方式优化" class="headerlink" title="3.IIFE方式优化"></a>3.IIFE方式优化</h2><p>实际上，这种方法代码会造成难以维护。我们接着采用IIFE的方式优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//IIFE</span><br><span class="hljs-keyword">var</span> addEvent = (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">addEventListener</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ele, eventName, handler</span>)&#123;<br>            ele.<span class="hljs-title function_">addEventListener</span>(eventName, handler)<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">window</span>.<span class="hljs-property">attachEvent</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">ele, eventName, handler</span>)&#123;<br>            ele.<span class="hljs-title function_">attachEvent</span>(<span class="hljs-string">&#x27;on&#x27;</span>+eventName, handler)<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//...</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>可以看到相比第一中方式，采用IIFE使得代码更易阅读，更易维护</p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>IIFE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>threejs-16:galaxy-generate</title>
    <link href="/2023/04/01/threejs-16-galaxy-generate/"/>
    <url>/2023/04/01/threejs-16-galaxy-generate/</url>
    
    <content type="html"><![CDATA[<h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1.准备工作"></a>1.准备工作</h2><p>创建一个星系工厂函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">Galaxy generate</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">generateGalxy</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;generate the galaxy&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>创建一个 <code>parameter</code> 对象，将会包含星系所有的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parameter = &#123;&#125;<br><br>parameter.<span class="hljs-property">count</span> = <span class="hljs-number">1000</span> <span class="hljs-comment">//1000个粒子</span><br></code></pre></td></tr></table></figure><p>首先创建随机粒子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">generateGalxy</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferGeometry</span>()<br>    <span class="hljs-keyword">const</span> position = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(parameter.<span class="hljs-property">count</span> * <span class="hljs-number">3</span>)<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; parameter.<span class="hljs-property">count</span> ; i++)&#123;<br>        <span class="hljs-keyword">const</span> i3 = i * <span class="hljs-number">3</span><br>        position[i3] = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * <span class="hljs-number">3</span><br>        position[i3 + <span class="hljs-number">1</span>] = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * <span class="hljs-number">3</span><br>        position[i3 + <span class="hljs-number">2</span>] = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * <span class="hljs-number">3</span><br>    &#125;<br>    geometry.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;position&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(position, <span class="hljs-number">3</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>创建 <code>PointsMaterial</code> 类并添加 <code>size</code> 属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">parameter.<span class="hljs-property">size</span> = <span class="hljs-number">0.02</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">generateGalxy</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointsMaterial</span>(&#123;<br>        <span class="hljs-attr">size</span>: parameter.<span class="hljs-property">size</span>,<br>        <span class="hljs-attr">sizeAttenuation</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">depthWrite</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">blending</span>: <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">AdditiveBlending</span><br>    &#125;)<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    创建 Points</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">const</span> points = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Points</span>(geometry, material)<br>    scene.<span class="hljs-title function_">add</span>(points)<br>&#125;<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/04/01/threejs-16-galaxy-generate/particles.png" class="" width="400"> </div><p>为 tweaks 添加调试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">gui.<span class="hljs-title function_">add</span>(parameters, <span class="hljs-string">&#x27;count&#x27;</span>).<span class="hljs-title function_">min</span>(<span class="hljs-number">100</span>).<span class="hljs-title function_">max</span>(<span class="hljs-number">100000</span>).<span class="hljs-title function_">step</span>(<span class="hljs-number">100</span>).<span class="hljs-title function_">onFinishChange</span>(<span class="hljs-title class_">DreamFusion</span>)<br>gui.<span class="hljs-title function_">add</span>(parameters, <span class="hljs-string">&#x27;size&#x27;</span>).<span class="hljs-title function_">min</span>(<span class="hljs-number">0.001</span>).<span class="hljs-title function_">max</span>(<span class="hljs-number">0.1</span>).<span class="hljs-title function_">step</span>(<span class="hljs-number">0.001</span>).<span class="hljs-title function_">onFinishChange</span>(<span class="hljs-title class_">DreamFusion</span>)<br></code></pre></td></tr></table></figure><p>每次更新tweaks时会使粒子重复生成造成内存飙升，所以我们需要处理一下这个问题：将 <code>geometry</code>,<code>material</code>,<code>points</code> 变量移到 <code>generateGalaxy</code>函数外面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> geometry = <span class="hljs-literal">null</span><br><span class="hljs-keyword">let</span> material = <span class="hljs-literal">null</span><br><span class="hljs-keyword">let</span> points = <span class="hljs-literal">null</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">generateGalaxy</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">//...</span><br>    geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferGeometry</span>()<br>    <br>    <span class="hljs-comment">//...</span><br>    <br>    material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointsMaterial</span>(&#123;<br>        <span class="hljs-attr">size</span>: parameter.<span class="hljs-property">size</span>,<br>        <span class="hljs-attr">sizeAttenuation</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">depthWrite</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-attr">blending</span>: <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">AdditiveBlending</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在赋值之前，我们先测试它们是否存在，若存在则使用 <code>dispose()</code> 方法销毁几何体和材质，并用 <code>remove()</code> 方法把点从场景中移除</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">generateGalaxy</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">if</span>(points != <span class="hljs-literal">null</span>) &#123;<br>        geometry.<span class="hljs-title function_">dispose</span>()<br>        material.<span class="hljs-title function_">dispose</span>()<br>        scene.<span class="hljs-title function_">remove</span>(points)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/04/01/threejs-16-galaxy-generate/tw.png" class="" width="400"> </div><h2 id="2-造型"><a href="#2-造型" class="headerlink" title="2.造型"></a>2.造型</h2><p>接下来创造一个螺旋星系</p><div align="center"> <img src="/2023/04/01/threejs-16-galaxy-generate/galaxy.png" class="" width="400"> </div><p>添加 <code>radius</code> 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">parameter.<span class="hljs-property">radius</span> = <span class="hljs-number">5</span>    <span class="hljs-comment">//星系半径</span><br><span class="hljs-comment">//..</span><br>gui.<span class="hljs-title function_">add</span>(parameters, <span class="hljs-string">&#x27;radius&#x27;</span>).<span class="hljs-title function_">min</span>(<span class="hljs-number">0.001</span>).<span class="hljs-title function_">max</span>(<span class="hljs-number">20</span>).<span class="hljs-title function_">step</span>(<span class="hljs-number">0.001</span>).<span class="hljs-title function_">onFinishChange</span>(<span class="hljs-title class_">DreamFusion</span>)<br></code></pre></td></tr></table></figure><p>先从简单的开始：创建从中心向外的几条射线</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; parameter.<span class="hljs-property">count</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> i3 = i * <span class="hljs-number">3</span><br>    <span class="hljs-keyword">const</span> radius = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * parameter.<span class="hljs-property">radius</span><br>    position[i3] = radius<br>    position[i3 + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>    position[i3 + <span class="hljs-number">2</span>] = <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/04/01/threejs-16-galaxy-generate/line.png" class="" width="400"> </div><p>然后创建星系的其它分支</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//...</span><br>parameter.<span class="hljs-property">branches</span> = <span class="hljs-number">3</span><br>gui.<span class="hljs-title function_">add</span>(parameters, <span class="hljs-string">&#x27;branches&#x27;</span>).<span class="hljs-title function_">min</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">max</span>(<span class="hljs-number">20</span>).<span class="hljs-title function_">step</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">onFinishChange</span>(<span class="hljs-title class_">DreamFusion</span>)<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>将粒子放在分支上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; parameter.<span class="hljs-property">count</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> i3 = i * <span class="hljs-number">3</span><br>    <span class="hljs-keyword">const</span> radius = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * parameter.<span class="hljs-property">radius</span><br>    <span class="hljs-keyword">const</span> branchAngle = (i % parameter.<span class="hljs-property">branches</span>) / parameter.<span class="hljs-property">branches</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> <br>    position[i3] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(branchAngle) * radius<br>    position[i3 + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>    position[i3 + <span class="hljs-number">2</span>] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(branchAngle) * radius<br>&#125;<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/04/01/threejs-16-galaxy-generate/branch.png" class="" width="400"> </div><h2 id="3-旋转星系"><a href="#3-旋转星系" class="headerlink" title="3.旋转星系"></a>3.旋转星系</h2><p>添加 <code>spin</code> 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">parameter.<span class="hljs-property">spin</span> = <span class="hljs-number">1</span><br>gui.<span class="hljs-title function_">add</span>(parameters, <span class="hljs-string">&#x27;spin&#x27;</span>).<span class="hljs-title function_">min</span>(-<span class="hljs-number">5</span>).<span class="hljs-title function_">max</span>(<span class="hljs-number">5</span>).<span class="hljs-title function_">step</span>(<span class="hljs-number">0.01</span>).<span class="hljs-title function_">onFinishChange</span>(<span class="hljs-title class_">DreamFusion</span>)<br></code></pre></td></tr></table></figure><p>用 <code>spin</code> 乘 <code>spinAngle</code> 以旋转粒子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; parameter.<span class="hljs-property">count</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> i3 = i * <span class="hljs-number">3</span><br>    <span class="hljs-keyword">const</span> radius = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * parameter.<span class="hljs-property">radius</span><br>    <span class="hljs-keyword">const</span> spinAngle = radius * parameter.<span class="hljs-property">spin</span><br>    <span class="hljs-keyword">const</span> branchAngle = (i % parameter.<span class="hljs-property">branches</span>) / parameter.<span class="hljs-property">branches</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span> <br>    position[i3] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(branchAngle + spinAngle) * radius<br>    position[i3 + <span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>    position[i3 + <span class="hljs-number">2</span>] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(branchAngle + spinAngle) * radius<br>&#125;<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/04/01/threejs-16-galaxy-generate/spin.png" class="" width="400"> </div><h2 id="4-添加随机性"><a href="#4-添加随机性" class="headerlink" title="4.添加随机性"></a>4.添加随机性</h2><p>添加 <code>randomeness</code> 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">parameter.<span class="hljs-property">randomness</span> = <span class="hljs-number">0.2</span><br>gui.<span class="hljs-title function_">add</span>(parameters, <span class="hljs-string">&#x27;randomness&#x27;</span>).<span class="hljs-title function_">min</span>(<span class="hljs-number">0</span>).<span class="hljs-title function_">max</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">step</span>(<span class="hljs-number">0.001</span>).<span class="hljs-title function_">onFinishChange</span>(<span class="hljs-title class_">DreamFusion</span>)<br></code></pre></td></tr></table></figure><p>我们想让粒子随机的分布在分支周围，就要给每个轴创建一个随机值，并用它乘 <code>radius</code> 和 <code>randomness</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; parameter.<span class="hljs-property">count</span>; i++) &#123;<br>    <span class="hljs-keyword">const</span> i3 = i * <span class="hljs-number">3</span><br>    <span class="hljs-keyword">const</span> radius = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * parameter.<span class="hljs-property">radius</span><br><br>    <span class="hljs-keyword">const</span> spinAngle = radius * parameter.<span class="hljs-property">spin</span><br>    <span class="hljs-keyword">const</span> branchAngle = (i % parameter.<span class="hljs-property">branches</span>) / parameter.<span class="hljs-property">branches</span> * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">2</span><br><br>    <span class="hljs-keyword">const</span> randomX = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * parameter.<span class="hljs-property">randomness</span> * radius<br>    <span class="hljs-keyword">const</span> randomY = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * parameter.<span class="hljs-property">randomness</span> * radius<br>    <span class="hljs-keyword">const</span> randomZ = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * parameter.<span class="hljs-property">randomness</span> * radius<br>    position[i3] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(branchAngle + spinAngle) * radius + randomX<br>    position[i3 + <span class="hljs-number">1</span>] = randomY<br>    position[i3 + <span class="hljs-number">2</span>] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(branchAngle + spinAngle) * radius + randomZ<br>&#125;<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/04/01/threejs-16-galaxy-generate/random.png" class="" width="400"> </div><p>注意，此时随机位置是从0到1，我们最好把随机值域改为[-0.5, 0.5]</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">const</span> randomX = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * parameter.<span class="hljs-property">randomness</span> * radius<br>    <span class="hljs-keyword">const</span> randomY = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * parameter.<span class="hljs-property">randomness</span> * radius<br>    <span class="hljs-keyword">const</span> randomZ = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * parameter.<span class="hljs-property">randomness</span> * radius<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><p>但实际上，随机的粒子多了后会呈现整体变为一个“正方体”，我们需要的效果是中心多，四周少的效果。所以我们需要使用加权的方式获得非线性的随机数</p><div align="center"> <img src="/2023/04/01/threejs-16-galaxy-generate/curve.png" class="" width="400"> </div><p>添加 <code>randomnessPower</code> 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">parameter.<span class="hljs-property">randomnessPower</span> = <span class="hljs-number">3</span><br>gui.<span class="hljs-title function_">add</span>(parameters, <span class="hljs-string">&#x27;randomnessPower&#x27;</span>).<span class="hljs-title function_">min</span>(<span class="hljs-number">1</span>).<span class="hljs-title function_">max</span>(<span class="hljs-number">10</span>).<span class="hljs-title function_">step</span>(<span class="hljs-number">0.001</span>).<span class="hljs-title function_">onFinishChange</span>(<span class="hljs-title class_">DreamFusion</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">const</span> randomX = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(), parameter.<span class="hljs-property">randomnessPower</span>) * (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &lt; <span class="hljs-number">0.5</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">const</span> randomY = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(), parameter.<span class="hljs-property">randomnessPower</span>) * (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &lt; <span class="hljs-number">0.5</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">const</span> randomZ = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(), parameter.<span class="hljs-property">randomnessPower</span>) * (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() &lt; <span class="hljs-number">0.5</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>)<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><h2 id="5-添加颜色"><a href="#5-添加颜色" class="headerlink" title="5.添加颜色"></a>5.添加颜色</h2><p>我们想让粒子从内到外做出一个渐变。添加 <code>innerColor</code> 和 <code>outsideColor</code> 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">parameter.<span class="hljs-property">innerColor</span> = <span class="hljs-string">&#x27;#ff6030&#x27;</span><br>parameter.<span class="hljs-property">outsideColor</span> = <span class="hljs-string">&#x27;#1b3984&#x27;</span><br><br>gui.<span class="hljs-title function_">addColor</span>(parameter, <span class="hljs-string">&quot;innerColor&quot;</span>).<span class="hljs-title function_">onFinishChange</span>(generateGalxy)<br>gui.<span class="hljs-title function_">addColor</span>(parameter, <span class="hljs-string">&quot;outsideColor&quot;</span>).<span class="hljs-title function_">onFinishChange</span>(generateGalxy)<br></code></pre></td></tr></table></figure><p>然后再PointMaterial中开启 <code>vertexColors</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointsMaterial</span>(&#123;<br>    <span class="hljs-attr">size</span>: parameter.<span class="hljs-property">size</span>,<br>    <span class="hljs-attr">sizeAttenuation</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">depthWrite</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">blending</span>: <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">AdditiveBlending</span>,<br>    <span class="hljs-attr">vertexColors</span>: <span class="hljs-literal">true</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>给 <code>geometry</code> 添加 <code>color</code> 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferGeometry</span>()<br><span class="hljs-keyword">const</span> position = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(parameter.<span class="hljs-property">count</span> * <span class="hljs-number">3</span>)<br><span class="hljs-keyword">const</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(parameter.<span class="hljs-property">count</span> * <span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; parameter.<span class="hljs-property">count</span> ; i++)&#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-comment">//color</span><br>    colors[i3] = <span class="hljs-number">1</span><br>    colors[i3] = <span class="hljs-number">0</span><br>    colors[i3] = <span class="hljs-number">0</span><br>    geometry.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;color&#x27;</span>, <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(colors, <span class="hljs-number">3</span>))<br>&#125;<br><br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/04/01/threejs-16-galaxy-generate/red.png" class="" width="400"> </div><p>然后分别给内部颜色与外部颜色建立 <code>Color</code> 实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">generateGalaxy</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span>  colorInside = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Color</span>(parameter.<span class="hljs-property">insideColor</span>)<br>    <span class="hljs-keyword">const</span>  colorOutside = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Color</span>(parameter.<span class="hljs-property">outColor</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>创建第三个 <code>Color</code> 实例，并使用 <code>lerp()</code>进行插值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> mixedColor = colorInside.<span class="hljs-title function_">clone</span>()  <span class="hljs-comment">//防止原色污染</span><br>mixedColor.<span class="hljs-title function_">lerp</span>(colorOutside, radius / parameters.<span class="hljs-property">radius</span>)<br><span class="hljs-comment">//...</span><br><span class="hljs-comment">//color</span><br>colors[i3] = mixedColor.<span class="hljs-property">r</span><br>colors[i3] = mixedColor.<span class="hljs-property">g</span><br>colors[i3] = mixedColor.<span class="hljs-property">b</span><br><br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/04/01/threejs-16-galaxy-generate/lerp.png" class="" width="400"> </div>]]></content>
    
    
    
    <tags>
      
      <tag>three.js</tag>
      
      <tag>web</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>threejs-15:particles</title>
    <link href="/2023/03/30/threejs-15-particles/"/>
    <url>/2023/03/30/threejs-15-particles/</url>
    
    <content type="html"><![CDATA[<h1 id="1-创建粒子"><a href="#1-创建粒子" class="headerlink" title="1.创建粒子"></a>1.创建粒子</h1><p>创建粒子就像创建一个 <code>Mesh</code> ，需要有 <strong>geometry(BufferGeometry)、material(PointsMaterial) 和 Points 实例(而不是一个 Mesh 实例)</strong></p><p>我们先创建一个 <strong>sphereBufferGeometry 和 PointsMaterial</strong>， <strong>geometry</strong>的每个坐标都会变成一个粒子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> particlesGeometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SphereBufferGeometry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>, <span class="hljs-number">32</span>)<br><span class="hljs-keyword">const</span> particlesMaterial = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointsMaterial</span>(&#123;<br>    <span class="hljs-attr">size</span>: <span class="hljs-number">0.02</span>,<br>    <span class="hljs-attr">sizeAttenuation</span>:<span class="hljs-literal">true</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> particles = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Points</span>(particlesGeometry, particlesMaterial)<br>scene.<span class="hljs-title function_">add</span>(particles)<br></code></pre></td></tr></table></figure><p>通过设置 <strong>PointsMaterial</strong> 的 <strong>size</strong> 属性改变粒子的大小。通过设置 <strong>sizeAttenuation</strong> 属性决定粒子的透视关系（是否通过摄像机与粒子的距离实现远大近小）</p><div align="center"> <img src="/2023/03/30/threejs-15-particles/spoints.png" class="" width="400"> <img src="/2023/03/30/threejs-15-particles/spoints2.png" class="" width="400"></div><h2 id="2-自定义坐标"><a href="#2-自定义坐标" class="headerlink" title="2.自定义坐标"></a>2.自定义坐标</h2><p>跟前几章一样，我们可以用 <strong>BufferGeometry</strong>上的 <strong>position</strong> 属性生成粒子,这些数据将会被送进gpu处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> particlesGeometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferGeometry</span>()<br><span class="hljs-keyword">const</span> count = <span class="hljs-number">500</span><br><br><span class="hljs-keyword">const</span> positions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(count * <span class="hljs-number">3</span>) <span class="hljs-comment">//坐标是三个一组（xyz)</span><br><br><span class="hljs-comment">//填充数组</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count * <span class="hljs-number">3</span>; i++)&#123;<br>    positions[i] = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span> ) * <span class="hljs-number">10</span><br>&#125;<br><br>particlesGeometry.<span class="hljs-title function_">setAttribute</span>(<br>    <span class="hljs-string">&#x27;position&#x27;</span>,<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(positions, <span class="hljs-number">3</span>)<br>)<br><span class="hljs-keyword">const</span> particlesMaterial = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointsMaterial</span>(&#123;<br>    <span class="hljs-attr">size</span>: <span class="hljs-number">0.02</span>,<br>    <span class="hljs-attr">sizeAttenuation</span>:<span class="hljs-literal">true</span><br>&#125;)<br><br><span class="hljs-keyword">const</span> particles = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Points</span>(particlesGeometry, particlesMaterial)<br>scene.<span class="hljs-title function_">add</span>(particles)<br></code></pre></td></tr></table></figure><p>效果如下。第二张图是 <code>positions[i] = Math.random()</code> 的效果</p><div align="center"> <img src="/2023/03/30/threejs-15-particles/dypoint.png" class="" width="400"> <img src="/2023/03/30/threejs-15-particles/dypo.png" class="" width="400"></div><h2 id="3-颜色"><a href="#3-颜色" class="headerlink" title="3.颜色"></a>3.颜色</h2><p>为粒子添加颜色只需改变材质的color属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">particlesMaterial.<span class="hljs-property">color</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Color</span>(<span class="hljs-string">&#x27;#ff88cc&#x27;</span>)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/30/threejs-15-particles/color.png" class="" width="400"></div><h2 id="3-材质"><a href="#3-材质" class="headerlink" title="3.材质"></a>3.材质</h2><p>我们同样可以给material添加材质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> textureLoader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>()<br><span class="hljs-keyword">const</span> particleTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/texture/particles/2.png&#x27;</span>)<br><br><span class="hljs-comment">//...</span><br>particlesMaterial.<span class="hljs-property">map</span> = particleTexture<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/30/threejs-15-particles/texture.png" class="" width="400"></div><div align="center"> <img src="/2023/03/30/threejs-15-particles/effect.png" class="" width="400"></div><p>要获取更多的粒子材质可以去 <a href="https://www.kenney.nl/">kenney</a> 处获取</p><p>当你仔细看前景的粒子时，会发现前景粒子会以矩形的形式遮挡后面的粒子不是不规则形状遮挡,且内部区域应当透明的地方没有透明。而，所以我们需要添加 alphaMap 来设定透明区域</p><div align="center"> <img src="/2023/03/30/threejs-15-particles/hidding.png" class="" width="400"></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">particlesMaterial.<span class="hljs-property">transparent</span> = <span class="hljs-literal">true</span><br>particlesMaterial.<span class="hljs-property">alphaMap</span> = particleTexture<br></code></pre></td></tr></table></figure><p>在使用透明贴图后仍会发现部分边缘区域会出现bug，这是因为创建粒子时他们重叠了导致的。解决方法也有很多</p><p>1.使用 <strong>alphatest</strong><br>alphatest 是一个从0到1的值，它让 webgl 根据像素的透明度，什么时候不应该渲染该像素。默认情况下它的值为0，意味着该像素永远都会被绘制<br>我们使用0.001来测试</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">particlesMaterial.<span class="hljs-property">alphaTest</span> = <span class="hljs-number">0.01</span><br></code></pre></td></tr></table></figure><p>设置 alphatest 后看起来效果好多了，但某些情况下任然会很怪。比如我们会在一个正方体中看见正方体后面的粒子</p><div align="center"> <img src="/2023/03/30/threejs-15-particles/alphatest.png" class="" width="400"> <img src="/2023/03/30/threejs-15-particles/cube.png" class="" width="400"></div><p>2.depth test</p><p>在three.js中，depth test是一个用于控制深度测试的属性。深度测试是一种用于检查像素深度信息的技术，以确定在渲染过程中哪些像素应该被渲染。当depth test属性被启用时，它会启用深度测试功能，这意味着每个像素的深度值将与深度缓冲区中的深度值进行比较。</p><p>深度测试通常使用一个叫做深度函数（depth function）的函数来控制。深度函数是一个用于比较像素深度和深度缓冲区中深度值的函数，通常有以下几种选项：</p><p>LESS：像素的深度值小于深度缓冲区中的深度值时通过深度测试。<br>LEQUAL：像素的深度值小于或等于深度缓冲区中的深度值时通过深度测试。<br>EQUAL：像素的深度值等于深度缓冲区中的深度值时通过深度测试。<br>GREATER：像素的深度值大于深度缓冲区中的深度值时通过深度测试。<br>GEQUAL：像素的深度值大于或等于深度缓冲区中的深度值时通过深度测试。<br>NOTEQUAL：像素的深度值不等于深度缓冲区中的深度值时通过深度测试。<br>ALWAYS：始终通过深度测试。<br>NEVER：始终不通过深度测试。<br>使用depth test属性，你可以控制在渲染过程中使用哪种深度函数进行深度测试。以下是一个设置深度测试属性的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123;<br>   <span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span>,<br>   <span class="hljs-attr">depthTest</span>: <span class="hljs-literal">true</span>,<br>   <span class="hljs-attr">depthFunc</span>: <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">LessEqualDepth</span>,<br>&#125;);<br><span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);<br>scene.<span class="hljs-title function_">add</span>(mesh);<br></code></pre></td></tr></table></figure><p>在这个例子中，depth test属性被设置为true，意味着将启用深度测试。depthFunc属性被设置为THREE.LessEqualDepth，意味着将使用小于等于深度缓冲区深度值的像素通过深度测试。<br>3.depth write<br>在three.js中，depth write是一个用于控制深度缓冲区写入的属性。深度缓冲区是一个特殊的缓冲区，用于存储每个像素的深度信息，它通常用于实现深度测试，以确定在渲染过程中哪些像素应该被渲染。</p><p>当depth write属性设置为true时，深度信息将被写入深度缓冲区，这意味着每个像素的深度值将被记录下来。当它设置为false时，深度信息将不会被写入深度缓冲区，而只会执行深度测试，以便根据需要渲染像素。这意味着在这种情况下，即使像素的深度测试通过，它们的深度信息也不会被写入深度缓冲区。</p><p>使用depth write属性可以在一定程度上控制three.js场景的深度行为，以实现更好的可视化效果。例如，在渲染半透明对象时，你可能想要禁用depth write属性，以便后面的对象能够正确地显示在前面的对象之上，从而实现透明效果。</p><p>——made by chatgpt</p><p>4.blending<br>Blending（混合）是three.js中一个用于控制物体混合透明度的属性。当两个或多个物体重叠时，混合可以使它们看起来更自然和逼真。</p><p>在three.js中，混合可以通过设置材质的blending属性来控制。blending属性是一个包含源混合因子和目标混合因子的数组，它们用于计算片段的颜色和alpha值，以便将其混合到场景中。</p><p>源混合因子（source blending factor）指定了如何混合当前片段的颜色和alpha值，而目标混合因子（destination blending factor）指定了如何混合已经在场景中的颜色和alpha值。</p><p>在three.js中，可以使用以下混合模式：</p><p>THREE.NoBlending: 不混合，即完全覆盖。<br>THREE.NormalBlending: 普通混合模式，即使用默认的混合因子。<br>THREE.AdditiveBlending: 加法混合模式，即将源和目标颜色相加。<br>THREE.SubtractiveBlending: 减法混合模式，即将源和目标颜色相减。<br>THREE.MultiplyBlending: 乘法混合模式，即将源和目标颜色相乘。<br>THREE.CustomBlending: 自定义混合模式，可以自己指定混合因子。<br>以下是一个使用混合的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123;<br>   <span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span>,<br>   <span class="hljs-attr">opacity</span>: <span class="hljs-number">0.5</span>,<br>   <span class="hljs-attr">transparent</span>: <span class="hljs-literal">true</span>,<br>   <span class="hljs-attr">blending</span>: <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">AdditiveBlending</span>,<br>&#125;);<br><span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material);<br>scene.<span class="hljs-title function_">add</span>(mesh);<br><br></code></pre></td></tr></table></figure><p>在这个例子中，材质的opacity属性被设置为0.5，使得物体半透明。transparent属性被设置为true，以启用透明度。blending属性被设置为THREE.AdditiveBlending，以使用加法混合模式。这将使场景中的物体看起来更加逼真和自然。</p><p>注意 使用blending会影响性能</p><div align="center"> <img src="/2023/03/30/threejs-15-particles/blending.png" class="" width="400"></div><h2 id="4-随机颜色"><a href="#4-随机颜色" class="headerlink" title="4.随机颜色"></a>4.随机颜色</h2><p>我们可以给每个粒子不同的颜色。通过添加 <strong>color</strong> 属性即可控制颜色。color 是一个 vector3 (r,g,b)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> position = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(count * <span class="hljs-number">3</span>)<br><span class="hljs-keyword">const</span> colors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Float32Array</span>(count * <span class="hljs-number">3</span>)<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count * <span class="hljs-number">3</span>; i++) &#123;<br>    positions[i] = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span> ) * <span class="hljs-number">10</span><br>    colors[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()<br>&#125;<br>particlesMaterial.<span class="hljs-property">vertexColors</span> = <span class="hljs-literal">true</span>   <span class="hljs-comment">//注意，需在此为粒子设置这个属性</span><br>particlesGeometry.<span class="hljs-title function_">setAttribute</span>(<br>    <span class="hljs-string">&#x27;position&#x27;</span>,<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(positions, <span class="hljs-number">3</span>)<br>)<br>particlesGeometry.<span class="hljs-title function_">setAttribute</span>(<br>    <span class="hljs-string">&#x27;color&#x27;</span>,<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(colors, <span class="hljs-number">3</span>)<br>)<br></code></pre></td></tr></table></figure><p>生成的vertex颜色会被 main material 的颜色影响，为了去除影响，我们可以注释掉这行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//particlesMaterial.color = new THREE.Color(&#x27;#ff88cc&#x27;)</span><br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/30/threejs-15-particles/colors.png" class="" width="400"> <img src="/2023/03/30/threejs-15-particles/color2.png" class="" width="400"></div><h2 id="5-制作动画"><a href="#5-制作动画" class="headerlink" title="5.制作动画"></a>5.制作动画</h2><p>为粒子制作动画的方式用很多种<br>1.将粒子作为 object 使用</p><p><strong>Points</strong> 类继承于 <strong>Object3D</strong> 类，所以我们可以移动，旋转，缩放粒子<br>例如，我们在 <strong>tick</strong> 函数里旋转粒子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">tick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> elapsedTime = clock.<span class="hljs-title function_">getElpasedTime</span>()<br>    <br>    particles.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> = elapsedTime * <span class="hljs-number">0.2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>2.改变 <strong>attributes</strong></p><p>我们可以改变 <code>particlesGeomerty.attributes.position.array</code> 每个粒子坐标的值操控粒子（每三个值代表一个）<br>接下来看一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">tick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">//...</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)&#123;<br>        <span class="hljs-keyword">const</span> i3 = i * <span class="hljs-number">3</span><br>        <span class="hljs-keyword">const</span> x = particlesGeometry.<span class="hljs-property">attributes</span>.<span class="hljs-property">position</span>.<span class="hljs-property">array</span>[i3]<br>        particlesGeometry.<span class="hljs-property">attributes</span>.<span class="hljs-property">position</span>.<span class="hljs-property">array</span>[i3 + <span class="hljs-number">1</span>] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(elapsedTime + x) <span class="hljs-comment">//改变y值</span><br>    &#125;<br>    particlesGeomerty.<span class="hljs-property">attributes</span>.<span class="hljs-property">position</span>.<span class="hljs-property">needsUpdate</span> = <span class="hljs-literal">true</span>    <span class="hljs-comment">//需要设置这个属性</span><br>&#125;<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/30/threejs-15-particles/i3.png" class="" width="400"></div>这样一来就可以看起sin波的粒子动画了。但是你应该避免这样实现动画，因为我们更新了上千个粒子，会造成电脑风扇狂转。这不是一个最佳的实现方案（使用shader）<div align="center"> <img src="/2023/03/30/threejs-15-particles/wave.png" class="" width="400"></div>]]></content>
    
    
    
    <tags>
      
      <tag>three.js</tag>
      
      <tag>web</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>three.js-14-Haunted-House</title>
    <link href="/2023/03/04/three-js-14-Haunted-House/"/>
    <url>/2023/03/04/three-js-14-Haunted-House/</url>
    
    <content type="html"><![CDATA[<p>在本节中，我们要造一个鬼屋。用Three.js的基本几何体。并以米作为基本单位</p><p>我们先建造基本场景：一个地板、一个球体、一些灯光、不必有阴影、一个Dat.GUI面板。<a href="https://threejs-journey.com/assets/lessons/16/17-haunted-house.zip">点击下载初始包</a></p><div align="center"> <img src="/2023/03/04/three-js-14-Haunted-House/basic.png" class="" width="600"> </div>然后我们把球体移除<h2 id="1-创建房子"><a href="#1-创建房子" class="headerlink" title="1.创建房子"></a>1.创建房子</h2><ol><li>建立房子我们先创建一个Group<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> house = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Group</span>()<br>scene.<span class="hljs-title function_">add</span>(house)<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-然后创建墙"><a href="#2-然后创建墙" class="headerlink" title="2. 然后创建墙"></a>2. 然后创建墙</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> walls = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxGeometry</span>(<span class="hljs-number">4</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">4</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#ac8e82&#x27;</span> &#125;)<br>)<br>walls.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = <span class="hljs-number">1.25</span> <span class="hljs-comment">//避免防止墙一半在地板下面</span><br>house.<span class="hljs-title function_">add</span>(walls)<br></code></pre></td></tr></table></figure><h2 id="3-创建一个房顶"><a href="#3-创建一个房顶" class="headerlink" title="3. 创建一个房顶"></a>3. 创建一个房顶</h2><p>我们使用 <strong>ConeBufferGeometry</strong> 。调整它的细分程度即可变为金字塔性质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> roof = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">ConeGeometry</span>(<span class="hljs-number">3.5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#b35f45&#x27;</span> &#125;)<br>)<br>roof.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">0.25</span><br>roof.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = <span class="hljs-number">2.5</span> + <span class="hljs-number">0.5</span><br>house.<span class="hljs-title function_">add</span>(roof)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/04/three-js-14-Haunted-House/roof.png" class="" width="600"> </div>## 4. 用平面创建一个门，并设置上材质<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> door = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneBufferGeometry</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123; <span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#aa7b7b&#x27;</span> &#125;)<br>)<br>door.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = <span class="hljs-number">1</span><br>door.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = <span class="hljs-number">2</span> + <span class="hljs-number">0.01</span> <span class="hljs-comment">//注意平面竞争（z-fighting</span><br>house.<span class="hljs-title function_">add</span>(door)<br></code></pre></td></tr></table></figure><h2 id="5-添加草丛"><a href="#5-添加草丛" class="headerlink" title="5. 添加草丛"></a>5. 添加草丛</h2><p>因为草丛都是一样的材质，形状。所以我们不是创建三个草丛几何体，而是创建三个网格</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bushGeometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SphereBufferGeometry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">16</span>, <span class="hljs-number">16</span>)<br><span class="hljs-keyword">const</span> bushMaterial = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123;<span class="hljs-attr">color</span>:<span class="hljs-string">&#x27;#89c854&#x27;</span>&#125;)<br><br><span class="hljs-keyword">const</span> bush1 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(bushGeometry, bushMaterial)<br>bush1.<span class="hljs-property">scale</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>)<br>bush1.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0.8</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">2.2</span>)<br><br><span class="hljs-keyword">const</span> bush2 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(bushGeometry, bushMaterial)<br>bush2.<span class="hljs-property">scale</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>)<br>bush2.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">1.4</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">2.1</span>)<br><br><span class="hljs-keyword">const</span> bush3 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(bushGeometry, bushMaterial)<br>bush3.<span class="hljs-property">scale</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0.4</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.4</span>)<br>bush3.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(- <span class="hljs-number">0.8</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">2.2</span>)<br><br><span class="hljs-keyword">const</span> bush4 = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(bushGeometry, bushMaterial)<br>bush4.<span class="hljs-property">scale</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0.15</span>, <span class="hljs-number">0.15</span>, <span class="hljs-number">0.15</span>)<br>bush4.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(- <span class="hljs-number">1</span>, <span class="hljs-number">0.05</span>, <span class="hljs-number">2.6</span>)<br>house.<span class="hljs-title function_">add</span>(bush1, bush2, bush3, bush4)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/04/three-js-14-Haunted-House/bush.png" class="" width="600"> </div><h2 id="6-添加坟墓"><a href="#6-添加坟墓" class="headerlink" title="6. 添加坟墓"></a>6. 添加坟墓</h2><p>手动生成大量的坟墓会很耗时，所以我们就自动的生成并防止坟墓</p><p>首先我们创建一个坟墓组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> graves = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Group</span>()<br>scene.<span class="hljs-title function_">add</span>(graves)<br><br><span class="hljs-keyword">const</span> graveGeometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxBufferGeometry</span>(<span class="hljs-number">0.6</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">0.2</span>)<br><span class="hljs-keyword">const</span> graveMaterial = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandarMaterial</span>(&#123;<span class="hljs-attr">color</span>: <span class="hljs-string">&#x27;#b2b6b1&#x27;</span>&#125;)<br><br><span class="hljs-comment">//范围内随机生成坟墓</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">50</span>; i++)&#123;<br>    <span class="hljs-keyword">const</span> angle = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-title class_">Math</span>.<span class="hljs-property">pi</span> * <span class="hljs-number">2</span>  <br>    <span class="hljs-keyword">const</span> radius = <span class="hljs-number">3</span> + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-number">6</span><br>    <span class="hljs-keyword">const</span> x = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(angle) * radius<br>    <span class="hljs-keyword">const</span> z = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(angle) * radius<br>    <br>    <span class="hljs-keyword">const</span> grave = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(graveGeometry, graveMaterial)<br>    grave.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(x, <span class="hljs-number">0.3</span>, z)<br>    graves.<span class="hljs-title function_">add</span>(grave)<br>&#125;<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/04/three-js-14-Haunted-House/graves.png" class="" width="600"> </div><p>然后增加点随机旋转</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//...</span><br>grave.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * <span class="hljs-number">1</span><br>grave.<span class="hljs-property">rotation</span>.<span class="hljs-property">z</span> = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/04/three-js-14-Haunted-House/rotate.png" class="" width="600"> </div><h2 id="7-灯光"><a href="#7-灯光" class="headerlink" title="7. 灯光"></a>7. 灯光</h2><p>然后调整灯光效果，并给一种蓝色的氛围色</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ambientLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AmbientLight</span>(<span class="hljs-string">&#x27;#b9d5ff&#x27;</span>, <span class="hljs-number">0.12</span>)<br><br><span class="hljs-comment">//...</span><br><br><span class="hljs-keyword">const</span> moonLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">DirectionalLight</span>(<span class="hljs-string">&#x27;#b9d5ff&#x27;</span>, <span class="hljs-number">0.12</span>)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/04/three-js-14-Haunted-House/dim.png" class="" width="600"> </div><p>然后给门加上点光源</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Door light</span><br><br><span class="hljs-keyword">const</span> doorLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointLight</span>(<span class="hljs-string">&#x27;ff7d46&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>)<br>doorLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">2.7</span>)<br>house.<span class="hljs-title function_">add</span>(doorLight)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/04/three-js-14-Haunted-House/pointlight.png" class="" width="600"> </div><h2 id="8-雾"><a href="#8-雾" class="headerlink" title="8.雾"></a>8.雾</h2><p>three.js提供了Fog类添加雾,要激活雾就在 <code>scene</code>上添加fog属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//Fog</span><br><span class="hljs-keyword">const</span> fog = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Fog</span>(<span class="hljs-string">&#x27;#ff0000&#x27;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>)<br>scene.<span class="hljs-property">fog</span> = fog<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/04/three-js-14-Haunted-House/fog.png" class="" width="600"> </div><p>雾有三个属性：</p><ul><li><p><strong>color</strong></p></li><li><p><strong>near</strong> ——雾距离相机的距离单位，开始的位置</p></li><li><p><strong>far</strong> ——雾完全透明的距离</p><p>调整一下颜色、近端和远端</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fog = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Fog</span>(<span class="hljs-string">&#x27;#262837&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">15</span>)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/04/three-js-14-Haunted-House/fogad.png" class="" width="600"> </div><p>当镜头推远时会发现背景有很强的违和感，我们需要改变<code>renderer</code>的 clearColor 和雾一样的颜色</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">renderer.<span class="hljs-title function_">setClearColor</span>(<span class="hljs-string">&#x27;#262837&#x27;</span>)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/04/three-js-14-Haunted-House/bg.png" class="" width="600"> </div><p>这样一来背景和雾的颜色就一样了</p><h2 id="9-添加材质"><a href="#9-添加材质" class="headerlink" title="9.添加材质"></a>9.添加材质</h2><p>添加所有的材质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> doorColorTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27; /textures/door/color.jpg&#x27;</span> )<br><span class="hljs-keyword">const</span> doorAlphaTexture = textureLoader.<span class="hljs-title function_">load</span>( <span class="hljs-string">&#x27; /textures/door/alpha.jpg&#x27;</span> )<br><span class="hljs-keyword">const</span> doorAmbdientocclusionTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/door/ambientOcclusion.jpg&#x27;</span>)<br><span class="hljs-keyword">const</span> doorHeightTexture = textureLoader.<span class="hljs-title function_">load</span>( <span class="hljs-string">&#x27;/textures/door/height.jpg&#x27;</span> )<br><span class="hljs-keyword">const</span> doorNormalTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/door/normal.jpg&#x27;</span>)<br><span class="hljs-keyword">const</span> doorMetalnessTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/door/metalness.jpg&#x27;</span>)<br><span class="hljs-keyword">const</span> doorRoughnessTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/door/roughness.jpg&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后将他们添加到door上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> door = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneBufferGeometry</span>(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandarMaterial</span>(&#123;<br>        <span class="hljs-attr">map</span>:doorColorTexture,<br>        <span class="hljs-attr">transparent</span>: ture,<br>        <span class="hljs-attr">alphaMap</span>: doorAlphaTexture,<br>        <span class="hljs-attr">aoMap</span>: doorAmbdientocclusionTexture,<br>        <span class="hljs-attr">displacementMap</span>: doorHeightTexture,<br>        <span class="hljs-attr">displaceMentScale</span>: <span class="hljs-number">0.1</span>,<br>        <span class="hljs-attr">normalMap</span>: doorNormalTexture,<br>        <span class="hljs-attr">metalnessMap</span>:doorMetalnessTexture,<br>        <span class="hljs-attr">roughnessMa</span>:doorRoughnessTexture<br>        <br>    &#125;)<br>)<br><br>door.<span class="hljs-property">geometry</span>.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;uv2&#x27;</span>, <br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Float32BufferAttribute</span>(door.<span class="hljs-property">geometry</span>.<span class="hljs-property">attributes</span>.<span class="hljs-property">uv</span>.<span class="hljs-property">arry</span>, <span class="hljs-number">2</span>)<br>)<br></code></pre></td></tr></table></figure><p>调整门的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//...</span><br><span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneBufferGeometry</span>(<span class="hljs-number">2.2</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/04/three-js-14-Haunted-House/door.png" class="" width="600"> </div><p>然后添加墙的材质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> bricksColorTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/bricks/color.jpg&#x27;</span>)<br><span class="hljs-keyword">const</span> bricksAmbientOcclusionTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/bricks/ambientOcclus,jpg&#x27;</span>)<br><span class="hljs-keyword">const</span> bricksNormalTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/bricks/normal.jpg&#x27;</span> )<br><span class="hljs-keyword">const</span> bricksRoughnessTexture = textureLoader.<span class="hljs-title function_">load</span>( <span class="hljs-string">&#x27;/textures/bricks/roughness.jpg&#x27;</span>)<br><br><span class="hljs-comment">/// Walls</span><br><br><span class="hljs-keyword">const</span> walls = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxBufferGeometry</span>(<span class="hljs-number">4</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">4</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandardMaterial</span>(&#123;<br>        <span class="hljs-attr">map</span>: bricksColorTexture,<br>        <span class="hljs-attr">aoMap</span>: bricksAmbientOcclusionTexture,<br>        <span class="hljs-attr">normalMap</span>:bricksNormalTexture,<br>        <span class="hljs-attr">roughnessMap</span>: bricksRoughnessTexture<br>    &#125;)<br>)<br><br>walls.<span class="hljs-property">geometry</span>.<span class="hljs-title function_">setAttribute</span>(<br>    <span class="hljs-string">&#x27;uv2&#x27;</span>,<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Float32BufferAttribute</span>(walls.<span class="hljs-property">geometry</span>.<span class="hljs-property">attributes</span>.<span class="hljs-property">uv</span>.<span class="hljs-property">arry</span>, <span class="hljs-number">2</span>)<br>)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/04/three-js-14-Haunted-House/wall.png" class="" width="600"> </div><p>给草添加材质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>three.js</tag>
      
      <tag>web</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>three.js-13:Shadow</title>
    <link href="/2023/03/02/three-js-13-Shadow/"/>
    <url>/2023/03/02/three-js-13-Shadow/</url>
    
    <content type="html"><![CDATA[<p>在添加光源后我们就可以看到物体上的明暗变化了，这个阴影实际叫做 <strong>core shadows</strong>，但是我们还没有投射到其他物体上的 <strong>drop shadow</strong>，本章将讲解如何获得 <strong>drop shadows</strong></p><p>光线追踪实际是个很耗费资源的计算，开发者需要用一些小技巧来增强视觉体验</p><p>Three.js 中实现阴影是在每一次渲染的时候会假设每一个光源上有个“相机”来计算哪个地方应该会有阴影，最后作为阴影texture贴在物体上。<br><a href="https://threejs.org/examples/?q=shadow#webgl_shadowmap_viewer">原理示例</a></p><div align="center"> <img src="/2023/03/02/three-js-13-Shadow/example.png" class="" width="600"> </div><p>Three.js实际上采用的就是 shadow map 技术实现阴影，它基于渲染场景时在某个点处拍摄的<strong>深度信息</strong>来确定光线的可见性，从而确定哪些物体会被遮挡，哪些物体应该被照亮。</p><p>Shadow map的大小决定了阴影的质量和分辨率。较大的阴影贴图能够提供更高分辨率的阴影，但也需要更多的GPU资源来渲染。过小的阴影贴图可能会导致阴影出现锯齿状，或者出现无法预期的阴影效果。</p><p>一般来说，选择阴影贴图的大小取决于场景的大小和需要达到的渲染质量。通常可以通过试验和测试来找到适合特定场景的最佳大小</p><h2 id="1-如何激活阴影"><a href="#1-如何激活阴影" class="headerlink" title="1.如何激活阴影"></a>1.如何激活阴影</h2><ol><li>在renderer上激活 shadow maps<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">renderer.<span class="hljs-property">shadowMap</span>.<span class="hljs-property">enabled</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>2.在Mesh上启用阴影。如果能投射阴影则启用<code>castShadow</code>,如果能接收阴影影响则启用<code>receiveShadow</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">sphere.<span class="hljs-property">castShadow</span> = <span class="hljs-literal">true</span><br><br>plane.<span class="hljs-property">receiveShadow</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><p>3.启动光源上的castShadow属性</p><p>注意，仅以下光源支持阴影</p><ul><li>PointLight</li><li>DirectionalLight</li><li>SpotLight</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">directionalLight.<span class="hljs-property">castShadow</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="2-优化阴影"><a href="#2-优化阴影" class="headerlink" title="2.优化阴影"></a>2.优化阴影</h2><p>下图就是默认的阴影效果了，可以看到非常不好看，所以我们需要优化阴影</p><div align="center"> <img src="/2023/03/02/three-js-13-Shadow/example.png" class="" width="400"> </div><p>我们可以通过光源的 <code>shadow</code> 属性来访问 shadow map</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(directionalLight.<span class="hljs-property">shadow</span>)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/02/three-js-13-Shadow/shadow.png" class="" width="400"> </div><p>默认情况下 shadow map大小是512x512的，我们可以将它增大。不过增大后当然会增加渲染压力，所以需要做好性能与视觉效果的平衡</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">directionalLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">mapSize</span>.<span class="hljs-property">width</span> = <span class="hljs-number">1024</span><br>directionalLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">mapSize</span>.<span class="hljs-property">height</span> = <span class="hljs-number">1024</span><br></code></pre></td></tr></table></figure><p>可以观察一下增大map分辨率后的效果：左图为512像素，右图为1024像素</p><div align="center"> <img src="/2023/03/02/three-js-13-Shadow/before.png" class="" width="400"> <img src="/2023/03/02/three-js-13-Shadow/after.png" class="" width="400"></div><p>在Three.js中，光源对象是可以具有camera属性的，这是因为一些光源需要像摄像机一样具有位置和方向，例如投影灯（SpotLight）和逐像素光（PointLight）。这些光源需要发射光线，以便根据场景中的物体计算阴影。</p><p>与摄像机类似，光源的位置和方向是在场景中进行计算的。如果光源的位置或方向发生变化，则必须更新光源的camera属性。这样，当场景被渲染时，Three.js可以在正确的位置和方向发射光线，并生成正确的阴影效果。</p><p>因此，虽然光源不是一个摄像机对象，但为了光源能够在正确的位置和方向发射光线，它需要具有camera属性。这个属性可以使光源与摄像机类似，具有位置和方向等属性，从而在场景中正确地渲染阴影效果。</p><p>我们可以通过 camera 属性访问光源的 camera 来调整shadow map，为了辅助我们调试，我们可以用 CameraHelper</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> directionalLightCamerHelper = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">CameraHelper</span>(directionalLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>)<br>scene.<span class="hljs-title function_">add</span>(directionalLightCamerHelper)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/02/three-js-13-Shadow/helper.png" class="" width="400"></div><p>调整一下近端(far)和远端(near)。<br>同样可以通过 top、right、bottom、left调整各个面的距离</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">directionalLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">near</span> = <span class="hljs-number">1</span><br>directionalLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">far</span> = <span class="hljs-number">6</span><br><br>directionalLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">top</span> = <span class="hljs-number">2</span><br>directionalLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">left</span> = <span class="hljs-number">2</span><br>directionalLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">right</span> = <span class="hljs-number">2</span><br>directionalLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">bottom</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>我们可以用visible隐藏helper</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">directionalLightCameraHelper.<span class="hljs-property">visible</span> = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>调整阴影模糊通过改变 radius 的值来改变模糊半径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">directionalLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">radius</span> = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>这种模糊只是在阴影上面模糊，并没有根据物体与物体、光线之间的距离确定模糊效果</p><h2 id="3-阴影贴图算法"><a href="#3-阴影贴图算法" class="headerlink" title="3.阴影贴图算法"></a>3.阴影贴图算法</h2><ul><li>THREE.BasicShadowMap: 效率高，但是质量低。会出现锯齿状边缘</li><li>THREE.PCFShadowMap：效率低，阴影质量和平滑度提高。（默认）</li><li>THREE.PCFSoftShadowMap</li><li>THREE.VSMShadowMap: 该算法使用两个深度图像素，一个用于存储平均深度，另一个用于存储深度方差。通过使用深度方差来计算阴影强度，可以提高阴影质量和平滑度。</li></ul><p>应用阴影贴图属性通过设置renderer.shaodwMap.type属性改变。使用PCFSoftShadowMap算法时，radius会失效</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">renderer.<span class="hljs-property">shaodwMap</span>.<span class="hljs-property">type</span> = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">PCFSoftShadowMap</span><br></code></pre></td></tr></table></figure><h2 id="4-SPOTLIGHT"><a href="#4-SPOTLIGHT" class="headerlink" title="4.SPOTLIGHT"></a>4.SPOTLIGHT</h2><p>讲解完以DirectionalLight为例的阴影。接下来以SPOTLIGHT为例解说阴影</p><p>先创建一个SPOTLIGHT</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> spotLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SpotLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">10</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">0.3</span>)<br><br>spotLight.<span class="hljs-property">castShadow</span> = <span class="hljs-literal">true</span><br><br>spotLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br><br>scene.<span class="hljs-title function_">add</span>(spotLight)<br>scene.<span class="hljs-title function_">add</span>(spotLight.<span class="hljs-property">target</span>)<br><span class="hljs-comment">//添加helper</span><br><span class="hljs-keyword">const</span> spotLightCameraHelper = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">CameraHelper</span>(spotLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>)<br>scene.<span class="hljs-title function_">add</span>(spotLightCameraHelper)<br><br><span class="hljs-comment">//降低其他灯光的亮度</span><br><br><span class="hljs-keyword">const</span> ambientLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AmbitenLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">0.4</span>)<br><br><span class="hljs-keyword">const</span> directionalLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title function_">directionalLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">0.4</span>)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/02/three-js-13-Shadow/spotlight.png" class="" width="400"></div><p>可以看出几个灯光混合出来的阴影和现实世界的并不相符，但起码有阴影了（</p><p>SpotLight会使用透视相机生成阴影，所以我们可以改变相机的fov来影响阴影。</p><p>同样也可以调整相机的 near 和 far</p><p>隐藏helper</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">spotLight.<span class="hljs-property">shadow</span>.<span class="hljs-property">camera</span>.<span class="hljs-property">fov</span> = <span class="hljs-number">30</span><br></code></pre></td></tr></table></figure><h2 id="5-PointLight"><a href="#5-PointLight" class="headerlink" title="5.PointLight"></a>5.PointLight</h2><p>第三个支持阴影的就是 pointlight, 我们再添加一个PointLight</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> pointLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title function_">pointLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">0.3</span>)<br><br>pointLight.<span class="hljs-property">castShadow</span> = <span class="hljs-literal">true</span><br><br>spotLight.<span class="hljs-property">position</span>.<span class="hljs-title function_">set</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br><br>scene.<span class="hljs-title function_">add</span>(spotLight)<br><br></code></pre></td></tr></table></figure><p>能设置的东西都差不多，懒得写了</p><p>如果你给PointLight的camera添加了helper会看见一个朝向一个方向的透视相机，看起来很不合理。实际上PointLight的camera已经完成了六个方向的阴影生成，我们看见的camera朝向仅是最后一步</p><p>注意，点光源需要渲染生成周围所有的阴影。所以它的camera不能设置fov</p><h2 id="6-Baking-shadow"><a href="#6-Baking-shadow" class="headerlink" title="6.Baking shadow"></a>6.Baking shadow</h2><p>如果你有很多光源，需要生成一个好看的阴影，GPU是个挑战，所以我们需要烘焙阴影来减少GPU的负担。我们将来看一个使用烘焙阴影的例子。</p><p>首先关闭渲染器生成阴影贴图</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">renderer.<span class="hljs-property">shadowMap</span>.<span class="hljs-property">enabled</span> = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>然后使用这张在blender生成的材质，要使用这张材质，我们要先加载</p><div align="center"> <img src="/2023/03/02/three-js-13-Shadow/bakedShadow.jpg" class="" width="600"></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//加载shadow</span><br><span class="hljs-keyword">const</span> textureLoader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>()<br><span class="hljs-keyword">const</span> bakedShadow = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/bakedShadow.jpg&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后用 MeshBasicMaterial 代替平面上的 MeshStandarMaterial。并加载材质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> plane = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneBufferGeometry</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123;<br>        <span class="hljs-attr">map</span>: bakedShadow<br>    &#125;)<br>)<br></code></pre></td></tr></table></figure><p>然后你就能看见比较好看的阴影效果了，但注意因为是贴图所以移动球体后阴影并不会产生变化</p><div align="center"> <img src="/2023/03/02/three-js-13-Shadow/baked.png" class="" width="400"> <img src="/2023/03/02/three-js-13-Shadow/posi.png" class="" width="400"></div><p>为了解决动态问题，我们可以在平面上创建一个小的平面，然后跟着球体运动</p><p>我们用这张阴影，来实现当球体移动的时候，阴影也随之移动。当球体上升时将阴影透明度降低</p><div align="center"> <img src="/2023/03/02/three-js-13-Shadow/simpleShadow.jpg" class="" width="400"></div>首先使用 MeshStandarMaterial 放回去，我们将simpleShadow应用在alpha贴图上<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">///...load simpleShadow</span><br><span class="hljs-keyword">const</span> sphereShadow = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneBufferGeometry</span>(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshStandarMaterial</span>(&#123;<br>        <span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span>,<br>        <span class="hljs-comment">//transparent: true,</span><br>        <span class="hljs-attr">alphaMap</span>: simpleShadow<br>    &#125;)<br>)<br><br>sphereShadow.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> = - <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span> * <span class="hljs-number">0.5</span><br><br>scene.<span class="hljs-title function_">add</span>(sphereShadow,)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/02/three-js-13-Shadow/sphere.png" class="" width="400"></div><p>然后就可以看到这个鬼样子，并且会产生plane与sphere层叠打架的问题,所以我们需要移动一下sphereShadow</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">sphereShadow.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = plane.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> + <span class="hljs-number">0.01</span><br></code></pre></td></tr></table></figure><p>然后将transparent的注释取消掉，并将color变成黑色，就可以得到一个比较好看的阴影了</p><div align="center"> <img src="/2023/03/02/three-js-13-Shadow/perfect.png" class="" width="400"></div><p>然后我们让球体动起来,转着圈跳动。并让阴影跟随</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> clock = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Clock</span>() <br><span class="hljs-keyword">const</span> <span class="hljs-title function_">tick</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> elapsedTime = clock.<span class="hljs-title function_">getElapsedTime</span>()<br>    <br>    <span class="hljs-comment">//update sphere</span><br>    sphere.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">cos</span>(elapsedTime) * <span class="hljs-number">1.5</span><br>    sphere.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(elapsedTime) * <span class="hljs-number">1.5</span><br>    sphere.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">sin</span>(elapsedTime * <span class="hljs-number">3</span>))<br>    <br>    <span class="hljs-comment">//update shadow</span><br>    sphereShadow.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = sphere.<span class="hljs-property">position</span>.<span class="hljs-property">x</span><br>    sphereShadow.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = shpere.<span class="hljs-property">position</span>.<span class="hljs-property">z</span><br>    sphereShadow.<span class="hljs-property">material</span>.<span class="hljs-property">opacity</span> = (<span class="hljs-number">1</span> - <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(sphere.<span class="hljs-property">position</span>.<span class="hljs-property">y</span>)) * <span class="hljs-number">0.3</span><br>&#125;<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/03/02/three-js-13-Shadow/follow2.png" class="" width="400"> <img src="/2023/03/02/three-js-13-Shadow/fllow.png" class="" width="400"></div>]]></content>
    
    
    
    <tags>
      
      <tag>three.js</tag>
      
      <tag>web</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12threejs:light</title>
    <link href="/2023/03/01/12threejs-light/"/>
    <url>/2023/03/01/12threejs-light/</url>
    
    <content type="html"><![CDATA[<p>增加与上个文章相同的场景</p><div align="center"> <img src="/2023/03/01/12threejs-light/scene.png" class="" width="400"> </div>然后删除 AmbientLight 和 PointLight，当你移除灯光后会发现场景 **一片漆黑**，是因为 **MeshStandarMaterial** 需要灯光才能看见物体<h2 id="1-AmbientLight"><a href="#1-AmbientLight" class="headerlink" title="1.AmbientLight"></a>1.AmbientLight</h2><p><strong>AmbientLight</strong> 应用了 Omni-directional lighting 效果，照来的灯光，所有面光照效果相同。没有阴影明暗灰度灯光反射变化</p><p><strong>AmbientLight具有两个属性</strong></p><ul><li><strong>color</strong></li><li><strong>intensity</strong></li></ul><blockquote><p>注意添加灯光后需要将灯光添加到场景中</p></blockquote><div align="center"> <img src="/2023/03/01/12threejs-light/ambient.png" class="" width="400"> </div><h2 id="2-DirectionalLight"><a href="#2-DirectionalLight" class="headerlink" title="2.DirectionalLight"></a>2.DirectionalLight</h2><p><strong>DirectionalLight</strong> 会模拟太阳光照效果（平行光）</p><p>它也有两个属性：<strong>color</strong> 和 <strong>intensity</strong></p><div align="center"> <img src="/2023/03/01/12threejs-light/direc.png" class="" width="400"> </div><p>方向性光源的光会使得物体在灯光下有了明暗阴影变化。DirectionalLight 的方向是从光源位置指向世界坐标原点的</p><blockquote><p>灯光的距离不会引起明暗阴影变化</p></blockquote><h2 id="3-HemisphereLight"><a href="#3-HemisphereLight" class="headerlink" title="3.HemisphereLight"></a>3.HemisphereLight</h2><p>HemisphereLight 与 AmbientLight类似。但比后者多了 groundColor 属性，这个光代表从<strong>地面</strong>射出来的光</p><div align="center"> <img src="/2023/03/01/12threejs-light/hemi.png" class="" width="400"> </div><p><strong>HeimisphereLight</strong> 三个属性</p><ul><li>color(skyColor)</li><li>groundColor</li><li>intensity</li></ul><div align="center"> <img src="/2023/03/01/12threejs-light/hemilight.png" class="" width="400"> </div><h2 id="4-Point-Light"><a href="#4-Point-Light" class="headerlink" title="4.Point Light"></a>4.Point Light</h2><p>PointLight 最接近现实灯光的照射效果。同时也比较费性能</p><div align="center"> <img src="/2023/03/01/12threejs-light/pointLight.png" class="" width="400"> </div><p>点光源会从一个光源发射光线，使得物体拥有明暗变化。它继承于 Object3D 对象，可以移动位置</p><p>默认情况下，光强不会随着距离衰减。我们可以通过 distance 和 decay 属性控制光线衰减效果。在 distance 距离内，光线强度一样。在distance距离之外，会以decay为单位开始衰减</p><h2 id="5-Rect-Area-Light"><a href="#5-Rect-Area-Light" class="headerlink" title="5.Rect Area Light"></a>5.Rect Area Light</h2><p><strong>Rect Area Light</strong> 会像摄影灯光一样在一个矩形内发光。它是方向性光源(directional Light)与漫射光(diffuse light)的混合</p><div align="center"> <img src="/2023/03/01/12threejs-light/rect.png" class="" title="Rect2.png 400"> </div><p><strong>Rect Area Light</strong> 具有以下属性</p><ul><li>color</li><li>intensity</li><li>width</li><li>height</li></ul><p>RectAreaLight 仅对 MeshStandardMaterial 和 MeshPhysicalMaterial 有效</p><p>你可以旋转或移动 RectAreaLight。也可以用 lookAt(…) 使灯光朝向某个物体</p><h2 id="6-SpotLight"><a href="#6-SpotLight" class="headerlink" title="6.SpotLight"></a>6.SpotLight</h2><p>SpotLight 像一个手电筒，它会形成一个光锥照射物体。具有以下属性</p><ul><li>color</li><li>intensity</li><li>distance</li><li>angle</li><li>penumbra</li><li>decay</li></ul><p>angle 是灯光照射范围，penumbra控制灯光边缘模糊程度，如果为0则会很尖锐</p><div align="center"> <img src="/2023/03/01/12threejs-light/spot.png" class="" width="400"> </div><p>如果需要旋转 SpotLight，我没需要添加一个 target 属性在场景中，然后移动它。SpotLight 会朝向 target(Object3D)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">scene.<span class="hljs-title function_">add</span>(spotLight.<span class="hljs-property">target</span>)<br>spotLight.<span class="hljs-property">target</span>.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = -<span class="hljs-number">0.75</span><br></code></pre></td></tr></table></figure><p>灯光都会耗费很多的性能，所以确保场景中只有尽可能少的灯光。</p><p><strong>最少性能消耗的灯光：</strong></p><ul><li>AmbientLight</li><li>HemisphereLight<br><strong>中等程度消耗的灯光：</strong></li><li>DirectionalLight</li><li>PointLight<br><strong>最耗性能的灯光：</strong></li><li>SpotLight</li><li>RectAreaLight</li></ul><h2 id="7-BAKING"><a href="#7-BAKING" class="headerlink" title="7.BAKING"></a>7.BAKING</h2><p>当需要很多的灯光效果时可以采用烘焙技术减少性能消耗。这个效果可以在3D软件中实现。</p><p>这样做的缺点就是我没不能移动灯光，而且要加载很多很大的材质</p><h2 id="8-helpher"><a href="#8-helpher" class="headerlink" title="8.helpher"></a>8.helpher</h2><p>定位灯光可以采用helper辅助我们调整灯光效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hemisphereLightHelper = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">HemisphereLightHelper</span>(hemisphereLight, <span class="hljs-number">0.2</span>)<br>scene.<span class="hljs-title function_">add</span>(hemisphereLightHelper)<br></code></pre></td></tr></table></figure><blockquote><p>SpotLightHelper 没有 <code>size</code> ，当我没改变了target的位置后需要在下一帧之前调用 update(…)函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> spotLightHelper = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SpotLightHelper</span>(spotLight)<br>scene.<span class="hljs-title function_">add</span>(spotLightHelper)<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    spotLightHelper.<span class="hljs-title function_">update</span>()<br>&#125;)<br></code></pre></td></tr></table></figure><p>RectAreaLightHelper 不是THREE变量下的一个成员，所以我们需要导入它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">RectAreaLightHelper</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/examples/jsm/helpers/RectAreaLightHelper.js &#x27;</span><br></code></pre></td></tr></table></figure><p>导入后还需要手动的更新 position 和 rotation 属性，并调用 update函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>    rectAreaLightHelper.<span class="hljs-property">position</span>.<span class="hljs-title function_">copy</span>(rectAreaLight.<span class="hljs-property">position</span>)<br>    rectAreaLightHelper.<span class="hljs-property">quaternion</span>.<span class="hljs-title function_">copy</span>(rectAreaLight.<span class="hljs-property">quaternion</span>)<br>    rectAreaLightHelper.<span class="hljs-title function_">update</span>()<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>three.js</tag>
      
      <tag>web</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用decorator优雅管理electron-Ipc池</title>
    <link href="/2023/02/25/%E4%BD%BF%E7%94%A8decorator%E4%BC%98%E9%9B%85%E7%AE%A1%E7%90%86electron-Ipc%E6%B1%A0/"/>
    <url>/2023/02/25/%E4%BD%BF%E7%94%A8decorator%E4%BC%98%E9%9B%85%E7%AE%A1%E7%90%86electron-Ipc%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="使用decorator优雅管理electron-Ipc池"><a href="#使用decorator优雅管理electron-Ipc池" class="headerlink" title="使用decorator优雅管理electron-Ipc池"></a>使用decorator优雅管理electron-Ipc池</h1><p>在这篇文章中，我们将系统地介绍 TypeScript 中装饰器的基础与实践，重点聚焦于类装饰器（Class Decorators）和方法装饰器（Method Decorators）的使用；然后深入剖析在 Electron 应用中开展 IPC（进程间通信）的两种典型模式——单向通信和双向通信；接着结合装饰器模式，展示如何用装饰器管理 IPC 回调，使代码更具可维护性；最后分享一种进阶方案，通过自动化地加载所有 IPC 处理器文件，实现零耦合的模块化注册。全文共计四大部分，附带丰富代码示例，助你快速掌握装饰器+IPC 的最佳实践。</p><hr><h2 id="✨-1-Decorator-简介"><a href="#✨-1-Decorator-简介" class="headerlink" title="✨ 1. Decorator 简介"></a>✨ 1. Decorator 简介</h2><p>在 TypeScript 中，装饰器（Decorator）是一种特殊的声明形式，可附加到类、方法、访问器、属性或参数上，用于在运行时观察、修改或替换对应的声明。使用装饰器时，需要开启实验性支持，并了解可用的装饰器类型。</p><ul><li><p><strong>启用实验性支持</strong></p><p>  要使用装饰器，必须在编译时打开 <code>experimentalDecorators</code> 选项。可以在命令行直接添加 <code>--experimentalDecorators</code> 标志：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tsc --experimentalDecorators your-file.ts<br><br></code></pre></td></tr></table></figure><p>  或者在 <code>tsconfig.json</code> 中配置：</p>  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;compilerOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;experimentalDecorators&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br><br></code></pre></td></tr></table></figure><p>  (<a href="https://www.typescriptlang.org/tsconfig/experimentalDecorators.html?utm_source=chatgpt.com">TSConfig Option: experimentalDecorators - TypeScript</a>, <a href="https://www.geeksforgeeks.org/how-to-enable-decorators-in-typescript-via-command-line/?utm_source=chatgpt.com">How to Enable Decorators in TypeScript via Command Line</a>)</p></li><li><p><strong>装饰器的五种类型</strong></p><p>  TypeScript 支持以下五种装饰器：</p><ol><li><p>Class Decorators</p></li><li><p>Method Decorators</p></li><li><p>Accessor Decorators（访问器装饰器）</p></li><li><p>Property Decorators</p></li><li><p>Parameter Decorators</p><p> 本文将重点介绍前两种，其他类型可参考官方手册。</p><p> (<a href="https://www.typescriptlang.org/docs/handbook/decorators.html?utm_source=chatgpt.com">Documentation - Decorators - TypeScript</a>)</p></li></ol></li></ul><hr><h3 id="🎯-1-1-Class-Decorators"><a href="#🎯-1-1-Class-Decorators" class="headerlink" title="🎯 1.1 Class Decorators"></a>🎯 1.1 Class Decorators</h3><ul><li><p><strong>定义</strong></p><p>  类装饰器声明在类定义之前，其函数会在运行时接收该类的构造函数作为唯一参数。可以用于观察、修改或替换类定义。</p>  <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sealed</span>(<span class="hljs-params"><span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Function</span></span>) &#123;<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(constructor);<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">seal</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>&#125;<br><br><span class="hljs-meta">@sealed</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123; &#125;<br><br></code></pre></td></tr></table></figure><p>  (<a href="https://www.typescriptlang.org/docs/handbook/decorators.html?utm_source=chatgpt.com">Documentation - Decorators - TypeScript</a>)</p></li><li><p><strong>签名</strong></p>  <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassDecorator</span> = &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>&gt;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">constructor</span>: T</span>) =&gt;</span> T | <span class="hljs-built_in">void</span>;<br><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="🛠️-1-2-Method-Decorators"><a href="#🛠️-1-2-Method-Decorators" class="headerlink" title="🛠️ 1.2 Method Decorators"></a>🛠️ 1.2 Method Decorators</h3><ul><li><p><strong>定义</strong></p><p>  方法装饰器声明在方法定义之前，其函数会在运行时接收三个参数：目标对象、方法名和属性描述符，可用于包装或修改方法行为。</p>  <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params"></span><br><span class="hljs-params">  <span class="hljs-attr">target</span>: <span class="hljs-title class_">Object</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span>,</span><br><span class="hljs-params">  <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span><br><span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> original = descriptor.<span class="hljs-property">value</span>;<br>  descriptor.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Calling <span class="hljs-subst">$&#123;propertyKey&#125;</span>:`</span>, args);<br>    <span class="hljs-keyword">return</span> original.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-meta">@log</span><br>  <span class="hljs-title function_">greet</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>  (<a href="https://www.typescriptlang.org/docs/handbook/decorators.html?utm_source=chatgpt.com">Documentation - Decorators - TypeScript</a>)</p></li><li><p><strong>签名</strong></p>  <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">type</span> <span class="hljs-title class_">MethodDecorator</span> = <span class="hljs-function">(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-attr">target</span>: <span class="hljs-title class_">Object</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>) =&gt;</span> <span class="hljs-title class_">PropertyDescriptor</span> | <span class="hljs-built_in">void</span>;<br><br></code></pre></td></tr></table></figure></li></ul><hr><h2 id="🚀-2-IPC-通信"><a href="#🚀-2-IPC-通信" class="headerlink" title="🚀 2. IPC 通信"></a>🚀 2. IPC 通信</h2><p>在 Electron 中，主进程（Main）和渲染进程（Renderer）通过 <code>ipcMain</code> 与 <code>ipcRenderer</code> 模块在开发者自定义的“通道”上交换消息。以下介绍两种常见模式。</p><h3 id="🔸-2-1-单向通信"><a href="#🔸-2-1-单向通信" class="headerlink" title="🔸 2.1 单向通信"></a>🔸 2.1 单向通信</h3><p>渲染进程向主进程发送消息，主进程使用事件监听接收：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// Renderer 进程</span><br><span class="hljs-keyword">import</span> &#123; ipcRenderer &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;electron&#x27;</span>;<br>ipcRenderer.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;set-title&#x27;</span>, <span class="hljs-string">&#x27;新窗口标题&#x27;</span>);<br><br><span class="hljs-comment">// Main 进程</span><br><span class="hljs-keyword">import</span> &#123; app, <span class="hljs-title class_">BrowserWindow</span>, ipcMain &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;electron&#x27;</span>;<br>ipcMain.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;set-title&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, title</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> win = <span class="hljs-title class_">BrowserWindow</span>.<span class="hljs-title function_">fromWebContents</span>(event.<span class="hljs-property">sender</span>);<br>  win?.<span class="hljs-title function_">setTitle</span>(title);<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>(<a href="https://electronjs.org/docs/latest/tutorial/ipc?utm_source=chatgpt.com">Inter-Process Communication - Electron</a>)</p><h3 id="🔹-2-2-双向通信"><a href="#🔹-2-2-双向通信" class="headerlink" title="🔹 2.2 双向通信"></a>🔹 2.2 双向通信</h3><h3 id="异步请求-响应（推荐）"><a href="#异步请求-响应（推荐）" class="headerlink" title="异步请求&#x2F;响应（推荐）"></a>异步请求&#x2F;响应（推荐）</h3><p>使用 <code>invoke</code>&#x2F;<code>handle</code> 实现 Promise 风格的双向通信：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// Renderer</span><br><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> ipcRenderer.<span class="hljs-title function_">invoke</span>(<span class="hljs-string">&#x27;compute&#x27;</span>, <span class="hljs-number">42</span>);<br><br><span class="hljs-comment">// Main</span><br>ipcMain.<span class="hljs-title function_">handle</span>(<span class="hljs-string">&#x27;compute&#x27;</span>, <span class="hljs-title function_">async</span> (event, value) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> value * value;<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>(<a href="https://electronjs.org/docs/latest/api/ipc-renderer?utm_source=chatgpt.com">ipcRenderer - Electron</a>)</p><h3 id="同步请求-响应（慎用）"><a href="#同步请求-响应（慎用）" class="headerlink" title="同步请求&#x2F;响应（慎用）"></a>同步请求&#x2F;响应（慎用）</h3><p>使用 <code>sendSync</code> 与 <code>event.returnValue</code>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// Renderer</span><br><span class="hljs-keyword">const</span> result = ipcRenderer.<span class="hljs-title function_">sendSync</span>(<span class="hljs-string">&#x27;sync-compute&#x27;</span>, <span class="hljs-number">7</span>);<br><br><span class="hljs-comment">// Main</span><br>ipcMain.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;sync-compute&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event, value</span>) =&gt;</span> &#123;<br>  event.<span class="hljs-property">returnValue</span> = value + <span class="hljs-number">1</span>;<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>(<a href="https://electronjs.org/docs/latest/api/ipc-main?utm_source=chatgpt.com">ipcMain - Electron</a>)</p><hr><h2 id="🎯-3-使用-Decorator-管理-IPC"><a href="#🎯-3-使用-Decorator-管理-IPC" class="headerlink" title="🎯 3. 使用 Decorator 管理 IPC"></a>🎯 3. 使用 Decorator 管理 IPC</h2><p>为了让 IPC 处理逻辑与业务方法解耦，可以用装饰器将通道名与方法绑定，并在类实例化时统一注册。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;reflect-metadata&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; ipcMain, <span class="hljs-title class_">IpcMainEvent</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;electron&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">IPC_LISTENER</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;ipc_listener&#x27;</span>);<br><br><span class="hljs-comment">// 方法装饰器：标记方法对应的通道</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">IpcListener</span>(<span class="hljs-params"><span class="hljs-attr">channel</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span></span>) =&gt;</span> &#123;<br>    <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineMetadata</span>(<span class="hljs-variable constant_">IPC_LISTENER</span>, channel, target, key);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 类装饰器：扫描并注册所有标记的方法</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">IpcController</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &lt;T <span class="hljs-keyword">extends</span> &#123; <span class="hljs-title function_">new</span>(...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]): &#123;&#125; &#125;&gt;<span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">constructor</span>: T</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>);<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">method</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">const</span> <span class="hljs-attr">channel</span>: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span> = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<br>        <span class="hljs-variable constant_">IPC_LISTENER</span>,<br>        constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,<br>        method<br>      );<br>      <span class="hljs-keyword">if</span> (channel) &#123;<br>        ipcMain.<span class="hljs-title function_">on</span>(channel, <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-title class_">IpcMainEvent</span>, ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) =&gt;</span> &#123;<br>          (instance <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>)[method](event, ...args);<br>        &#125;);<br>      &#125;<br>    &#125;);<br>  &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-meta">@IpcController</span>()<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Handlers</span> &#123;<br>  <span class="hljs-meta">@IpcListener</span>(<span class="hljs-string">&#x27;ping&#x27;</span>)<br>  <span class="hljs-title function_">onPing</span>(<span class="hljs-params"><span class="hljs-attr">event</span>: <span class="hljs-title class_">IpcMainEvent</span></span>) &#123;<br>    event.<span class="hljs-title function_">reply</span>(<span class="hljs-string">&#x27;pong&#x27;</span>, <span class="hljs-string">&#x27;pong 响应&#x27;</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li>装饰器工厂原理参考 TS 官方文档 (<a href="https://www.typescriptlang.org/docs/handbook/decorators.html?utm_source=chatgpt.com">Documentation - Decorators - TypeScript</a>)</li><li>元数据功能需启用 <code>emitDecoratorMetadata</code> 并引入 <code>reflect-metadata</code> 库 (<a href="https://www.typescriptlang.org/docs/handbook/decorators.html?utm_source=chatgpt.com">Documentation - Decorators - TypeScript</a>)</li><li>关于装饰器元数据在 TS 5.2 中的更新 (<a href="https://github.com/typeorm/typeorm/issues/10869">Instead of experimental decorators use the full version of decorators introduced in TS 5.0 · Issue #10869 · typeorm&#x2F;typeorm · GitHub</a>)</li></ul><hr><h2 id="🌟-4-进阶：自动加载-Ipc-handler"><a href="#🌟-4-进阶：自动加载-Ipc-handler" class="headerlink" title="🌟 4. 进阶：自动加载 Ipc handler"></a>🌟 4. 进阶：自动加载 Ipc handler</h2><p>在大型项目中，手动导入每个处理器类非常繁琐。可利用构建工具功能自动遍历指定目录，导入所有文件，从而触发装饰器注册：</p><blockquote><p>Vite + TypeScript</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-comment">// src/main.ts</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;reflect-metadata&#x27;</span>;<br><span class="hljs-comment">// 自动导入 handlers 目录下的所有模块（eager: true 强制立即执行）</span><br><span class="hljs-keyword">const</span> modules = <span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-title function_">glob</span>(<span class="hljs-string">&#x27;./handlers/*.ts&#x27;</span>, &#123; <span class="hljs-attr">eager</span>: <span class="hljs-literal">true</span> &#125;);<br><span class="hljs-comment">// 仅需导入，装饰器在模块加载时即刻注册</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(modules);<br><br></code></pre></td></tr></table></figure><p>(<a href="https://vite.dev/guide/features?utm_source=chatgpt.com">Features | Vite</a>)</p></blockquote><blockquote><p>Webpack (require.context)</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">const</span> context = <span class="hljs-built_in">require</span>.<span class="hljs-title function_">context</span>(<span class="hljs-string">&#x27;./handlers&#x27;</span>, <span class="hljs-literal">false</span>, <span class="hljs-regexp">/\.ts$/</span>);<br>context.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">forEach</span>(context);<br><br></code></pre></td></tr></table></figure></blockquote><p>如此一来，无论后续新增多少 Handler 文件，都无需在入口显式引入，即可实现零维护的 IPC 注册机制。</p><p>在这一补充部分中，我们将从更深入的角度剖析类装饰器（Class Decorators）与方法装饰器（Method Decorators）的高级用法和实践细节，涵盖装饰器工厂的参数化、构造函数替换、Mixin 混入、元数据注入，以及方法装饰器的参数化、静态 vs 原型方法、装饰器链执行顺序和描述符自定义等内容，帮助你在实际项目中灵活运用这两类装饰器。</p><hr><h2 id="深入-Class-Decorators"><a href="#深入-Class-Decorators" class="headerlink" title="深入 Class Decorators"></a>深入 Class Decorators</h2><h3 id="1-装饰器工厂：参数化定义"><a href="#1-装饰器工厂：参数化定义" class="headerlink" title="1. 装饰器工厂：参数化定义"></a>1. 装饰器工厂：参数化定义</h3><p>类装饰器不仅可以是一个简单函数，还可通过“装饰器工厂”接收参数，以便在不同场景下定制行为。 (<a href="https://blog.logrocket.com/practical-guide-typescript-decorators/?utm_source=chatgpt.com">A practical guide to TypeScript decorators - LogRocket Blog</a>)</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Entity</span>(<span class="hljs-params"><span class="hljs-attr">config</span>: &#123; tableName: <span class="hljs-built_in">string</span> &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> &lt;T <span class="hljs-keyword">extends</span> &#123; <span class="hljs-title function_">new</span>(...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]): &#123;&#125; &#125;&gt;(<span class="hljs-attr">constructor</span>: T) &#123;<br>    constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__tableName</span> = config.<span class="hljs-property">tableName</span>;<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@Entity</span>(&#123; <span class="hljs-attr">tableName</span>: <span class="hljs-string">&#x27;users&#x27;</span> &#125;)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123; &#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((<span class="hljs-title class_">User</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">__tableName</span>); <span class="hljs-comment">// &#x27;users&#x27;</span><br><br></code></pre></td></tr></table></figure><h3 id="2-替换或扩展构造函数"><a href="#2-替换或扩展构造函数" class="headerlink" title="2. 替换或扩展构造函数"></a>2. 替换或扩展构造函数</h3><p>如果类装饰器返回一个新的构造函数，它会替换原有类定义；在此过程中必须手动维护原型链，以免丢失原方法和属性。 (<a href="https://www.typescriptlang.org/docs/handbook/decorators.html?utm_source=chatgpt.com">Documentation - Decorators - TypeScript</a>, <a href="https://stackoverflow.com/questions/34411546/how-to-properly-wrap-constructors-with-decorators-in-typescript?utm_source=chatgpt.com">How to properly wrap constructors with decorators in TypeScript</a>)</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title class_">Timestamped</span>&lt;T <span class="hljs-keyword">extends</span> &#123; <span class="hljs-title function_">new</span>(...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]): &#123;&#125; &#125;&gt;(<span class="hljs-attr">ctor</span>: T) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> ctor &#123;<br>    createdAt = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>  &#125;;<br>&#125;<br><br><span class="hljs-meta">@Timestamped</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> &#123;<br>  <span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"><span class="hljs-attr">text</span>: <span class="hljs-built_in">string</span></span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span> = text; &#125;<br>&#125;<br><span class="hljs-keyword">const</span> msg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>((msg <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-property">createdAt</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>); <span class="hljs-comment">// true</span><br><br></code></pre></td></tr></table></figure><h3 id="3-Mixin-混入模式"><a href="#3-Mixin-混入模式" class="headerlink" title="3. Mixin 混入模式"></a>3. Mixin 混入模式</h3><p>利用类装饰器，可动态向多个类注入通用方法或属性，实现类似“多重继承”的效果。 (<a href="https://github.com/monade/typescript-decorators?utm_source=chatgpt.com">monade&#x2F;typescript-decorators - GitHub</a>)</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Mixin</span>(<span class="hljs-params">...<span class="hljs-attr">bases</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> &lt;T <span class="hljs-keyword">extends</span> &#123; <span class="hljs-title function_">new</span>(...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]): &#123;&#125; &#125;&gt;(<span class="hljs-attr">ctor</span>: T) &#123;<br>    bases.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">base</span> =&gt;</span> &#123;<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(base.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (name !== <span class="hljs-string">&#x27;constructor&#x27;</span>) &#123;<br>          <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<br>            ctor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>,<br>            name,<br>            <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(base.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, name)!<br>          );<br>        &#125;<br>      &#125;);<br>    &#125;);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CanFly</span> &#123; <span class="hljs-title function_">fly</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;flying&#x27;</span>); &#125; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CanSing</span> &#123; <span class="hljs-title function_">sing</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;singing&#x27;</span>); &#125; &#125;<br><br><span class="hljs-meta">@Mixin</span>(<span class="hljs-title class_">CanFly</span>, <span class="hljs-title class_">CanSing</span>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123; &#125;<br>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>() <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-title function_">fly</span>(); <span class="hljs-comment">// flying</span><br>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bird</span>() <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>).<span class="hljs-title function_">sing</span>(); <span class="hljs-comment">// singing</span><br><br></code></pre></td></tr></table></figure><h3 id="4-元数据注入与依赖注入"><a href="#4-元数据注入与依赖注入" class="headerlink" title="4. 元数据注入与依赖注入"></a>4. 元数据注入与依赖注入</h3><p>开启 <code>emitDecoratorMetadata</code> 后，装饰器可以借助 <code>reflect-metadata</code> 获取设计时类型信息，用于自动化注册与依赖注入。 (<a href="https://www.npmjs.com/package/reflect-metadata?utm_source=chatgpt.com">reflect-metadata - NPM</a>, <a href="https://refine.dev/blog/typescript-decorators/?utm_source=chatgpt.com">TypeScript Decorators in Brief - Refine dev</a>)</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;reflect-metadata&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Inject</span>(<span class="hljs-params"><span class="hljs-attr">serviceIdentifier</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">propertyKey</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">type</span> = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getMetadata</span>(<span class="hljs-string">&#x27;design:type&#x27;</span>, target, propertyKey);<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, propertyKey, &#123;<br>      <span class="hljs-attr">get</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Container</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-keyword">type</span>),<br>    &#125;);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> &#123; <span class="hljs-title function_">log</span>(<span class="hljs-params"><span class="hljs-attr">msg</span>: <span class="hljs-built_in">string</span></span>) &#123; <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg); &#125; &#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Service</span> &#123;<br>  <span class="hljs-meta">@Inject</span>(<span class="hljs-string">&#x27;Logger&#x27;</span>)<br>  <span class="hljs-keyword">private</span> logger!: <span class="hljs-title class_">Logger</span>;<br>  <span class="hljs-title function_">doWork</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;work done&#x27;</span>); &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h2 id="深入-Method-Decorators"><a href="#深入-Method-Decorators" class="headerlink" title="深入 Method Decorators"></a>深入 Method Decorators</h2><h3 id="1-参数化方法装饰器"><a href="#1-参数化方法装饰器" class="headerlink" title="1. 参数化方法装饰器"></a>1. 参数化方法装饰器</h3><p>同样可通过装饰器工厂传入参数，以控制日志级别、缓存时长、权限校验等行为。 (<a href="https://blog.logrocket.com/practical-guide-typescript-decorators/?utm_source=chatgpt.com">A practical guide to TypeScript decorators - LogRocket Blog</a>, <a href="https://medium.com/%40rahul.jindal57/typescript-decorators-a-beginners-guide-2116d422dc7?utm_source=chatgpt.com">Typescript Decorators: Beginner’s Guide - Medium</a>)</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Log</span>(<span class="hljs-params"><span class="hljs-attr">level</span>: <span class="hljs-string">&#x27;info&#x27;</span> | <span class="hljs-string">&#x27;warn&#x27;</span> | <span class="hljs-string">&#x27;error&#x27;</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-attr">target</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">desc</span>: <span class="hljs-title class_">PropertyDescriptor</span></span>) &#123;<br>    <span class="hljs-keyword">const</span> original = desc.<span class="hljs-property">value</span>;<br>    desc.<span class="hljs-property">value</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">...<span class="hljs-attr">args</span>: <span class="hljs-built_in">any</span>[]</span>) &#123;<br>      <span class="hljs-variable language_">console</span>[level](<span class="hljs-string">`Calling <span class="hljs-subst">$&#123;key&#125;</span>`</span>, args);<br>      <span class="hljs-keyword">return</span> original.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);<br>    &#125;;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Api</span> &#123;<br>  <span class="hljs-meta">@Log</span>(<span class="hljs-string">&#x27;info&#x27;</span>)<br>  <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"><span class="hljs-attr">id</span>: <span class="hljs-built_in">number</span></span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="2-静态方法-vs-原型方法"><a href="#2-静态方法-vs-原型方法" class="headerlink" title="2. 静态方法 vs 原型方法"></a>2. 静态方法 vs 原型方法</h3><ul><li><strong>原型方法装饰器</strong>：<code>target</code> 指向类的原型，常用于实例方法；</li><li><strong>静态方法装饰器</strong>：<code>target</code> 指向构造函数本身，适用于对类方法的增强。 (<a href="https://refine.dev/blog/typescript-decorators/?utm_source=chatgpt.com">TypeScript Decorators in Brief - Refine dev</a>)</li></ul><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Example</span> &#123;<br>  <span class="hljs-meta">@decorateProto</span><br>  <span class="hljs-title function_">instanceMethod</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br>  <span class="hljs-meta">@decorateStatic</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-装饰器链的执行顺序"><a href="#3-装饰器链的执行顺序" class="headerlink" title="3. 装饰器链的执行顺序"></a>3. 装饰器链的执行顺序</h3><p>当同一方法上有多个装饰器时，它们<strong>先从外到内依次求值</strong>（即装饰器工厂执行），再<strong>从内到外依次调用</strong>（即装饰器函数执行）。 (<a href="https://stackoverflow.com/questions/34173364/how-decorators-chaining-work?utm_source=chatgpt.com">How decorators chaining work? [duplicate] - python - Stack Overflow</a>, <a href="https://mirone.me/a-complete-guide-to-typescript-decorator/?utm_source=chatgpt.com">A Complete Guide to TypeScript Decorators | Disenchanted - Mirone</a>)</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"><span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;eval&#x27;</span>, name);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;call&#x27;</span>, name);<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>  <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;Outer&#x27;</span>)<br>  <span class="hljs-meta">@f</span>(<span class="hljs-string">&#x27;Inner&#x27;</span>)<br>  <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-comment">// 输出顺序：eval Outer, eval Inner, call Inner, call Outer</span><br><br></code></pre></td></tr></table></figure><h3 id="4-自定义描述符：控制属性特性"><a href="#4-自定义描述符：控制属性特性" class="headerlink" title="4. 自定义描述符：控制属性特性"></a>4. 自定义描述符：控制属性特性</h3><p>方法装饰器可直接修改 <code>descriptor</code> 中的 <code>writable</code>、<code>enumerable</code>、<code>configurable</code> 等选项，甚至替换 <code>descriptor.value</code> 实现缓存、节流、权限校验等功能。 (<a href="https://dev.to/pipaliyachirag/mastering-typescript-50-decorators-the-ultimate-guide-26f0?utm_source=chatgpt.com">Mastering TypeScript 5.0 Decorators: The Ultimate Guide</a>)</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Enumerable</span>(<span class="hljs-params"><span class="hljs-attr">enumerable</span>: <span class="hljs-built_in">boolean</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-attr">_</span>: <span class="hljs-built_in">any</span>, <span class="hljs-attr">__</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">descriptor</span>: <span class="hljs-title class_">PropertyDescriptor</span></span>) &#123;<br>    descriptor.<span class="hljs-property">enumerable</span> = enumerable;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-meta">@Enumerable</span>(<span class="hljs-literal">false</span>)<br>  <span class="hljs-title function_">secret</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hidden&#x27;</span>; &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><p>通过上述扩展，你可以在实际项目中：</p><ul><li>使用装饰器工厂灵活传参，实现不同场景下的多样化配置；</li><li>在类装饰器中替换或扩展构造函数，动态混入功能；</li><li>利用元数据注入和反射实现依赖注入与自动化注册；</li><li>在方法装饰器中定制日志、缓存、权限等切面化功能，控制方法属性特性；</li><li>掌握多装饰器的执行时序，确保复杂逻辑可预测运作。</li></ul><p>希望这些细节能帮助你更深入地理解并驾驭 TypeScript 装饰器的强大能力！</p><hr><p>通过本文的讲解，你已掌握：</p><ol><li>如何在 TypeScript 中启用并使用类装饰器与方法装饰器；</li><li>Electron 应用中单向与双向 IPC 通信的核心用法；</li><li>利用装饰器模式优雅管理 IPC 逻辑；</li><li>结合构建工具自动加载所有处理器，实现更高效的模块化开发。</li></ol><p>希望以上内容能助力你在 Electron 与 TypeScript 项目中快速构建清晰、可维护的通信层！</p>]]></content>
    
    
    
    <tags>
      
      <tag>typescript</tag>
      
      <tag>electron</tag>
      
      <tag>ipc通信</tag>
      
      <tag>decorator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>three.js-11:3D-Text</title>
    <link href="/2023/02/24/three-js-11-3D-Text/"/>
    <url>/2023/02/24/three-js-11-3D-Text/</url>
    
    <content type="html"><![CDATA[<p>在这本节中，我们将实现 ilithya的<a href="https://www.ilithya.rocks/">3D文本</a>特效。如下图所示</p><div align="center"> <img src="/2023/02/24/three-js-11-3D-Text/3Dtext.png" class="" width="400"> </div><h2 id="1-字体加载"><a href="#1-字体加载" class="headerlink" title="1.字体加载"></a>1.字体加载</h2><p>我们首先使用 <code>TextBufferGeometry</code> 在场景中创建一个3D文本。要设定字体需要使用<a href="https://gero3.github.io/facetype.js/">typeface</a>将字体转换为指定格式。或者使用 Three.js 提供的字体。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> typefaceFont <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;three/example/fonts/helvetiker_regular.typeface.json&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>要练习通过静态资源加载字体的方法可以采用以下步骤：</p><ul><li>打开 &#x2F;node_modules&#x2F;three&#x2F;example&#x2F;fonts&#x2F;</li><li>将 helvetiker_regular.typeface.json 文件和 LICENSE 文件粘贴到 &#x2F;static&#x2F;fonts 文件夹下</li><li>然后就可以通过访问 &#x2F;font&#x2F;helvetiker_regular.typeface.json URL 加载字体资源了</li></ul></blockquote><p>加载字体需要使用 <code>FontLoader</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Fonts</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> fontLoader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">FontLoader</span>()<br>fontLoader.<span class="hljs-title function_">load</span>(<br>    <span class="hljs-string">&#x27;/font/helvetiker_regular.typeface.json&#x27;</span>,<br>    <span class="hljs-function">(<span class="hljs-params">font</span>)=&gt;</span>&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;font loaded&#x27;</span>)<br>    &#125;<br>)<br><br><span class="hljs-comment">//注意，此处与材质加载器不同，材质加载器加载后会得到材质，而字体加载器加载后需要在回调函数里获取字体</span><br><span class="hljs-keyword">const</span> texture = textureLoader.<span class="hljs-title function_">load</span>()    <span class="hljs-comment">//得到材质</span><br></code></pre></td></tr></table></figure><h2 id="2-文本创建"><a href="#2-文本创建" class="headerlink" title="2.文本创建"></a>2.文本创建</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fontLoader.<span class="hljs-title function_">load</span>(    <span class="hljs-comment">//加载字体</span><br>    <span class="hljs-string">&#x27;/font/helvetiker_regular.typeface.json&#x27;</span>,<br>    <span class="hljs-function">(<span class="hljs-params">font</span>)=&gt;</span>&#123;<br>        <span class="hljs-comment">//创建文本顶点数据</span><br>        <span class="hljs-keyword">const</span> textGeometry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThREE</span>.<span class="hljs-title class_">TextBufferGeometry</span>(<br>            <span class="hljs-string">&quot;Hello Three.js&quot;</span>,<br>            &#123;<br>                <span class="hljs-comment">//font config</span><br>                font,<br>                <span class="hljs-attr">size</span>: <span class="hljs-number">0.5</span>,<br>                <span class="hljs-attr">height</span>: <span class="hljs-number">0.2</span>,<br>                <span class="hljs-attr">curveSegments</span>: <span class="hljs-number">12</span>,<br>                <span class="hljs-attr">bevelEnable</span>: <span class="hljs-literal">true</span>,<br>                <span class="hljs-attr">bevelThickness</span>: <span class="hljs-number">0.03</span>,<br>                <span class="hljs-attr">bevelSize</span>: <span class="hljs-number">0.02</span>,<br>                <span class="hljs-attr">bevelOffset</span>: <span class="hljs-number">0</span>,<br>                <span class="hljs-attr">bevelSegments</span>: <span class="hljs-number">5</span><br>            &#125;<br>        )<br>        <span class="hljs-comment">//创建材质</span><br>        <span class="hljs-keyword">const</span> textMaterial = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>()<br>        <span class="hljs-comment">//创建网格</span><br>        <span class="hljs-keyword">const</span> text = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(textGeometry, textMaterial)<br>        <span class="hljs-comment">//加入场景</span><br>        scene.<span class="hljs-title function_">add</span>(text)<br>    &#125;<br>)<br></code></pre></td></tr></table></figure><p>注意创建文字几何体是非常耗费资源的，因为一段文字会包含许多的几何体（三角形、圆形），所以我们尽量通过减少 <code>curveSegments</code> 和 <code>bevelSegments</code>的值来保持文本几何体是低模的</p><h3 id="2-1-文本居中"><a href="#2-1-文本居中" class="headerlink" title="2.1 文本居中"></a>2.1 文本居中</h3><p>居中文本的方式有很多种。</p><ol><li>BOUNDING<br><strong>BOUNDING</strong> 就是几何体的边界信息，意味着几何体在空间中占用的大小，他可能是一个立方体，也可能是一个球体<div align="center">  </div>。它可以让 **THree.js** 计算哪些物体应该在视锥范围内显示。所以我们可以用 **bounding** 让文本居中</li></ol><p>默认情况下， <strong>THree.js</strong> 使用球面 <strong>BOUNDING</strong>，我们可以用 <code>computeBoundingBox()</code> 计算 <strong>Bounding</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">textGeometry.<span class="hljs-title function_">computeBoundingBox</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(textGeometry.<span class="hljs-property">boundingBox</span>)   <span class="hljs-comment">//注意，在使用textGeometry.boundingBox之前需要先使用computeBoundingBox</span><br></code></pre></td></tr></table></figure><p><strong>textGeometry.boundingBox</strong> 的结果是 <code>Box3</code> 实例，具有 <strong>min</strong> 和 <strong>max属性</strong>。如果你观察上面打印出来的结果会发现即使文本是从原点开始创建的但 <strong>min</strong> property并不是0，这是因为 <strong>bevelThickness</strong> 和 <strong>bevelSize</strong>的影响。</p><p>我们接下来使用 <code>translate</code> 方法来移动整个几何体的顶点，而不是移动 mesh。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">textGeometry.<span class="hljs-title function_">translate</span>(<br>    - textGeometry.<span class="hljs-property">boundingBox</span>.<span class="hljs-property">max</span>.<span class="hljs-property">x</span> * <span class="hljs-number">0.5</span>,<br>    - textGeometry.<span class="hljs-property">boundingBox</span>.<span class="hljs-property">max</span>.<span class="hljs-property">y</span> * <span class="hljs-number">0.5</span>,<br>    - textGeometry.<span class="hljs-property">boundingBox</span>.<span class="hljs-property">max</span>.<span class="hljs-property">z</span> * <span class="hljs-number">0.5</span><br>)<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/02/24/three-js-11-3D-Text/translate.png" class="" width="400"> </div><p>表面看起来移动在中心了，实际上并没有。因为bevelThickness和bevelSize的影响。所以还需微调以下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">textGeometry.<span class="hljs-title function_">translate</span>(<br>    - ( textGeometry.<span class="hljs-property">boundingBox</span>.<span class="hljs-property">max</span>.<span class="hljs-property">x</span> - <span class="hljs-number">0.02</span>) * <span class="hljs-number">0.5</span>,<br>    - ( textGeometry.<span class="hljs-property">boundingBox</span>.<span class="hljs-property">max</span>.<span class="hljs-property">y</span> - <span class="hljs-number">0.02</span> )* <span class="hljs-number">0.5</span>, <span class="hljs-comment">// -0.02是因为 bevelsize（从字体内部到外部的距离）</span><br>    - ( textGeometry.<span class="hljs-property">boundingBox</span>.<span class="hljs-property">max</span>.<span class="hljs-property">z</span> - <span class="hljs-number">0.03</span> ) * <span class="hljs-number">0.5</span> <span class="hljs-comment">// -0.03是因为bevelThickness</span><br>)<br></code></pre></td></tr></table></figure><p>这样才能是真正的居中</p><h3 id="2-2-使用-center-居中"><a href="#2-2-使用-center-居中" class="headerlink" title="2.2 使用 center() 居中"></a>2.2 使用 center() 居中</h3><p>实际上three.js内置了一个 center() 函数来使文字居中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">textGeometry.<span class="hljs-title function_">center</span>()<br></code></pre></td></tr></table></figure><p>center函数也是基于BOUNDING实现的</p><h2 id="3-添加MATCAT"><a href="#3-添加MATCAT" class="headerlink" title="3.添加MATCAT"></a>3.添加MATCAT</h2><p>我们使用 <strong>MeshMatcapMaterial</strong> 应用 matcaps(模拟光照阴影)，你可以在这里<a href="https://github.com/nidorx/matcaps">下载matcaps</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> textureLoader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>()<br><span class="hljs-keyword">const</span> matcapTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/matcaps/1.png&#x27;</span>)<br></code></pre></td></tr></table></figure><p>然后使用 <strong>MeshMatcapMaterial</strong> 替换 <strong>MeshBasicMaterial</strong>，并使用 matcap</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> textMaterial = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshMatcapMaterial</span>(&#123;<span class="hljs-attr">matcap</span>: matcapTexture&#125;)<br><br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/02/24/three-js-11-3D-Text/matcap.png" class="" width="400"> </div><h2 id="4-添加装饰几何体"><a href="#4-添加装饰几何体" class="headerlink" title="4.添加装饰几何体"></a>4.添加装饰几何体</h2><p>在场景中创建完3D文本后我们可以添加100个几何体用来装饰周围环境，首先我们用一个低效的方法实现创建100个几何体</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++)&#123;<br>    <span class="hljs-keyword">const</span> donutGeometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TorusBufferGeometry</span>(<span class="hljs-number">0.3</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">20</span>, <span class="hljs-number">45</span>)<br>    <span class="hljs-keyword">const</span> donutMaterial = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshMatcapMaterial</span>(&#123;<span class="hljs-attr">matcap</span>: matcapTexture&#125;)<br>    <span class="hljs-keyword">const</span> donut = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(donutGeometry, donutMaterial)<br>    <br>    donut.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * <span class="hljs-number">10</span><br>    donut.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * <span class="hljs-number">10</span><br>    donut.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = (<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() - <span class="hljs-number">0.5</span>) * <span class="hljs-number">10</span><br>    <br>    scene.<span class="hljs-title function_">add</span>(donut)<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下</p><div align="center"> <img src="/2023/02/24/three-js-11-3D-Text/donut.png" class="" width="400"> </div>所有的甜甜圈都朝向一个地方,且大小相同，所以我们最好给甜甜圈旋转以下，并缩放甜甜圈<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//...</span><br>donut.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span><br>donut.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * <span class="hljs-title class_">Math</span>.<span class="hljs-property">PI</span><br><br><span class="hljs-keyword">const</span> scale = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()<br>donut.<span class="hljs-property">scale</span>.<span class="hljs-property">x</span> = scale<br>donut.<span class="hljs-property">scale</span>.<span class="hljs-property">y</span> = scale<br>donut.<span class="hljs-property">scale</span>.<span class="hljs-property">z</span> = scale<br><br><span class="hljs-comment">//或者使用 donut.scale.set(scale, scale, scale)</span><br>scene.<span class="hljs-title function_">add</span>(donut)<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure><h2 id="5-优化"><a href="#5-优化" class="headerlink" title="5.优化"></a>5.优化</h2><p>实际上以上的性能非常低效，我们可以用 <code>console.time(donuts)</code> 看一下性能消耗</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;donuts&quot;</span>)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i= <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span> ; i++)<br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;donuts&quot;</span>)  <span class="hljs-comment">//44...ms</span><br></code></pre></td></tr></table></figure><p>可以看出是非常消耗性能的，所以我们有一个优化思路：我们可以用同样的 <strong>geometry</strong> 和 <strong>material</strong> 在多个 <strong>Meshes</strong> 上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;donuts&quot;</span>)<br><span class="hljs-keyword">const</span> donutGeometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TorusBufferGeometry</span>(<span class="hljs-number">0.3</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">20</span>, <span class="hljs-number">45</span>)<br><span class="hljs-keyword">const</span> donutMaterial = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshMatcapMaterial</span>(&#123;<span class="hljs-attr">matcap</span>: matcapTexture&#125;)<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;donuts&quot;</span>) <span class="hljs-comment">//1.... ms</span><br></code></pre></td></tr></table></figure><p>可以看到优化非常的明显</p><p>此外，我们还可以让 <strong>donut</strong> 和 <strong>text</strong> 使用同一个 <strong>material</strong>，而不必再为 <strong>donut</strong> 实例化一个 <strong>material</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>three.js</tag>
      
      <tag>web</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>three.js_10-Materials</title>
    <link href="/2023/02/20/three-js-10-Materials/"/>
    <url>/2023/02/20/three-js-10-Materials/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是-Materials"><a href="#1-什么是-Materials" class="headerlink" title="1.什么是 Materials"></a>1.什么是 Materials</h2><p><strong>Materials</strong>用来给几何体上每个可见的像素染色。这种染色算法在程序里叫做 <strong>Shaders</strong>. 我们不需要自己手写 <strong>Shaders</strong> 可以使用内置的 materials</p><h2 id="2-使用-Materials"><a href="#2-使用-Materials" class="headerlink" title="2.使用 Materials"></a>2.使用 Materials</h2><h3 id="2-1-创建场景"><a href="#2-1-创建场景" class="headerlink" title="2.1 创建场景"></a>2.1 创建场景</h3><p>我们创建三种不同的几何体(spehre, plane, torus)来练习Materials的使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123;<span class="hljs-attr">color</span>: <span class="hljs-number">0xff0000</span>&#125;)<br><br><span class="hljs-keyword">const</span> sphere = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">SphereBufferGeometry</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">16</span>, <span class="hljs-number">16</span>),<br>    material<br>)<br>sphere.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = - <span class="hljs-number">1.5</span><br><br><span class="hljs-keyword">const</span> plane = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PlaneBufferGeometry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>),<br>    material<br>)<br><br><br><span class="hljs-keyword">const</span> torus = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(<br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TorusBufferGeometry</span>(<span class="hljs-number">0.3</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">16</span>, <span class="hljs-number">32</span>),<br>    material<br>)<br>torus.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = <span class="hljs-number">1.5</span><br><br>scene.<span class="hljs-title function_">add</span>(sphere, plane, torus)<br></code></pre></td></tr></table></figure><p>以上代码创建了三个几何体，并设置了color。效果如图</p><div align="center"> <img src="/2023/02/20/three-js-10-Materials/material.png" class="" width="400"> </div><p>接下来，我们让几何体自己旋转以便观察到各个部位</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> clock = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Clock</span>()<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">tick</span> =(<span class="hljs-params"></span>) =&gt;&#123;<br>    <span class="hljs-keyword">const</span> elapsedTime = clock.<span class="hljs-title function_">getElapsedTime</span>()<br>    sphere.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> = <span class="hljs-number">0.1</span> * elapsedTime<br>    plane.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> = <span class="hljs-number">0.1</span> * elapsedTime<br>    torus.<span class="hljs-property">rotation</span>.<span class="hljs-property">y</span> = <span class="hljs-number">0.1</span> * elapsedTime<br><br>    sphere.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> = <span class="hljs-number">0.15</span> * elapsedTime<br>    plane.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> = <span class="hljs-number">0.15</span> * elapsedTime<br>    torus.<span class="hljs-property">rotation</span>.<span class="hljs-property">x</span> = <span class="hljs-number">0.15</span> * elapsedTime<br>&#125;<br></code></pre></td></tr></table></figure><p>然后加载纹理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> textureLoader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>(loadingManager)<br><span class="hljs-keyword">const</span> doorColorTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/door/color.jpg&#x27;</span>)<br><span class="hljs-keyword">const</span> doorAlphaTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/door/alpha.jpg&#x27;</span>)<br><span class="hljs-keyword">const</span> doorColorTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/door/color.jpg&#x27;</span>)<br><span class="hljs-keyword">const</span> doorColorTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/door/color.jpg&#x27;</span>)<br><span class="hljs-keyword">const</span> matcapTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/matcaps/1.png&#x27;</span>)<br><span class="hljs-keyword">const</span> gradientTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/gradients/1.png&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="2-2-MeshBasicalMaterial"><a href="#2-2-MeshBasicalMaterial" class="headerlink" title="2.2 MeshBasicalMaterial"></a>2.2 MeshBasicalMaterial</h3><p>大多数的 <strong>Material</strong> 属性都能用两种设置，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//实例化时声明</span><br><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123;<span class="hljs-attr">map</span>: doorColorTexture&#125;)<br><br><span class="hljs-comment">//实例化后声明</span><br><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshBasicMaterial</span>()<br>material.<span class="hljs-property">map</span> = doorColorTexture<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/02/20/three-js-10-Materials/setPro.png" class="" width="400"> </div><ol><li><p><strong>map</strong> 属性会将 <strong>texture</strong> 设置在几何体的表面.</p></li><li><p><strong>color</strong> 属性会给几何体的表面设置颜色，一旦被实例化后。 <strong>color</strong> 属性就变为 <code>Color</code>**&#96;&#96;&#96; 类型，所以如果在实例化 <strong>Material</strong>  后指定物体的颜色可采用以下两种方法</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1.采用Color.set 方法</span><br>material.<span class="hljs-property">color</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;#ff00ff&#x27;</span>)<br><br><span class="hljs-comment">// 2.实例化一个 Color 类</span><br>material.<span class="hljs-property">color</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title function_">color</span>(<span class="hljs-string">&#x27;#ff00ff&#x27;</span>)<br></code></pre></td></tr></table></figure><ol start="3"><li><p><strong>wireframe</strong> 属性会展示组成几何体的三角形</p></li><li><p><strong>opacity</strong> 控制几何体的透明度。在这之前我们需要设置 <code>transparent = true</code> </p></li><li><p><strong>alphaMap</strong> 控制材质的透明度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">material.<span class="hljs-property">transparent</span> = <span class="hljs-literal">true</span><br>material.<span class="hljs-property">alphaMap</span> = doorAlphaTexture<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/02/20/three-js-10-Materials/alpha.png" class="" width="400"> </div></li><li><p><strong>side</strong> 可以让你决定哪个面能够显示</p><ul><li>THREE.FrontSide(default)</li><li>THREE.BackSide</li><li>THREE.DoubleSide</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">material.<span class="hljs-property">side</span> = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">DoubleSide</span> <span class="hljs-comment">//会造成GPU压力增加</span><br></code></pre></td></tr></table></figure><h3 id="2-3MeshNormalMaterial"><a href="#2-3MeshNormalMaterial" class="headerlink" title="2.3MeshNormalMaterial"></a>2.3MeshNormalMaterial</h3><p><strong>MeshNormalMaterial</strong> 会展示一个非常炫酷的紫色效果</p><blockquote><p>normals n.法线</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshNormalMaterial</span>()<br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/02/20/three-js-10-Materials/normal.png" class="" width="400"> </div><p>实际上 <strong>Normal</strong> 并不仅仅是给几何体添加上了炫彩的颜色，而是给 <strong>Geometry</strong> 自动添加了法线方向属性，以供于光照、反射的计算</p><p><strong>MeshNormalMaterial</strong> 与 <strong>MeshBasicMaterial</strong> 一样拥有 <code>wireframe, transparent, opacity, side</code> 属性。但会额外多一个 <code>flatShading</code> 属性。</p><p><strong>flatShading（平坦着色）</strong> 是指通过三角形三顶点的坐标计算出整个三角形的法向量。 这样就导致相邻两个三角形的法向量差别很大，所以就能看到明显的三角形的边。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">material.<span class="hljs-property">flatShading</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/02/20/three-js-10-Materials/flat.png" class="" width="400"> </div><p>与之相对应的是“Smooth Shading”：先计算三角形三顶点处的法向量，然后将这三个法向量线性插值的结果作为整个三角形的法向量。这样相邻两个三角形的法向量差别就会小很多。</p><p>来两张图感受一下两种着色,前者为 flat 着色，后者为 smooth 着色</p><div align="center"><img src="/2023/02/20/three-js-10-Materials/flat.bmp" class="" width="400"> <img src="/2023/02/20/three-js-10-Materials/smoth.bmp" class="" width="400"></div>图源：<p><a href="https://blog.csdn.net/libing_zeng/article/details/60760296">平坦着色（Flat Shading）和平滑着色（Smooth Shading)</a></p><p><strong>MeshNormalMaterial</strong>通常是用来调试法线的，且它可以直接用在你的工程中</p><h3 id="2-4-MeshMatcapMaterial"><a href="#2-4-MeshMatcapMaterial" class="headerlink" title="2.4 MeshMatcapMaterial"></a>2.4 MeshMatcapMaterial</h3><p><strong>MeshMatcapMaterial</strong> 会使用法线作为计算应用在几何体上matcap材质正确着色的参考。</p><div align="center"><img src="/2023/02/20/three-js-10-Materials/matcap.png" class=""></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//设置matcap属性应用matcap</span><br><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshMatcapMaterial</span>()<br>material.<span class="hljs-property">matcap</span> = matcapTexture<br></code></pre></td></tr></table></figure><p>注意设置mapcap后几何体有光照阴影效果</p><div align="center"><img src="/2023/02/20/three-js-10-Materials/matcaps.png" class=""></div><p><a href="https://github.com/nidorx/matcaps">下载matcaps</a></p><h3 id="2-5-MeshDepthMaterial"><a href="#2-5-MeshDepthMaterial" class="headerlink" title="2.5 MeshDepthMaterial"></a>2.5 MeshDepthMaterial</h3><p><strong>MeshDepthMaterial</strong> 会在摄像头距离几何体近端染上白色，远端染上黑色</p><div align="center"><img src="/2023/02/20/three-js-10-Materials/white0.png" class="" width="400"> <img src="/2023/02/20/three-js-10-Materials/black.png" class="" width="400"></div><p>可以用来模拟光照</p><h3 id="2-6-MeshLambertMaterial"><a href="#2-6-MeshLambertMaterial" class="headerlink" title="2.6 MeshLambertMaterial"></a>2.6 MeshLambertMaterial</h3><p><strong>MeshLambertMaterial</strong> 可以被光照的效果影响到<br>首先增加灯光来看下效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ambienLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">AmbientLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">0.5</span>)<br>scene.<span class="hljs-title function_">add</span>(ambienLight)<br><br><span class="hljs-keyword">const</span> pointLight = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">PointLight</span>(<span class="hljs-number">0xffffff</span>, <span class="hljs-number">0.5</span>)<br>pointLight.<span class="hljs-property">position</span>.<span class="hljs-property">x</span> = <span class="hljs-number">2</span><br>pointLight.<span class="hljs-property">position</span>.<span class="hljs-property">y</span> = <span class="hljs-number">3</span><br>pointLight.<span class="hljs-property">position</span>.<span class="hljs-property">z</span> = <span class="hljs-number">4</span><br><br>scene.<span class="hljs-title function_">add</span>(pointLight)<br><br><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">MeshLambertMaterial</span>()<br><br></code></pre></td></tr></table></figure><p>左图是有光照的效果，右图是没有光照的效果</p><div align="center"><img src="/2023/02/20/three-js-10-Materials/light.png" class="" width="400"> <img src="/2023/02/20/three-js-10-Materials/none.png" class="" width="400"></div><p><strong>MeshLambertMaterial</strong> 具有很好的性能表现，但物理效果还有更好的 Material</p><h3 id="2-7-MeshLambertMaterial"><a href="#2-7-MeshLambertMaterial" class="headerlink" title="2.7 MeshLambertMaterial"></a>2.7 MeshLambertMaterial</h3><p>**MeshLambertMaterial 与 ** <strong>MeshLambertMaterial</strong> 表现效果类似，但视觉光反射上会更好。</p><p>可以通过 <code>shininess</code> 和 <code>specular</code> 调整光反射效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">material.<span class="hljs-property">shininess</span> = <span class="hljs-number">100</span>    <span class="hljs-comment">//值越大光反射效果越明显</span><br>material.<span class="hljs-property">specular</span> = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Color</span>(<span class="hljs-number">0x1188ff</span>)<br></code></pre></td></tr></table></figure><div align="center"><img src="/2023/02/20/three-js-10-Materials/specular.png" class="" width="400"> </div><h3 id="2-8-MeshToonMaterial"><a href="#2-8-MeshToonMaterial" class="headerlink" title="2.8 MeshToonMaterial"></a>2.8 MeshToonMaterial</h3><p><strong>MeshToonMaterial</strong> 效果与 <strong>MeshLambertMaterial</strong> 类似，但会有一种漫画滤镜</p><div align="center"><img src="/2023/02/20/three-js-10-Materials/Toon.png" class="" width="400"> </div><p>要添加更多的色彩渐变，可以使用 gradientMap 赋予渐变材质。下图为渐变材质示例</p><div align="center"><img src="/2023/02/20/three-js-10-Materials/gradient.png" class="" width="400"> </div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">material.<span class="hljs-property">gradientMap</span> = gradientTexture<br></code></pre></td></tr></table></figure><p>添加渐变材质后色彩分割感就小时了，因为渐变单位变小了，并且 magFilter 会尝试使用 mipmapping 来优化视觉（模糊）效果</p><div align="center"><img src="/2023/02/20/three-js-10-Materials/gMap.png" class="" width="400"> </div>如果我们想改变这种情况，可以给 THREE.NearestFilter 设置 minFilter 和 magFilter<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">grdientTexture.<span class="hljs-property">minFilter</span> = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">NearestFilter</span><br>grdientTexture.<span class="hljs-property">magFilter</span> = <span class="hljs-variable constant_">THREE</span>.<span class="hljs-property">NearestFilter</span><br><br>grdientTexture.<span class="hljs-property">generateMipmaps</span> = <span class="hljs-literal">false</span> <span class="hljs-comment">//采用了最近点采样方法后建议将 mipmapping生成关掉，这样会优化性能</span><br></code></pre></td></tr></table></figure><div align="center"><img src="/2023/02/20/three-js-10-Materials/magFilter.png" class="" width="400"> </div><h3 id="2-9-MeshStandardMaterial"><a href="#2-9-MeshStandardMaterial" class="headerlink" title="2.9 MeshStandardMaterial"></a>2.9 MeshStandardMaterial</h3><p><strong>MeshStandardMaterial</strong> 采用了 PBR 标准，使得视觉上光照更接近物理效果。与 <strong>MeshLambertMaterial</strong> 和 <strong>MeshPhongMaterial</strong> 类似，它支持很多与光照有关的算法，且额外提供了类似 <code>roughness</code> 和 <code>metalness</code> 这样的参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MeshStandardMaterial</span><br><br>material.<span class="hljs-property">metalness</span> = <span class="hljs-number">0.45</span><br>material.<span class="hljs-property">roughness</span> = <span class="hljs-number">0.65</span><br></code></pre></td></tr></table></figure><div align="center"><img src="/2023/02/20/three-js-10-Materials/stand.png" class="" width="400"> </div><p>你可以使用 <strong>map</strong> 属性添加普通材质，也可以用 aoMap(ambient occlusion map) 添加纹理中提供的阴影,当然仅设置 <code>aoMap</code> 还不够，我们还需要提供另一组 UV 数组坐标： <code>uv2</code></p><blockquote><p>uv坐标提供纹理如何应用于材质</p></blockquote><div align="center"><img src="/2023/02/20/three-js-10-Materials/ao.png" class="" width="400"> </div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">plane.<span class="hljs-property">geometry</span>.<span class="hljs-title function_">setAttribute</span>(<br>    <span class="hljs-string">&#x27;uv2&#x27;</span>, <br>    <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BufferAttribute</span>(plane.<span class="hljs-property">geometry</span>.<span class="hljs-property">attributes</span>.<span class="hljs-property">uv</span>.<span class="hljs-property">arry</span>, <span class="hljs-number">2</span>))<br>    <span class="hljs-comment">//因为阴影材质uv与纹理材质一致，所以直接使用plane.geometry.attributes.uv.arry</span><br></code></pre></td></tr></table></figure><p>左图为未设置 <code>aoMap</code> 右图未设置了 <code>aoMap</code></p><div align="center"> <img src="/2023/02/20/three-js-10-Materials/noaomap.png" class="" width="400"> <img src="/2023/02/20/three-js-10-Materials/aomap.png" class="" width="400"></div><p>aoMap 添加了 doorAmbientOcclusionTexture 后就可以使用 aoMapIntensity 控制阴影深度</p><p>使用 <code>displacementMap</code> 添加了高度材质后就可以做出浮雕效果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">material.<span class="hljs-property">displacementMap</span> = doorHeightTexture<br></code></pre></td></tr></table></figure><div align="center"><img src="/2023/02/20/three-js-10-Materials/dis.png" class="" width="400"> </div><p>我们发现在使用了 displacement 后几何体就变得很奇怪，这是因为几何体提供的定点数太少了，而 displacement值又太大</p><p>所以我们需要用<br> <figure class="highlight plaintext"><figcaption><span>降低 ```displacement``` 效果, 并给几何体添加细分度。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs displacementScale```"><br>```javascript<br>material.displacementScale = 0.05<br>//...<br>new THREE.PlaneBufferGeometry(1, 1, 100, 100)<br>//...<br></code></pre></td></tr></table></figure></p><div align="center"><img src="/2023/02/20/three-js-10-Materials/scale.png" class="" width="400"> </div><p>除了通过 matalness 和 roughness 添加光照效果，我们也可以用 <code>metalnessMap</code> 和 <code>roughnessMap</code> 来添加光照效果</p><p>当同时使用 <strong>matalness</strong> 与 <strong>metalnessMap</strong>、 <strong>roughness</strong> 与 <strong>roughnessMap</strong> 后效果会很奇怪，因为他们都会起作用从而造成效果叠加</p><p><strong>normalMap</strong>会改变法线朝向并给表面添加更多细节。左图是没有 <strong>normalMap</strong> 的预览，右图是添加 <strong>normalMap</strong> 后的预览</p><div align="center"><img src="/2023/02/20/three-js-10-Materials/nonor.png" class="" width="400"> <img src="/2023/02/20/three-js-10-Materials/detail.png" class="" width="400"></div><p>我们也可以使用 <code>normalScale: Vector2</code> 改变法线性质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">material.<span class="hljs-property">normalScale</span>.<span class="hljs-title function_">set</span>(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><p>最后 ，我们可以使用 <code>alphaMap</code> 属性控制 <strong>alpha</strong>，同时不要忘记将 <code>transparent</code> 设置为 true</p><h3 id="2-10-MeshPhysicalMaterial"><a href="#2-10-MeshPhysicalMaterial" class="headerlink" title="2.10 MeshPhysicalMaterial"></a>2.10 MeshPhysicalMaterial</h3><p><strong>MeshPhysicalMaterial</strong> 和 <strong>MeshStandardMaterial</strong> 一样，不过支持透明涂层效果</p><div align="center"> <img src="/2023/02/20/three-js-10-Materials/phy.png" class="" width="400"></div><h3 id="2-11-PointsMaterial"><a href="#2-11-PointsMaterial" class="headerlink" title="2.11 PointsMaterial"></a>2.11 PointsMaterial</h3><p>用于粒子的材质</p><h2 id="3-ENVIRONMENT-MAP"><a href="#3-ENVIRONMENT-MAP" class="headerlink" title="3.ENVIRONMENT MAP"></a>3.ENVIRONMENT MAP</h2><p>环境贴图是周围场景的图片，它不仅可以用来做反射和折射效果，也能做光照效果。通常环境贴图不止有一张，而是很多张的集合(左右上下前后)</p><p>要使用环境贴图需要用 CubeTextureLoader 在 material 实例化之前加载完成</p><div align="center"> <img src="/2023/02/20/three-js-10-Materials/loader.png" class="" width="400"></div><p>获取好看的环境贴图，我们可以在 <a href="https://polyhaven.com/">HDRI HAVEN</a> 下载，不过从这上面下载下来的图片是 HDRIs(High Dynamic Range Imaging) 图片, 并不是 cube maps。</p><p>所以我们可以使用 <a href="https://matheowis.github.io/HDRI-to-CubeMap/">在线工具</a> 将 HDRIs 转换为 cube maps</p>]]></content>
    
    
    
    <tags>
      
      <tag>three.js</tag>
      
      <tag>web</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>three.js_9-texture</title>
    <link href="/2023/02/19/three-js-9-texture/"/>
    <url>/2023/02/19/three-js-9-texture/</url>
    
    <content type="html"><![CDATA[<h2 id="1-什么是材质"><a href="#1-什么是材质" class="headerlink" title="1.什么是材质?"></a>1.什么是材质?</h2><p>材质就是覆盖在几何体上的图片，并且也能有不同的视觉效果（例如反射），不仅仅是贴图</p><h2 id="2-材质种类"><a href="#2-材质种类" class="headerlink" title="2.材质种类"></a>2.材质种类</h2><h3 id="2-1-alpha"><a href="#2-1-alpha" class="headerlink" title="2.1 alpha"></a>2.1 alpha</h3><ul><li>alpha 材质是一个灰度图，白色的地方代表可见，黑色则代表不可见，如下图<div align="center"> <img src="/2023/02/19/three-js-9-texture/door/alpha.jpg" class="" width="400"> </div></li></ul><h3 id="2-2-HEIGHT"><a href="#2-2-HEIGHT" class="headerlink" title="2.2 HEIGHT"></a>2.2 HEIGHT</h3><ul><li>HEIGHT 材质也是一个灰度图，代表高度。</li><li>一个像素点的灰度会提高或降低平面的高度。 需要提供细分信息（subdivision）如下图<div align="center"> <img src="/2023/02/19/three-js-9-texture/door/height.jpg" class="" width="400"> </div></li></ul><h3 id="2-3-NORMAL"><a href="#2-3-NORMAL" class="headerlink" title="2.3 NORMAL"></a>2.3 NORMAL</h3><ul><li>NORMAL 材质需要我们添加一些表面细节，如光照。</li><li>无需细分信息相比HEIGHT材质有更高的性能<div align="center"> <img src="/2023/02/19/three-js-9-texture/door/normal.jpg" class="" width="400"> </div></li></ul><h3 id="2-4-AMBIENT-OCCLUSION"><a href="#2-4-AMBIENT-OCCLUSION" class="headerlink" title="2.4 AMBIENT OCCLUSION"></a>2.4 AMBIENT OCCLUSION</h3><ul><li>AMBIENT OCCLUSION 也是一个灰度图，作用是增加物体的阴影</li><li>但它并不会模拟真实的物理光照效果（假阴影）。通常用来添加反差效果和更多细节<div align="center"> <img src="/2023/02/19/three-js-9-texture/door/ambientOcclusion.jpg" class="" width="400"> </div></li></ul><h3 id="2-5-METALNESS"><a href="#2-5-METALNESS" class="headerlink" title="2.5 METALNESS"></a>2.5 METALNESS</h3><ul><li>METALNESS 是一个灰度图。白色地方代表金属光泽，黑色代表无金属光照</li><li>大多用来展示光线反射（如镜子）<div align="center"> <img src="/2023/02/19/three-js-9-texture/door/metalness.jpg" class="" width="400"> </div></li></ul><h3 id="2-6-ROUGHNESS"><a href="#2-6-ROUGHNESS" class="headerlink" title="2.6 ROUGHNESS"></a>2.6 ROUGHNESS</h3><ul><li>ROUGHNESS 是一个灰度图，通常与 METALNESS 配合使用。</li><li>白色代表粗糙，黑色代表平滑。</li><li>通常用来展示光线漫反射<br>例如用它来展示一个地毯（粗糙）或者金属（光滑）<div align="center"> <img src="/2023/02/19/three-js-9-texture/door/roughness.jpg" class="" width="400"> </div></li></ul><h3 id="2-7-PBR-principles"><a href="#2-7-PBR-principles" class="headerlink" title="2.7 PBR principles"></a>2.7 PBR principles</h3><p>这些种类的材质都需要遵循 <strong><a href="https://zhuanlan.zhihu.com/p/33464301">PBR</a></strong> 规范</p><blockquote><h3 id="PBR-规范"><a href="#PBR-规范" class="headerlink" title="PBR 规范"></a>PBR 规范</h3><p>PBR是基于物理表现的渲染，例如光照、金属光泽、粗糙度（实际上大多数技术都倾向于遵循现实世界的物理效果）<br>PBR定义了一系列的算法用来模拟现实世界物体的渲染效果</p></blockquote><h2 id="3-使用材质"><a href="#3-使用材质" class="headerlink" title="3.使用材质"></a>3.使用材质</h2><p>了解了几种材质类型后就可以开始使用材质了。首先使用一个由Paulo做的<a href="https://3dtextures.me/2019/04/16/door-wood-001/">门材质</a>,这是一个很有名的库</p><div align="center"> <img src="/2023/02/19/three-js-9-texture/door-texture.png" class="" width="400"></div><h3 id="3-1加载材质静态资源"><a href="#3-1加载材质静态资源" class="headerlink" title="3.1加载材质静态资源"></a>3.1加载材质静态资源</h3><p>使用材质首先需要解决的问题是引入材质图片，我们有两种方法引入</p><ol><li><p>可以使用 import 导入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> imageSource <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./color.jpg&#x27;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(imageSource)    <span class="hljs-comment">//http://localhost/images/c43f...jpg</span><br></code></pre></td></tr></table></figure></li><li><p>静态资源服务器<br>我们可以在项目根目录的static目录下放置图片</p><div align="center"> <img src="/2023/02/19/three-js-9-texture/project.png" class="" width="400"> </div>然后就能在浏览器中直接访问到材质图片了<div align="center"> <img src="/2023/02/19/three-js-9-texture/project2.png" class="" width="400"> </div>以上方式皆基于webpack</li><li><p>Native Javascript</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>()<br><br>image.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;image loaded&quot;</span>)<br>&#125;<br><br>image.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;/textures/door/color.jpg&#x27;</span><br></code></pre></td></tr></table></figure><p>缺点：当图片大，宽带小时会花费很长时间加载</p></li></ol><h3 id="3-2初始化材质"><a href="#3-2初始化材质" class="headerlink" title="3.2初始化材质"></a>3.2初始化材质</h3><p>材质被加载进来后就可以开始初始化材质,并将材质应用在物体上了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>()<br><br>image.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> texture = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Texture</span>(image)    <span class="hljs-comment">//初始化材质</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;image loaded&quot;</span>)<br>&#125;<br><br>image.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;/textures/door/color.jpg&#x27;</span><br></code></pre></td></tr></table></figure><p>实际上这段代码可以使用 <strong>texture.needsUpdate</strong> 属性实现材质的自动更新，这样就可以避免因作用域问题需要手动维护texture的状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>()<br><span class="hljs-keyword">const</span> texture = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Texture</span>(image)<br>image.<span class="hljs-property">onload</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    texture.<span class="hljs-property">needsUpdate</span> = <span class="hljs-literal">true</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;image loaded&quot;</span>)<br>&#125;<br><br>image.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;/textures/door/color.jpg&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="TextureLoader"><a href="#TextureLoader" class="headerlink" title="TextureLoader"></a>TextureLoader</h3><p>除了使用img初始化材质以外，还可以使用 <strong>TextureLoader</strong> 直接加载材质</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> textureLoader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>()<br><span class="hljs-keyword">const</span> texture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/door/color.jpg&#x27;</span>)<br><span class="hljs-keyword">const</span> geometry = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">BoxBufferGeometry</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> material = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Three</span>.<span class="hljs-title class_">MeshBasicMaterial</span>(&#123;<span class="hljs-attr">map</span>:texture&#125;) <span class="hljs-comment">//使用材质</span><br><span class="hljs-keyword">const</span> mesh = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">Mesh</span>(geometry, material)<br></code></pre></td></tr></table></figure><p><strong>TextureLoader</strong> 可以在第一个参数后添加三个function用来处理加载材质的生命周期</p><ul><li>load -当材质成功加载后触发</li><li>progress -材质加载中触发</li><li>error -材质加载失败触发</li></ul><h3 id="LoadingManager"><a href="#LoadingManager" class="headerlink" title="LoadingManager"></a>LoadingManager</h3><p>当加载字体、模型、材质时就需要一个全局的加载进度来告知用户哪些被加载完成了，这个功能已在three.js中集成，既<strong>LoadingManager</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> loadingManager = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">LoadingManager</span>()<br><span class="hljs-keyword">const</span> textureLoader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>(loadingManager)<br><span class="hljs-keyword">const</span> texture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/door/color.jpg&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>LoadingManager</strong>提供了许多事件可供监听,例如 <strong>onStart</strong>、<strong>onLoaded</strong>、<strong>onProgress</strong>、<strong>onError</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> loadingManager = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">LoadingManager</span>()<br>loadingManager.<span class="hljs-property">onStart</span> = <span class="hljs-function">()=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;onStart&quot;</span>)<br>&#125;<br>loadingManager.<span class="hljs-property">onLoaded</span> = <span class="hljs-function">()=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;onLoaded&quot;</span>)<br>&#125;<br>loadingManager.<span class="hljs-property">onProgress</span> = <span class="hljs-function">()=&gt;</span>&#123;<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;onProgress&quot;</span>)<br>&#125;<br><span class="hljs-keyword">const</span> textureLoader = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">THREE</span>.<span class="hljs-title class_">TextureLoader</span>(loadingManager)<br><span class="hljs-keyword">const</span> texture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;/textures/door/color.jpg&#x27;</span>)<br></code></pre></td></tr></table></figure><p>实际上，在写完这些代码后你会发现仅仅触发 “onStart”和”onProgress” ，Loaded事件并未被触发&#x2F;</p><div align="center"> <img src="/2023/02/19/three-js-9-texture/log.png" class=""> </div><h3 id="UV-UNWRAPPER"><a href="#UV-UNWRAPPER" class="headerlink" title="UV UNWRAPPER"></a>UV UNWRAPPER</h3><p>了解 <strong>UV Unwrapping</strong> 之前先来了解以下 <strong>UV map（贴图)</strong> 和 <strong>UV mapping(映射)</strong></p><p>UV Map 是包裹在3D模型上的材质，创建UV 贴图的过程就叫做UV Unwrapping(拆图)</p><div align="center"> <img src="/2023/02/19/three-js-9-texture/uv.png" class=""> </div><blockquote><p>U和V指的是2D空间的水平和垂直轴，因为X、Y、Z已经在3D空间中使用</p></blockquote><p>UV mapping即是将 3D网格转换为2D信息，用于指定材质如何”贴在几何体上”</p><p>类似Three.js 内置的 <code>BoxBufferGeometry</code> UV 坐标已经被指定过，可以用 <code>geometry.attributes.uv</code> 访问</p><div align="center"> <img src="/2023/02/19/three-js-9-texture/coodinate.png" class=""> </div><p>可以看到在这个 <code>Float32Array</code> 里 <code>itemSize = 2</code>，因为 UV 坐标是 2D 的</p><p>如果你创建了自己的几何体，你就需要自己指定 UV coordinates(坐标),当你使用 3D 建模软件建模时，UV Unwrapping 也是必不可少的一步</p><h2 id="4-材质变换"><a href="#4-材质变换" class="headerlink" title="4.材质变换"></a>4.材质变换</h2><h3 id="4-1-重复"><a href="#4-1-重复" class="headerlink" title="4.1 重复"></a>4.1 重复</h3><p>我们可以用 <code>repeat</code> 属性让材质重复，它是一个  <code>Vector2</code> 的属性</p><div align="center"> <img src="/2023/02/19/three-js-9-texture/beRepet.png" class="" width="400"> </div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> colorTexture = textureLoader.<span class="hljs-title function_">load</span>(<span class="hljs-string">&#x27;...&#x27;</span>)<br><br>colorTexture.<span class="hljs-property">repeat</span>.<span class="hljs-property">x</span> = <span class="hljs-number">2</span><br>colorTexture.<span class="hljs-property">repeat</span>.<span class="hljs-property">y</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><div align="center">  </div><p>注意默认情况下，材质不会重复，采用最后一个材质像素拉伸适应几何体，这也是为什么上面设置 <code>repet</code> 属性后的怪异行为。我们可以给 <code>wrapS</code> 和 <code>wrapT</code> 属性设置 <code>Three.RepeatWrapping</code>改变重复方式 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">colorTexture.<span class="hljs-property">wrapS</span> = <span class="hljs-title class_">Three</span>.<span class="hljs-property">RepeatWrapping</span><br>colorTexture.<span class="hljs-property">wrapT</span> = <span class="hljs-title class_">Three</span>.<span class="hljs-property">RepeatWrapping</span><br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/02/19/three-js-9-texture/wrap.png" class="" width="400"> </div><p>我们也可以使用 <code>THREE.MirroredRepeatWrapping</code> 达到重复的目的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">colorTexture.<span class="hljs-property">wrapS</span> = <span class="hljs-title class_">Three</span>.<span class="hljs-property">MirroredRepeatWrapping</span><br>colorTexture.<span class="hljs-property">wrapT</span> = <span class="hljs-title class_">Three</span>.<span class="hljs-property">MirroredRepeatWrapping</span><br></code></pre></td></tr></table></figure><h3 id="4-2-偏移"><a href="#4-2-偏移" class="headerlink" title="4.2 偏移"></a>4.2 偏移</h3><p>要偏移一个材质使用 <code>offset</code> 属性设置，这个属性也是一个 <code>Vector2</code> 的类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">colorTexture.<span class="hljs-property">offset</span>.<span class="hljs-property">x</span> = <span class="hljs-number">0.5</span><br>colorTexture.<span class="hljs-property">offset</span>.<span class="hljs-property">y</span> = <span class="hljs-number">0.5</span><br></code></pre></td></tr></table></figure><div align="center"> <img src="/2023/02/19/three-js-9-texture/offsetxy.png" class="" width="400"> </div><h3 id="4-3-旋转"><a href="#4-3-旋转" class="headerlink" title="4.3 旋转"></a>4.3 旋转</h3><p>使用 <code>rotation</code> 属性旋转材质。注意单位是 rad(弧度)</p><div align="center"> <img src="/2023/02/19/three-js-9-texture/rotate.png" class="" width="400"> </div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">colorTexture.<span class="hljs-property">rotation</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>旋转时是按照 pivot point (轴心) 旋转的。可以使用 <code>center</code> 属性修改轴心，这个属性是 <code>Vector2</code> 类型的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">colorTexture.<span class="hljs-property">center</span>.<span class="hljs-property">x</span> = <span class="hljs-number">0.5</span><br>colorTexture.<span class="hljs-property">center</span>.<span class="hljs-property">y</span> = <span class="hljs-number">0.5</span><br></code></pre></td></tr></table></figure><h3 id="4-4-filtering-and-mipmapping"><a href="#4-4-filtering-and-mipmapping" class="headerlink" title="4.4 filtering and mipmapping"></a>4.4 filtering and mipmapping</h3><p>当你把 camera 移动至立方体的顶端至几乎看不见的时候就会发现材质变得模糊，这是因为 <strong>filtering</strong> 和 <strong>mipmapping(多级渐远纹理)</strong> 特性</p><p><strong>mipmapping</strong> 是把一个材质宽高不断减半细分的技术，直到得到 1x1 像素的材质分量。这些材质分量会被送到 GPU 内部，并由 GPU 决定最适合显示的材质分量</p><p>这些过程会被 Three.js 和 GPU 自动接管，不过我们任然能改变两种算法来达到合适的显示效果</p><ol><li><p>minification filtering<br>  当camera与纹理表面距离变的更远时就会发生这种情况，我们可以使用材质的 <code>minFilter</code> 属性来改变 filter. 它有下面六个取值</p><ul><li>THREE.NearestFilter</li><li>THREE.LinearFilter</li><li>THREE.NearestMipmapNearestFilter</li><li>THREE.NearestMipmapLinearFilter</li><li>THREE.LinearMipmapNearestFilter</li><li>THREE.LinearMipmapLinearFilter(default)</li></ul></li><li><p>Magnification filtering<br> 当camera与纹理表面距离变的更远时就会发生这种情况，我们可以使用材质的 <code>magFilter</code> 属性改变 filter. 它有两种取值</p><ul><li>THREE.NearestFilter</li><li>THREE.LinearFilter (default)</li></ul></li></ol><p>当我们在 <strong>minFilter</strong> 使用 <strong>THREE.NearestFilter</strong> 时就不需要  mipmaps 了， 使用 <code>colorTexture.generateMipmaps = false</code> 来禁止生成 mipmaps</p><h2 id="5-材质优化"><a href="#5-材质优化" class="headerlink" title="5.材质优化"></a>5.材质优化</h2><p>材质图片的大小可能很大，所以我们可以使用 TinyPNG 做一个压缩</p>]]></content>
    
    
    
    <tags>
      
      <tag>three.js</tag>
      
      <tag>web</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS - Box Model</title>
    <link href="/2021/11/03/CSS-Box-Model/"/>
    <url>/2021/11/03/CSS-Box-Model/</url>
    
    <content type="html"><![CDATA[<p><em>CSS 显示的所有内容都是一个’盒子’，所以了解 CSS 盒模型工作原理是 学习CSS 的基本功</em></p><p>假如你写了这段 HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs HTML"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span> 这是一段简短的文字 <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后添加了一段 CSS 样式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs CSS"><span class="hljs-selector-tag">p</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>    bordere:<span class="hljs-number">1px</span> solid;<br>&#125;<br></code></pre></td></tr></table></figure><iframe id="cp_embed_WNRemxN" src="//codepen.io/web-dot-dev/embed/WNRemxN?height=300&theme-id=33713&slug-hash=WNRemxN&default-tab=default_tabs&embed-version=2" scrolling="no" frameborder="no" height="300" allowTransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe><p>像上面看到的那样，文本内容会溢出到边框外。打开调试器会发现宽度为 142px 左右，而不是设定的 100px。为什么会这样呢？盒模型是 CSS 的基本概念，理解它是如何运作的。更重要的是，你学会如何利用它后才能写出看起来符合你预期的 CSS，不然就会出现各种诡异的行为（</p><p>你要记住，在网页中，所有用 CSS 显示的元素都会被浏览器解释为一个 “box”</p><h2 id="Content-and-sizing-内容和大小"><a href="#Content-and-sizing-内容和大小" class="headerlink" title="Content and sizing | 内容和大小"></a>Content and sizing | 内容和大小</h2><p>根据 display 取值、设置的大小和 Box 中的内容不同，Box在布局中的显示效果也不同。<br>内容指的就是由子元素、或纯文本内容生成的 Box。默认情况下，这些内容会影响 Box 的大小</p><p>你可以使用用 extrinsic sizing （译为外部大小，即指 width 属性） 控制元素的 content 大小，或者让浏览器根据 content 的大小来决定 intrinsic sizing (译为固有大小) 自主决定</p><iframe id="cp_embed_abpoMBL" src="//codepen.io/web-dot-dev/embed/abpoMBL?height=600&theme-id=33713&slug-hash=abpoMBL&default-tab=default_tabs&embed-version=2" scrolling="no" frameborder="no" height="600" allowTransparency="true" allowfullscreen="true" class="cp_embed_iframe" style="width: 100%; overflow: hidden;"></iframe>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript函数传参时的值传递与引用传递</title>
    <link href="/2020/05/19/JavaScript%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E6%97%B6%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <url>/2020/05/19/JavaScript%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E6%97%B6%E7%9A%84%E5%80%BC%E4%BC%A0%E9%80%92%E4%B8%8E%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<blockquote><p>ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数</p></blockquote><p>一开始对这句话没有什么概念，只是简单的当成与其它语言差不多的“Feature”。但后来在实际开发中踩了个大坑才对这个问题深究。</p><p>先来看一段简单的代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">function <span class="hljs-built_in">changeColor</span>(<span class="hljs-attribute">color</span>)&#123;<br>    <span class="hljs-attribute">color</span> = <span class="hljs-string">&quot;blue&quot;</span><br>&#125;<br><span class="hljs-selector-tag">var</span> Mycolor = <span class="hljs-string">&quot;green&quot;</span><br><span class="hljs-function"><span class="hljs-title">changeColor</span><span class="hljs-params">(Mycolor)</span></span><br>console<span class="hljs-selector-class">.log</span>(Mycolor)<br></code></pre></td></tr></table></figure><p><img src="https://sm.ms/image/pea53jUxZlRgEd1" alt="图片.png"></p><p>毫无意外，输出结果是“green”。  </p><p>在其它编程语言中也是一样的，函数传参时默认只传值。</p><p>但如果我们传入一个<strong>对象</strong>呢？</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">function <span class="hljs-built_in">changeColor</span>(_obj)&#123;<br>    _obj<span class="hljs-selector-class">.color</span> = <span class="hljs-string">&quot;blue&quot;</span><br>&#125;<br><span class="hljs-selector-tag">var</span> Mycolor = &#123;<span class="hljs-attribute">color</span>:<span class="hljs-string">&quot;green&quot;</span>&#125;<br><span class="hljs-function"><span class="hljs-title">changeColor</span><span class="hljs-params">(Mycolor)</span></span><br>console<span class="hljs-selector-class">.log</span>(Mycolor.<span class="hljs-attribute">color</span>)<br></code></pre></td></tr></table></figure><p><img src="https://sm.ms/image/FaejLZhXbgUzuHv" alt="图片.png"></p><p>然而，奇怪的是输出的Mycolor.color被改变了（从green - &gt; blue）。</p><p>那是否可以认为调用函数传参的过程中传递了Mycolor的地址呢？但这不就与开头定义相悖了吗？</p><p>其实并不是，在上面一段代码中函数传递的依然是值，只不过传的值不是“Mycolor”，而是Mycolor引用（地址）的拷贝。</p><p>也就是拷贝了一份Mycolor的引用传进去。不信?来看下一段代码</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">function <span class="hljs-built_in">changeColor</span>(_obj)&#123;<br>    _obj<span class="hljs-selector-class">.color</span> = <span class="hljs-string">&quot;blue&quot;</span><br>    _obj = new <span class="hljs-built_in">Object</span>()<br>    _obj<span class="hljs-selector-class">.color</span> = <span class="hljs-string">&quot;white&quot;</span><br>&#125;<br><span class="hljs-selector-tag">var</span> Mycolor = &#123;<span class="hljs-attribute">color</span>:<span class="hljs-string">&quot;green&quot;</span>&#125;<br><span class="hljs-function"><span class="hljs-title">changeColor</span><span class="hljs-params">(Mycolor)</span></span><br>console<span class="hljs-selector-class">.log</span>(Mycolor.<span class="hljs-attribute">color</span>)<br></code></pre></td></tr></table></figure><p>上面的代码中只改变了两行，就是给_obj赋予了一个新的空Object，并且增加了color属性，赋值为“white”。</p><p><img src="https://sm.ms/image/qcVtwJejFfBnprZ" alt="图片.png"></p><p>再来看看输出结果  </p><p>输出依然是“blue”，那么这也就可以证明了传递的其实是<strong>Mycolor的地址的拷贝</strong>，并不是将Mycolor的引用（地址）传递了过去，</p><p>形参_obj和Mycolor指向的同一个Object地址，所以改变 _obj属性的值，Mycolor的值也会改变，但如果给 _obj赋予一个新的值，那 _obj就不会与Mycolor关联了。</p><p>手码不易，点个赞👍吧</p><p>参考资料：</p>]]></content>
    
    
    <categories>
      
      <category>网站建设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSSmargin:auto踩坑</title>
    <link href="/2020/03/29/CSSmargin/"/>
    <url>/2020/03/29/CSSmargin/</url>
    
    <content type="html"><![CDATA[<p>css中得margin如果指定左右auto的话就能就能实现元素居中效果</p><p><img src="https://i.loli.net/2020/03/29/1KGB9cfxNd5EFQk.png"></p><p>闲着的时候做的一个书单</p><p>但是，auto居中效果前提是必须<strong>给该元素指定一个宽度</strong>才能生效。比如width:50%</p><p>给行内元素(inline)设置上下margin时即使页面上会显示margin的存在，但是<strong>不会</strong>有效果。 因为行内元素只支左右的margin，而不支持上下的</p><hr><p>给margin的左右赋值auto后，该元素就不能使用float了，不然会产生逻辑错误</p>]]></content>
    
    
    <categories>
      
      <category>网站建设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>margin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP值传递和引用传递</title>
    <link href="/2020/03/28/PHP%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
    <url>/2020/03/28/PHP%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
    
    <content type="html"><![CDATA[<h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p>在php中，使用值传递传递函数参数的话，如果在函数内部改变形参的值，外部实参是不会发生改变的。也就是说实参传过来的值被拷贝了一份作为形参调用</p><p><img src="https://i.loli.net/2020/03/28/vjlOuiUZVnaRsAB.png"></p><p>即使$value被改变了，外部的实参也不会收到影响</p><h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>什么是值传递：</p><p>当在函数中传递一个实参时，若在形参中使用&amp;$varb的语法则这个形参会获得实参的引用。其中”&amp;”符号就是高数解释器传过来的是一个实参的引用</p><p><img src="https://i.loli.net/2020/03/28/38Vj27yeGJpHkLF.png"></p><p>简单的将形参中的**$value<strong>改成</strong>&amp;$value**就能发现他们的不同了</p>]]></content>
    
    
    <categories>
      
      <category>网站建设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP中$this和self的区别</title>
    <link href="/2020/03/28/PHP%E4%B8%AD$this%E5%92%8Cself%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2020/03/28/PHP%E4%B8%AD$this%E5%92%8Cself%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="this"><a href="#this" class="headerlink" title="$this"></a>$this</h2><p>[toc]</p><p>$this提供了对自身类的引用，可以访问自身类下的所有的成员。属性&#x2F;方法</p><h2 id="self"><a href="#self" class="headerlink" title="self"></a>self</h2><p>self和$this一样，保存了自身类的引用，也可以访问自身类下的所有成员。</p><h2 id="对象操作符"><a href="#对象操作符" class="headerlink" title="对象操作符"></a>对象操作符</h2><p>“-&gt;”是php中内置的符号，它和$this一起使用来访问类的成员（属性或方法）</p><p>“::”是访问类中静态属性的操作符，可以和self结合使用访问类的静态成员</p><h2 id="this和self的区别："><a href="#this和self的区别：" class="headerlink" title="this和self的区别："></a>this和self的区别：</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs php">使用 <span class="hljs-variable language_">$this</span> -&gt; member 来访问自身类下的非静态成员<br>使用 <span class="hljs-built_in">self</span>::<span class="hljs-variable">$member</span> 来访问自身类下的静态成员<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网站建设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习</title>
    <link href="/2020/03/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2020/03/28/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="快速机器学习-toc"><a href="#快速机器学习-toc" class="headerlink" title="快速机器学习[toc]"></a>快速机器学习[toc]</h1><h2 id="什么是机器学习？"><a href="#什么是机器学习？" class="headerlink" title="什么是机器学习？"></a>什么是机器学习？</h2><p>机器学习是科学的一个分支，它研究的是使用模式和推理来执行特定任务的算法和系统，而不是显式地使用程序化指令。机器学习有各种不同的用例，从图像识别到文本生成。大多数机器学习任务概括为以下两种学习类型中的一种:</p><ul><li>Supervised learning(监督学习)：使用标记数据训练模型。训练数据集的标签表示每个数据观察属于的类&#x2F;类别。训练后，该模型应该能够预测新数据观测的标签(来自与训练数据相同的总体分布)。<ul><li>例如:假设你正在训练一个机器学习模型来预测一幅图片是否包含一个湖。使用监督学习，您可以在一个图片数据集上训练一个模型，其中每个图片的标签是“Yes”(如果它包含一个湖)，或者是“No”(如果它不包含湖)。经过训练，该模型将能够拍摄照片，并确定它是否包含一个湖。</li></ul></li></ul><p>苹果  桃子  香蕉</p>]]></content>
    
    
    <categories>
      
      <category>计算机科学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>手撕webpack</title>
    <link href="/2020/03/28/%E6%89%8B%E6%92%95webpack/"/>
    <url>/2020/03/28/%E6%89%8B%E6%92%95webpack/</url>
    
    <content type="html"><![CDATA[<p>console.log(this)</p><h1 id="快速上手webpack-toc"><a href="#快速上手webpack-toc" class="headerlink" title="快速上手webpack[toc]"></a>快速上手webpack[toc]</h1><h2 id="webpack是什么？"><a href="#webpack是什么？" class="headerlink" title="webpack是什么？"></a>webpack是什么？</h2><blockquote><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle</p></blockquote><p>以上就是webpack官网的概念，简单地说，webpack就是个<strong>模块打包器</strong>现代前端开发为了方便，会在依赖关系上大作文章，以此来提高代码的可读性以及解耦。对程序员来说这是个很好的习惯，但对浏览器来说可有点难受了。</p><p>如果一个页面需要加载十几个js，十几个css文件的话那么网站的加载速度就会拖慢。而webpack就能将数个静态资源文件打包在几个静态资源文件中，这样就减少了HTTP请求，从而加快了网站加载速度。</p><p>当然，webpack并不仅仅只是将静态资源打包在几个文件中，它也能把浏览器不能识别的静态资源（如sass，less）转换成浏览器容易识别的静态资源</p><p><img src="https://i.loli.net/2020/03/28/ZtLJEKXfYbTDISW.png" alt="webpack工作方式"></p><h3 id="快速使用webpack"><a href="#快速使用webpack" class="headerlink" title="快速使用webpack"></a>快速使用webpack</h3><p>webpack包是托管在npm上的，所以我们需要用到npm包管理器，为了防止安装过程因网速导致一大堆ERROR，请在安装之前将npm镜像设置为淘宝镜像。当然也可以使用yarn安装。</p>]]></content>
    
    
    <categories>
      
      <category>网站建设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phpGD库图像处理</title>
    <link href="/2020/03/27/phpGD%E5%BA%93%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
    <url>/2020/03/27/phpGD%E5%BA%93%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="phpGD库操作"><a href="#phpGD库操作" class="headerlink" title="phpGD库操作"></a>phpGD库操作</h1><h2 id="简介及安装配置"><a href="#简介及安装配置" class="headerlink" title="简介及安装配置"></a>简介及安装配置</h2><blockquote><p>PHP并不仅限于创建HTML输出，它也可以创建和处理包括GIF，PNG， JPEG， WBMP 以及XPM在内的多种格式的图像。更加方便的是，PHP可以直接将图像数据流输出到浏览器。要想在PHP中使用图像处理功能，这时候就需要使用PHP提供的GD函数库。</p></blockquote><h3 id="GD库的安装及配置"><a href="#GD库的安装及配置" class="headerlink" title="GD库的安装及配置"></a>GD库的安装及配置</h3><ul><li>配置PHP配置文件，开启extension&#x3D;php_gd2.dll</li><li>设置extension_dir&#x3D;”ext目录所在的位置”</li></ul><p>重启服务器检测gd扩展是否开启<code>var_dump(extension_loaded(&#39;gd));</code></p><p>检测函数是否可使用</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">var<span class="hljs-number">_</span>dump(<span class="hljs-keyword">function</span><span class="hljs-number">_</span><span class="hljs-keyword">exists</span>(<span class="hljs-string">&#x27;gd_info&#x27;</span>));<br></code></pre></td></tr></table></figure><p>检查gd库信息</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">var_dump</span>(<span class="hljs-title">gd_info</span>());</span><br></code></pre></td></tr></table></figure><p>查看所有包含的函数</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">print_r</span>(<span class="hljs-title">get_defined_functions</span>());</span><br></code></pre></td></tr></table></figure><h2 id="创建流程"><a href="#创建流程" class="headerlink" title="创建流程"></a>创建流程</h2><h3 id="创建画布"><a href="#创建画布" class="headerlink" title="创建画布"></a>创建画布</h3><p>使用<code>imagecreatetruecolor($width,$height)</code>来创建一个画布  </p><blockquote><p>创建一个画布，成功返回图像资源标识符，错误返回FALSE。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-variable">$image</span> = <span class="hljs-title function_ invoke__">imagecreatetruecolor</span>(<span class="hljs-number">500</span>,<span class="hljs-number">300</span>);<br></code></pre></td></tr></table></figure><p>注：<code>imagecreate</code>和<code>imagecreatetruecolor</code>都会创建一个画布，但不同的是前者创建一个空白画布，而后者则会创建一个黑色画布</p></blockquote><p>使用imagecolorallocate ( resource $image , int $red , int $green , int $blue )为一画布分配颜色  </p><blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//创建颜色 $red = imagecolorallocate($image,255,0,0)</span><br></code></pre></td></tr></table></figure></blockquote><p>开始绘画，这里尝试使用<code>imagechar ( resource $image , int $font , int $x , int $y , string $c , int $color )</code>水平的画出一个字符</p><blockquote><p>imagechar bool型</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">imagechar</span>(<span class="hljs-variable">$image</span>,<span class="hljs-number">5</span>,<span class="hljs-number">50</span>,<span class="hljs-number">10</span>,<span class="hljs-string">&#x27;K&#x27;</span>,<span class="hljs-variable">$red</span>);<br></code></pre></td></tr></table></figure><p>注：若要画出一个字符串请使用imagestring()</p></blockquote><p>将绘画的结果告诉浏览器以图片的形式显示</p><blockquote><p>用imagejpeg输出一个图像到浏览器或文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">header</span>(<span class="hljs-string">&#x27;content-type:image/jpeg&#x27;</span>);<span class="hljs-comment">//告诉浏览器以图片的形式显示 imagejpeg($image);//输出图像</span><br></code></pre></td></tr></table></figure></blockquote><p>销毁资源</p><blockquote><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-title function_ invoke__">imagedestroy</span>(<span class="hljs-variable">$image</span>);<br></code></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/03/27/kpE5tI9FNRbGTm6.png" alt="图片.png"></p><p>输出结果：</p></blockquote><h2 id="使用系统字体绘制内容"><a href="#使用系统字体绘制内容" class="headerlink" title="使用系统字体绘制内容"></a>使用系统字体绘制内容</h2><p>如果使用以上方法绘制文字的话就会有两个问题</p><ol><li><ol><li>画布黑色</li><li>字体太小</li></ol></li></ol><p>[toc]</p>]]></content>
    
    
    <categories>
      
      <category>网站建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统导论</title>
    <link href="/2020/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"/>
    <url>/2020/03/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="1-5计算机系统性能评价"><a href="#1-5计算机系统性能评价" class="headerlink" title="1.5计算机系统性能评价"></a>1.5计算机系统性能评价</h2><ul><li><p>吞吐率：表示在单位时间内所完成的工作量，例如：带宽</p></li><li><p>响应时间：指从作业提交开始到作业完成所用的时间，例如:执行时间、等待时间。</p></li><li><p>存储容量：存储器存放的二进制位数，反应存储器存储能力的指标。</p></li><li><p>机器字长： CPU一次处理的二进制位，反应CPU工作能力</p></li><li><p>指令字长： 一条指令用多少位二进制数表示</p></li><li><p>存储字长： 一个存储单元能存放的二进制位数。</p></li></ul><h2 id="1-6数制相互转换"><a href="#1-6数制相互转换" class="headerlink" title="1.6数制相互转换"></a>1.6数制相互转换</h2><p>例1：<br>将（1010111011.0010111）2转换为八进制</p><p>001</p><p>010</p><p>111</p><p>001</p><p>.</p><p>001</p><p>011</p><p>100</p><p>1</p><p>2</p><p>7</p><p>3</p><p>.</p><p>1</p><p>3</p><p>4</p><p>例2：<br>将（2754.41）8转换为二进制</p><p>2</p><p>7</p><p>5</p><p>4</p><p>.</p><p>4</p><p>1</p><p>010</p><p>111</p><p>101</p><p>100</p><p>.</p><p>100</p><p>001</p><h2 id="2-2二进制数的表示"><a href="#2-2二进制数的表示" class="headerlink" title="2.2二进制数的表示"></a>2.2二进制数的表示</h2><ul><li><p>真值：数的真实值。例如: +1011 , -1011 , +0.1010 , -0.1010</p></li><li><p>机器数：真值的符号位数字化成0表示正1表示负。例如: 0,1011 、1,1011 、 0.1010 、 1,1010</p><h3 id="2-2-3机器数的表示"><a href="#2-2-3机器数的表示" class="headerlink" title="2.2.3机器数的表示"></a>2.2.3机器数的表示</h3><ul><li><p>原码：等于机器数</p></li><li><p>反码：正数反码等于原码，负数反码等于原码符号位不变数值位取反。</p></li><li><p>补码：正数补码等于原码，负数补码等于反码末位加1。</p></li></ul><h3 id="2-2-4定点数和浮点数的表示"><a href="#2-2-4定点数和浮点数的表示" class="headerlink" title="2.2.4定点数和浮点数的表示"></a>2.2.4定点数和浮点数的表示</h3><ul><li><p>定点数概念：指计算机中的小数点位置固定不变的数的表示方式。</p></li><li><p>分类</p><ul><li><p>定点整数：小数点固定在数的最低位之后。设字长为8位,能表示的数值范围为: 0000000 - 01111111即0 - (27 - 1 )</p></li><li><p>定点小数: 小数点固定在数的最高位之前。设字长为8位,能表示的范围为: 0.00000 ~ 1111111即0 - (1 - 2-7 )</p></li><li><p>浮点数概念：指计算机中的小数点位置不是固定的，或者说是“浮动”的。</p></li><li><p>数的表示方式：通过阶码和尾数表示：N&#x3D;2±E × (±S)</p></li><li><p>E称为<strong>阶码</strong>，它是一个二进制正整数;</p></li><li><p>E前的土为阶码的符号，称为<strong>阶符</strong>(Ef);表示了是扩大还是缩小，正数则为扩大，负数则为缩小</p></li><li><p>S称为<strong>尾数</strong>，它是一个二进制正小数;</p></li><li><p>S前的±为尾数的符号，称为<strong>尾符</strong>(Sf)</p></li><li><p>“2”是阶码E的<strong>底数</strong>。</p></li></ul></li></ul></li></ul><p><img src="https://i.loli.net/2020/03/24/ZEeqYbAvSNKdQxr.png" alt="例子"></p><h2 id="2-3十进制数表示"><a href="#2-3十进制数表示" class="headerlink" title="2.3十进制数表示"></a>2.3十进制数表示</h2><ul><li><p>BCD码(二进制 -&gt; 十进制)：用四位二进制代码对一位十进制数进行编码，它既具有二进制码的形式(四位二进制码)，又有十进制数的特点(每四位二进制码是一位十进制数)。</p><p>例：（931）10 &#x3D; (?)BCD</p><p>9</p><p>3</p><p>1</p><p>1001</p><p>0011</p><p>0001</p><p>= (1001 0011 0001)BCD</p></li></ul><h2 id="2-4字符编码"><a href="#2-4字符编码" class="headerlink" title="2.4字符编码"></a>2.4字符编码</h2><ul><li>ASCII编码：用一个字节表示，最高位置0，只用低七位，收集了128个字符和符号。当ASCII码的最高位取1时，又可表示128个字符,这种编码称为扩展ASCII码， 主要是一些制符</li></ul><p><img src="https://i.loli.net/2020/03/24/9ksDlhywvS3tRdC.png" alt="p1"></p><h3 id="2-4-2-文字编码"><a href="#2-4-2-文字编码" class="headerlink" title="2.4.2 文字编码"></a>2.4.2 文字编码</h3><ul><li><p>文字编码（↓汉字的输入码（外码））</p><ul><li><p>数字编码： 如电报码或国家标准GB2312 - 80规定的汉字交(国标、区位码)来输入汉字都是数字编码。数字编码法不会产生重码，但难以记忆不易推广</p></li><li><p>字音编码： 一种基于汉语拼音的编码方法。由于同音字很多，因此这种编码方法会产生很多重码</p></li><li><p>字形编码:根据汉字的字形而给出编码方法。把汉宇分解为字根、部首、偏旁、笔划等基本单位，每种基本单位与健盘上的一个健相对应，从而构成一个汉字的编码。这种输人法不易记忆但具有重码少，输入速度快等优点。</p></li><li><p>形音编码:形音编码法吸取字音编码和字形编码两种编码的特点，使编码规则简单，重码少。</p></li><li><p>汉字的机内码:是供计算机系统内部进行存储、加工处理传输统一使用的代码。目前使用最广泛的是变形的国标码将GB2312-80交换码的两个字节的最高位分别置为1而得到的。</p></li><li><p>汉字字形码:是指汉字字形点阵的代码，用于汉字的显示 和打印。目前汉字字形的产生方式大多是数字式，即以点阵方式形成汉字。</p></li><li><p>汉字字库:是汉字字形数字化后，以二进制文件形式存储在存储器中而形成的汉字字模库。</p></li></ul><p><img src="https://i.loli.net/2020/03/24/u4qSgioHh81CxIs.png" alt="p2"></p></li></ul><h2 id="2-5数据基本运算"><a href="#2-5数据基本运算" class="headerlink" title="2.5数据基本运算"></a>2.5数据基本运算</h2><ul><li>算数移位</li></ul><p> </p><p>码制</p><p>添补代码</p><p>正数</p><p>原码、补码、反码</p><p>0</p><p>负数</p><p>原码</p><p>0</p><p>补码</p><p>左移 添0</p><p>右移 添1 </p><p>反码</p><p>添1</p><ul><li><p>逻辑位移</p><ul><li>逻辑左移 低位添0，高位移丢</li><li>逻辑右移 高位添0，低位移丢</li></ul><p>例如</p><p>01010011</p><p> </p><p>10110010</p><p>逻辑左移</p><p>1010011<strong>0</strong></p><p>逻辑右移</p><p><strong>01</strong>011001</p><p>算术左移</p><p>0010011<strong>0</strong></p><p>逻辑右移</p><p><strong>11</strong>011001（补码）</p><h3 id="2-5-3加减运算"><a href="#2-5-3加减运算" class="headerlink" title="2.5.3加减运算"></a>2.5.3加减运算</h3><ol><li>加法(补码)</li></ol><p><strong>整数</strong> : [A]补 + [B]补 &#x3D; [A+B]补（mod 2n+1)<br><strong>小数</strong> : [A]补 + [B]补 &#x3D; [A+B]补（mod 2）</p><ol start="2"><li><p>减法<br>A - B &#x3D; A + (-B)<br><strong>整数</strong> : [A - B]补 &#x3D; [A + (-B)]补 &#x3D; [A + (-B)]补（mod 2n+1)<br><strong>小数</strong> : [A - B]补 &#x3D; [A + (-B)]补 &#x3D; [A + (-B)]补（mod 2n+1)</p><blockquote><p>连同符号位一起相加，符号位产生的进位自然丢掉</p></blockquote></li></ol><ul><li><p><strong>例子一</strong></p><p>设 _A_= 0.1011 , <em>B</em> &#x3D; -0.0101 求 [A+B]补</p></li></ul><p>解:</p><p>[A]补</p><p>=</p><p>0.1011</p><p> </p><p> </p><p>+[B]补</p><p>=</p><p>1.1011</p><p> </p><p>[A]补</p><p>+[B]补</p><p>=</p><p>10.0110</p><p>= [A]补+[B]补</p><p>注：</p><p>A + B</p><p>=</p><p>0.0110</p><ul><li><strong>例子二</strong><br><img src="https://i.loli.net/2020/03/24/eZOikX1xr2G5JaL.png" alt="例子二"></li></ul></li></ul><h2 id="3-1-程序的链接"><a href="#3-1-程序的链接" class="headerlink" title="3.1 程序的链接"></a>3.1 程序的链接</h2><ul><li><p>程序的执行过程<br><img src="https://i.loli.net/2020/03/24/cUK5j4AFI7gYB3b.png"><br><img src="https://i.loli.net/2020/03/24/ZxXyOg9TQfGJhtB.png"></p><ul><li><p>程序的执行<br>指令：计算机的一条命令<br>指令的一般格式：操作码字段 - 地址码字段</p><blockquote><ul><li>操作码： 作何操作</li><li>地址吗：操作数存放的位置</li></ul></blockquote></li></ul><p>寻址方式：<br>确定<strong>本条指令</strong>的<strong>操作数地址</strong><br><strong>下一条</strong>欲执行指令的<strong>指令地址</strong><br><img src="https://i.loli.net/2020/03/24/eQAkM6qcBgIZoWh.png" alt="图片.png"></p></li></ul><p>[toc]</p>]]></content>
    
    
    <categories>
      
      <category>计算机科学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue笔记。</title>
    <link href="/2020/03/17/Vue%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/03/17/Vue%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Computed和methods"><a href="#Computed和methods" class="headerlink" title="Computed和methods"></a>Computed和methods</h2><p>在一个页面中，Computed不管被调用几次，实际上都只调用一次，且计算结果会缓存，但依赖改变依然会重新计算。而每次调用methods，实际上都会重新调用，所以页面中逻辑可以尽量写在Computed里然后通过插值方法调用（意识流文章×</p><h2 id="Component组件"><a href="#Component组件" class="headerlink" title="Component组件"></a>Component组件</h2><p>在一个Script中调用Vue.component()方法创建一个组件时此组件属于根组件，任意模板（template）中都能使用。</p><p>而如果在Component()方法中指定组件对象（compoent{}）创建组件，那么这个组件为局部组件，只能被父组件调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(&#123;<br>  <span class="hljs-attr">components</span>: &#123;<br>   <span class="hljs-attr">child</span>:&#123;<br><span class="hljs-attr">template</span>:&amp;#x60;&amp;lt;div&amp;gt;child&amp;lt;/div&amp;gt;&amp;#x60;<br><br>       &#125;<br>     &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>template中必须只能有一个根节点</li><li>子组件无法直接访问到父组件中的数据</li><li>组件中的data必须是一个函数</li></ul><h3 id="父子组件通信方式"><a href="#父子组件通信方式" class="headerlink" title="父子组件通信方式"></a>父子组件通信方式</h3><ul><li>【父-&gt;子】使用props属性(使用props传递逻辑值时记得在属性前加 : 例如 :myprops&#x3D;true。否则js会让你知道什么叫做黑魔法QAQ)</li><li>【父&lt;-子】父组件需申明一个事件并赋值，子组件再通过this.$emit(事件名)调用。例如this.$emit(get,1000)</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>当Vue实例中的data被修改时会调用beforeupdated()和updated()。而DOM树被修改时会重新循环生命周期并，此时mounted()就有很多的作用。</p><h2 id="vue-config-js"><a href="#vue-config-js" class="headerlink" title="vue.config.js"></a>vue.config.js</h2><ul><li>改了配置文件一定要重启服务器</li></ul><h3 id="反向代理设置"><a href="#反向代理设置" class="headerlink" title="反向代理设置"></a>反向代理设置</h3><p>vue中的反向代理设置实际上是通过node的中间件<a href="https://github.com/chimurai/http-proxy-middleware#proxycontext-config">http-proxy-middleware</a>实现的<br><img src="http://nanxfu.cn/wp-content/uploads/2020/03/1487693512.png" alt="QQ截图20200319223906.png" title="QQ截图20200319223906.png"></p><p>[toc]</p>]]></content>
    
    
    <categories>
      
      <category>网站建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Electron编译/打包流程</title>
    <link href="/2020/03/14/Electron%E7%BC%96%E8%AF%91/"/>
    <url>/2020/03/14/Electron%E7%BC%96%E8%AF%91/</url>
    
    <content type="html"><![CDATA[<p>写完一个electron项目后准备编译测试一下，结果遇到重重困难，一堆ERROR看的头疼，这里记录一下解决过程，方便看到这篇文章的人避免踩坑。</p><p>总所周知由于国情的原因，大部分开发者用npm都换成了淘宝源</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure><p>（咕咕咕）</p>]]></content>
    
    
    <categories>
      
      <category>软件工程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>博客代码更改记录</title>
    <link href="/2020/03/09/73/"/>
    <url>/2020/03/09/73/</url>
    
    <content type="html"><![CDATA[<ul><li>2020&#x2F;3&#x2F;22 越来越注重文章排版、可读性及插件拓展，博客已从typecho成功转移至wordpress</li></ul><p>一个图片背景一直盯着有点吃藕，所以就从Wallpaper engineer上下了个喜欢的动态视频，然后把背景的div标签改成了video。这样就实现了动态背景QwQ<img src="http://nanxfu.cn/wp-content/uploads/2020/03/2991057238.png" alt="QQ截图20200308195207.png" title="QQ截图20200308195207.png">不过由于video原本的限制，如果直接添加上去的话两边就会有白边，所以需要在style里添加<code>object-fit:fill</code>。这样看起来就舒服多了(｡･∀･)ﾉﾞ <img src="http://nanxfu.cn/wp-content/uploads/2020/03/2300815208.png" alt="QQ截图20200308195136.png" title="QQ截图20200308195136.png"></p><p>由于动态背景本质是视频，体积相对图片还是很大的，所以把background id加上去了，在视频没有加载出来之前，先把加载出来了的图片贴上去。等视频加载完成图片就被覆盖了，这样就可以实现伪·懒加载了（黑魔法(´ｰ∀ｰ`)</p><ul><li>有一个小bug就是因为把div标签换成了video，文章内header背景就不是文章的封面了。而是首页背景。(￣_,￣ )。算了 就先这样了，反正动态背景也不吃藕，以后想起来再加一下自定义搞个随机动态背景qwq</li></ul><p>附上代码： <code>&lt;video src=/usr/img/Watt.mp4 id= autoplay muted loop style=width:100%;height:100%;z-index:-1;position:relative;object-fit:fill;&gt;</code>然后因为nav栏在默认情况下是白色背景，这样的话nav栏就有点看不清，就在背景里取了个色，调了下背景颜色<br>[toc]</p><blockquote><p>2020.3.28 修复 categories点击后出现404错误</p><p>content_thumb 54行</p><p>echo esc_url(get_category_link($the_cat[0]-&gt;cat_ID));</p><p>替换为</p><p>$_home &#x3D; esc_url(home_url( ‘&#x2F;‘ );</p><p>esc_url(get_category_link($the_cat[0]-&gt;cat_ID));</p><p>echo esc_url(str_replace($_home,$_home . “index.php&#x2F;“,get_category_link($the_cat[0]-&gt;cat_ID)));</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网站建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>uikit下img组件height与width属性</title>
    <link href="/2020/03/07/uikit/"/>
    <url>/2020/03/07/uikit/</url>
    
    <content type="html"><![CDATA[<p>在使用uikit的img组件时我发现指定的height属性没用生效。width与height同时指定为100（原图为316X256）。 但在页面上实际渲染效果却只有100X81 <img src="http://nanxfu.cn/wp-content/uploads/2020/03/1871535963.png" alt="QQ截图20200306181300.png" title="QQ截图20200306181300.png"> <img src="http://nanxfu.cn/wp-content/uploads/2020/03/2727641762.png" alt="QQ截图20200306181300.png" title="QQ截图20200306181300.png"></p><hr><p>于是我打开chrome的调试工具检查了样式，发现原来时<strong>UIKIT自带的样式把height指定为了auto</strong></p><p><img src="http://nanxfu.cn/wp-content/uploads/2020/03/1711722119.png" alt="QQ截图20200306181523.png" title="QQ截图20200306181523.png"></p><p>经过我不断的实验，最终得知height的auto值是按width的比例换算。换算下来刚好为81px。 所以只要在标签里内联一个样式指定height样式就行了<code>style=height:100px</code></p><p>因为css的Specificity效果，内联样式就会覆盖外联样式 嗐 也怪我学艺不精(<em>&#x2F;ω＼</em>)</p>]]></content>
    
    
    <categories>
      
      <category>网站建设</category>
      
      <category>视觉设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Photoshop扒图（个人资料卡）</title>
    <link href="/2020/03/03/Photoshop%E6%89%92%E5%9B%BE(info)/"/>
    <url>/2020/03/03/Photoshop%E6%89%92%E5%9B%BE(info)/</url>
    
    <content type="html"><![CDATA[<p>在B站闲逛的时候发现了挺好看的个人简介封面，原作者是用Sketch做的，所以我就用Photoshop扒了一个练手,扒图的记录以后更上吧… 原图： <img src="http://nanxfu.cn/wp-content/uploads/2020/03/1156077689.png" alt="QQ截图20200302183843.png" title="QQ截图20200302183843.png"> 扒图： <img src="http://nanxfu.cn/wp-content/uploads/2020/03/3281054246.png" alt="扒图.png" title="扒图.png"></p><h2 id="扒图过程"><a href="#扒图过程" class="headerlink" title="扒图过程"></a>扒图过程</h2>]]></content>
    
    
    <categories>
      
      <category>视觉设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PhotoShop扒图（知乎读书封面）</title>
    <link href="/2019/12/02/PhotoShop%E6%89%92%E5%9B%BE/"/>
    <url>/2019/12/02/PhotoShop%E6%89%92%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在逛知乎时突然康见一个图片感觉设计不错，为了加强Photoshop使用的熟练度便尝试将它扒下来 <strong>原图：</strong> <img src="http://nanxfu.cn/wp-content/uploads/2019/12/2329276609.jpg" alt="v2-267dd85d36c8bbc06c3ef7be1d6b9b97_hd.jpg" title="v2-267dd85d36c8bbc06c3ef7be1d6b9b97_hd.jpg"> <strong>最终图：</strong> <img src="http://nanxfu.cn/wp-content/uploads/2019/12/1959932561.png" alt="Sourece" title="Sourece"></p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="基本图形"><a href="#基本图形" class="headerlink" title="基本图形"></a>基本图形</h3><p>1.首先新建一个项目然后找一张图片做背景，因为我电脑上刚好有一张图便直接拿来用了 <img src="http://nanxfu.cn/wp-content/uploads/2019/12/1763718710.jpeg" alt="素材" title="素材"></p><p><img src="http://nanxfu.cn/wp-content/uploads/2019/12/3575605518.png" alt="1.png" title="1.png"> 2.按下<strong>U</strong>快捷键调出<strong>矩形工具</strong>画出边框，然后同时选中矩形图形图层与背景图层按下<strong>V</strong>快捷键使用<strong>垂直居中对齐、水平居中对齐</strong>使边框在背景的中央位置 <img src="http://nanxfu.cn/wp-content/uploads/2019/12/339539811.png" alt="4.png" title="4.png"></p><p><img src="http://nanxfu.cn/wp-content/uploads/2019/12/153130169.png" alt="2.png" title="2.png"></p><p>3.再用矩形工具将中间大块矩形和两条直线画出并调整位置。</p><p><img src="http://nanxfu.cn/wp-content/uploads/2019/12/979246213.png" alt="5.png" title="5.png"></p><h3 id="文字穿透"><a href="#文字穿透" class="headerlink" title="文字穿透"></a>文字穿透</h3><p>4.选中中间大片白色的图层并点击图层面板下方<strong>创建蒙版图层</strong>按钮 <img src="http://nanxfu.cn/wp-content/uploads/2019/12/706534241.png" alt="6.png" title="6.png"></p><p>5.创建文字并选择合适字体排版后按住<strong>Ctrl</strong>将鼠标移至文字图层“T”图标上点击即可创建文字选区</p><p><img src="http://nanxfu.cn/wp-content/uploads/2019/12/1061550952.png" alt="7.png" title="7.png"></p><p>6.选中第四步创建的蒙版图层，然后用黑色油漆桶将选区涂黑并隐藏文字图层即可创建穿透文字。</p><p><img src="http://nanxfu.cn/wp-content/uploads/2019/12/2643584749.png" alt="QQ截图20191201173120.png" title="QQ截图20191201173120.png"></p><p><img src="http://nanxfu.cn/wp-content/uploads/2019/12/3433872185.png" alt="8.png" title="8.png"></p><p>咕咕咕…</p>]]></content>
    
    
    <categories>
      
      <category>Photoshop</category>
      
      <category>视觉设计</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RobotMaster（校内赛）赛程记录</title>
    <link href="/2019/11/09/RobotMaster/"/>
    <url>/2019/11/09/RobotMaster/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为我对硬件感兴趣，曾再高中划水摸鱼间了解过单片机。于是在比赛宣传（吐槽一下：其实我觉得主办方并没有过多的宣传，可能比较穷，毕竟开始报名的时候我身边的同学都不太了解这个比赛）的时候就和别班的同学一起组队了。这篇文章就是记录在准备赛事期间遇到的一些问题以及一些总结的经验。</p><p>因为比赛是面向全校的，所以大一的同学大部分必定都会吃亏。幸好我接触计科较早，在计科领域也认识了不少的dalao（首先感谢@Angelic47姐姐的帮助），所以在准备赛事的过程中也算比较顺利。毕竟为是初次接触单片机，就选了个最简单的题目：避障寻迹小车</p><h2 id="赛程记录"><a href="#赛程记录" class="headerlink" title="赛程记录"></a>赛程记录</h2><h3 id="复赛阶段"><a href="#复赛阶段" class="headerlink" title="复赛阶段"></a>复赛阶段</h3><p>复赛于11.24号 下午13:00开始。在距比赛还有40分钟开始时我们就赶到了场地，在调试的时候虽然表现比大部分场上的人来说较好，但对我来说依然不尽人意。</p><p>于是尽管赛事迫在眉睫，我们依然在不停地测试小车，不停地改程序。幸运的是轮到我们正式比赛的时候小车车的表现比我们预期的好很多，几乎是最完美的一次。</p><p>最终成绩排到第二名，第一名是学姐们的车。取得这个成绩也已经很满足了，接下来就是准备决赛。在这里先立个Flag，我们要冲着第一名去･ω･)ﾉ</p><h2 id="超声波避障模块"><a href="#超声波避障模块" class="headerlink" title="超声波避障模块"></a>超声波避障模块</h2><p>选购超声波模块的时候种类太多，就在淘宝马虎的看了一下参数，然后挑了个看起来性价比超高，牛拉吧唧的模块 HY-SRF05（也确实性价比比较高 性能稳定，测度距离精确。能和国外的SRF05,SRF02等超声波测距模相媲美。模块高精度，盲区（2cm）超近）</p><p>模块长这样：<br>（以后补图）</p><p><strong>0.原理解释</strong></p><ul><li>波发射器向某一方向发射超声波，在发射的同时开始计时，超声波在空气中传播，途中碰到障碍物就立即返回来，超声波接收器收到反射波就立即停止计时。根据<strong>S&#x3D;V*t</strong>就可以计算出被测物体离模块的距离。</li><li>公式推导：声音在20°C，空气中传播的速度为343m&#x2F;s。换算一下单位为<strong>0.0343cm&#x2F;μs</strong>。<br>设声波从发射到被接收的时间为<strong>T</strong>。则声波从发射到撞到被测物体所花费的时间为<strong>T&#x2F;2</strong>。则距离公式为<strong>S&#x3D;0.01715*T</strong></li></ul><p><strong>1. 丝印解释</strong></p><ul><li>_ECHO_：接收返回的信号，如果有信号，ECHO引脚便会输出高电平。高电平持续的时间就是超声波从发射到返回的时间。</li><li><em>TRIG</em>: 给TRIG引脚高于10μs的高电平信号时SR04模块测距功能便会被触发。</li><li><em>GND</em>: 接地引脚</li><li><em>VCC</em>: 接5V电源</li></ul><p><strong>2. 线路连接</strong></p><p><strong>3. 程序编写</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">float</span> <span class="hljs-title">Qifd</span><span class="hljs-params">(<span class="hljs-type">int</span> TrigPin,<span class="hljs-type">int</span> EchoPin,<span class="hljs-type">int</span> interval)</span></span><br><span class="hljs-function"><span class="hljs-comment">//超声波测距 返回一个float型数据。单位为cm</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">float</span> distance;<br><span class="hljs-type">int</span> pulse_;<br><br><span class="hljs-built_in">pinMode</span>(TrigPin, <span class="hljs-literal">OUTPUT</span>);<br><span class="hljs-comment">// 要检测引脚上输入的脉冲宽度，需要先设置为输入状态</span><br><span class="hljs-built_in">pinMode</span>(EchoPin, <span class="hljs-literal">INPUT</span>);<br><br><span class="hljs-comment">// 产生一个10us的高脉冲去触发TrigPin</span><br><span class="hljs-built_in">digitalWrite</span>(TrigPin, <span class="hljs-literal">HIGH</span>);<br><span class="hljs-built_in">delayMicroseconds</span>(<span class="hljs-number">10</span>);<br><span class="hljs-built_in">digitalWrite</span>(TrigPin, <span class="hljs-literal">LOW</span>);<br><span class="hljs-comment">// 检测脉冲宽度，并计算出距离</span><br>pulse_=<span class="hljs-built_in">pulseIn</span>(EchoPin, <span class="hljs-literal">HIGH</span>);<br>distance = <span class="hljs-number">0.01715</span>*pulse_;<br><span class="hljs-keyword">return</span> distance;<br><br><span class="hljs-built_in">delay</span>(<span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考资料：<a href="https://blog.csdn.net/qq_31077649/article/details/72581968">https://blog.csdn.net/qq_31077649&#x2F;article&#x2F;details&#x2F;72581968</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>电子信息</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大学记录（一）</title>
    <link href="/2019/10/18/26/"/>
    <url>/2019/10/18/26/</url>
    
    <content type="html"><![CDATA[<h2 id="牢骚"><a href="#牢骚" class="headerlink" title="牢骚"></a>牢骚</h2><p>从进入大学到现在已经有两个月了，期间我也对大学的生活有了个大概的认识（划水摸鱼打豆豆）emmmmmmmm虽然和假期放假时的想象有些出入，不过随着时间的流逝，也逐渐接受了这个设定。为什么大学好像比高三还累啊喂！！！（大声） 不过，确实大学管的会比较的宽松，有丰富的活动、组织可以凭自己的兴趣与热情去投入，并且也会有一定的收获（不能让自己开心的活动及组织就不用参加了emmm）</p><h2 id="经历"><a href="#经历" class="headerlink" title="经历"></a>经历</h2><p>两个月的时间足够发生许多有趣的事。在得知被黑龙江大学录取后，我就早早的加入了新生群，后来和某学长混熟后加入了一个唠嗑群，里面个个都系人才，suo fa又好听，敲稀饭在里面的惹QwQ。 起初被某乎流行的“大学组织（指社团，学生会等）没必要加，加了也是浪费自己的时间”洗脑，对一些组织也不感冒。 但经过学长的答疑，我了解到了能真正提升自己的校级组织以及大学综测的一些事宜。便在一些机缘巧合之下顺利的进入了今日校园运维中心的易班（为了综测分）。 进入了易班才发现原来不是一个浪费时间的组织，是一个真正能提升自己能力的组织（有点废话？qwq？）。 期间也确实参与举办了有意义的活动，而且学长学姐们也不会刻意为难干事，能很好的相处。起初确实让我有点小小的惊讶，或许之前是我想多了吧hhhhhhh(´∀｀*) <strong>附上一张参加活动时的照片</strong> 说起校级组织就不得不说起学生会了，在我的印象中，是个尖酸刻薄、处处充满着官僚主义的组织（刻版印象 捂脸(〃ﾉωﾉ)。 但在学校待了两个月，也没有听见有人对学生会不满。学生会组织好像也没有整出什么幺蛾子，而且学长也并没有对学生会抱怨什么。这一点学校还是搞得挺好hhh。 突然懒得写了，就先写到这吧以后再更qwq，最后是一些照片。 <img src="http://nanxfu.cn/wp-content/uploads/2019/10/3245235613.jpeg" alt="中央大街" title="中央大街"> <img src="http://nanxfu.cn/wp-content/uploads/2019/10/2011313886.jpg" alt="军训时拍的汇文楼" title="军训时拍的汇文楼"> <img src="http://nanxfu.cn/wp-content/uploads/2019/10/110229539.jpg" alt="哈尔滨的天空" title="哈尔滨的天空"> <img src="http://nanxfu.cn/wp-content/uploads/2019/10/1291298970.jpg" alt="漫展上的猫猫QWQ" title="漫展上的猫猫QWQ"></p>]]></content>
    
    
    <categories>
      
      <category>我的大学</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>区块链是什么鬼</title>
    <link href="/2018/07/24/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC/"/>
    <url>/2018/07/24/%E5%8C%BA%E5%9D%97%E9%93%BE%E6%98%AF%E4%BB%80%E4%B9%88%E9%AC%BC/</url>
    
    <content type="html"><![CDATA[<p>除非你是山顶洞人，我确信你已经听说了比特币（<strong>Bitcoins</strong>）和区块链。毕竟，它们是热点，是这几天媒体最喜欢的话题，也是年度流行词。连那些从来没有听过加密货币（<strong>cryptocurrency</strong>）、根本不知道它如何运行的家伙们也在谈论它。我的朋友中，非技术宅可比技术宅要多。为了让我给他们解释这个新流行词，他们已经骚扰我好几个星期了。我猜，成千上万人跟我有着同样的感受。当这种情形出现，是时候要写一些东西了，好让每个人都能戳醒那些糊涂蛋——这就是这篇推送的目的——以浅白的英文写作，让任何普通的网友都能理解。<br><strong>区块链：为什么我们需要这么复杂的东西？</strong></p><blockquote><p>“每一个复杂的问题都有一个清晰、简单并且是错误的答案。”——H.L.Mencken*</p></blockquote><p><strong>与互联网上的其它任何推送相反</strong>，我们不会一开始就定义什么是区块链，我们会先认识它要解决的问题。</p><p>想象一下，Joe 是你最好的朋友。他正在海外旅游。在他假期的第五天，他给你一个电话，“Dude，我把钱花光了，江湖救急。”<br>你回答”马上汇款“然后挂掉电话。</p><p><strong>-<a href="http://www.forexnewsnow.com/top-stories/bitcoin-2016-summary-2017-forecasts/">http://www.forexnewsnow.com/top-stories/bitcoin-2016-summary-2017-forecasts/</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>计算机相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android本地服务器环境部署</title>
    <link href="/2018/07/22/Android%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    <url>/2018/07/22/Android%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>在Android搭建的灵感最初来自智慧的⑨（鳖），然后经过不断的摸索终于在Android系统上成功搭建个人博客冰实现了内网穿透。</p><p>然后掏出曾经我用来搭博客的洋垃圾….<br><img src="/wp-content/uploads/2018/07/405831247.jpg" alt="IMG_20180723_200201.jpg" title="IMG_20180723_200201.jpg"> <img src="/wp-content/uploads/2018/07/2261203488.jpg" alt="IMG_20180723_200207.jpg" title="IMG_20180723_200207.jpg"> <img src="/wp-content/uploads/2018/07/3548013908.jpg" alt="IMG_20180723_200233.jpg" title="IMG_20180723_200233.jpg"><br>当时因为没钱，就在淘宝上300买了个水货，寄过来乍一眼一看没有大额头，无边框的特征也是惊艳到我了。</p><p>但那个上世纪的UI、难以启齿的导航栏以及负优化系统（贴吧里也有dalao做美化包，用美化包的也挺好看）真的是不敢恭维。。</p><p>不过304SH的洋垃圾配上火龙801 2+32GB在咸鱼上也就100左右就能收，便宜点的70左右，如果捡到砖机，在贴吧里翻翻帖子大部分也能满血复活。</p><p>当作备用机是个很好的选择。</p><hr><h1 id="选择哪种服务器搭建软件？"><a href="#选择哪种服务器搭建软件？" class="headerlink" title="选择哪种服务器搭建软件？"></a>选择哪种服务器搭建软件？</h1><p><strong>a.<em>Androphp</em></strong><br>这个是我用过的服务器搭建软件中最简洁的软件，适合小型的展示型网站。但因为不支持、Nginx、Lightptd。搭建多虚拟服务器就不行了。如果箱底的手机配置比较差<strong>（指划手机的流畅，但日常使用就有点吃力）</strong>的话这款软件也是不错的选择，配置稍微凑合的<strong>（划手机流畅，日常使用还勉强）</strong>就可以抛弃这款了，除非你不喜欢折腾。<br>附上截图<br><img src="/wp-content/uploads/2018/07/4260176773.png" alt="Androphp.png" title="Androphp.png"><img src="/wp-content/uploads/2018/07/2146585494.png" alt="Androphp1.png" title="Androphp1.png"></p><p><strong>b.<em>Ksweb</em></strong><br>这款就是我最终选择用来部署服务器环境的软件了。目前作者还在更新它。软件是收费的，不过百度上也能找到破解版（emmmmmm）相比使用过的几款软件，它的UI设计很棒，以及集成了各种套件。不管是对小白还是对专业人员来说都是个不错的选择。附上截图<br><img src="/wp-content/uploads/2019/02/2368196160.png" alt="官方描述.png" title="官方描述.png"></p>]]></content>
    
    
    <categories>
      
      <category>网站建设</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>PE结构学习</title>
    <link href="/2018/02/21/PE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    <url>/2018/02/21/PE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>参考资料：<br>滴水逆向2015-03-16期。<br>1、PE结构简介<br>本论坛PE的解析的帖子以及教程非常多，我这里只是介绍一下学习的过程与思路，具体的内容还是需要自己去记忆与理解。结合PEtool或者其他的PE解析工具以及下载链接中的PDF文件，首先将pe的每个字段所在位置，整体分布，由一个宏观的把握。PE字段的命名有一定的规律，了解了文件偏移，虚拟地址，相对虚拟地址这些概念之后，一部分字段就可以猜测出含义，部分没有规律的，可以百度。<br>PE文件总览 <a href="https://pan.baidu.com/s/1oAkP0TG">https://pan.baidu.com/s/1oAkP0TG</a> 密码: smxa</p><span id="more"></span><p>2、滴水逆向2015-03-16期课后做业<br>模拟一个PE文件在内存中的加载过程<br>1)、把一个PE文件读入内存缓冲区File-&gt;FileBuffer<br>2)、PE文件的拉伸，FileBuffer-&gt;ImageBuffer<br>3)、PE文件的还原，开辟另一块空间，把ImageBuffer重新还原成文件刚加载进内存时的样子<br>4)、PE文件的转存，把3得到的结果转存为文件，看看是否可以运行</p><p>3、大体思路如下：<br>1)、把一个PE文件读入内存缓冲区File-&gt;FileBuffer<br>首先读取文件大小，根据文件大小开辟缓冲区，把缓冲区初始化0，然后把PE文件代码写入缓冲区，具体函数如下：<br>ReadPEFile</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LPVOID <span class="hljs-title">ReadPEFile</span><span class="hljs-params">(LPSTR lpszFile)</span></span><br><span class="hljs-function"></span>&#123;<br>    FILE *pFile =<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//DWORD fileSize=0;</span><br>    LPVOID pFileBuffer=<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-comment">//打开文件</span><br>    pFile=<span class="hljs-built_in">fopen</span>(lpszFile,<span class="hljs-string">&quot;rb&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!pFile)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;无法打开EXE文件!&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">//读取文件大小</span><br>    <span class="hljs-built_in">fseek</span>(pFile,<span class="hljs-number">0</span>,SEEK_END);<br>    fileSize=<span class="hljs-built_in">ftell</span>(pFile);<br>    <span class="hljs-built_in">fseek</span>(pFile,<span class="hljs-number">0</span>,SEEK_SET);<br>    <span class="hljs-comment">//分配缓冲区</span><br>    pFileBuffer=<span class="hljs-built_in">malloc</span>(fileSize);<br>    <span class="hljs-keyword">if</span> (!pFileBuffer)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;分配空间失败！&quot;</span>);<br>        <span class="hljs-built_in">fclose</span>(pFile);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">//将文件数据读取到缓冲区</span><br>    <span class="hljs-type">size_t</span> n=<span class="hljs-built_in">fread</span>(pFileBuffer,fileSize,<span class="hljs-number">1</span>,pFile);<br>    <span class="hljs-keyword">if</span>(!n)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;读取数据失败！&quot;</span>);<br>        <span class="hljs-built_in">free</span>(pFileBuffer);<br>        <span class="hljs-built_in">fclose</span>(pFile);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">//关闭文件</span><br>    <span class="hljs-built_in">fclose</span>(pFile);<br>    <span class="hljs-keyword">return</span> pFileBuffer;<br>&#125;<br></code></pre></td></tr></table></figure><p>返回指向缓冲区的指针</p><p>2)、PE文件的拉伸<br>拉伸前我们首先需要对PE文件的节表有一点的了解，PE文件的节表为一个结构体，具体如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">typedef struct _IMAGE_SECTION_HEADER &#123;<br>    <span class="hljs-built_in">BYTE</span>    Name[IMAGE_SIZEOF_SHORT_NAME]<span class="hljs-comment">;</span><br>    union &#123;<br>            <span class="hljs-built_in">DWORD</span>   PhysicalAddress<span class="hljs-comment">;</span><br>            <span class="hljs-built_in">DWORD</span>   VirtualSize<span class="hljs-comment">;</span><br>    &#125; Misc<span class="hljs-comment">;</span><br>    <span class="hljs-built_in">DWORD</span>   VirtualAddress<span class="hljs-comment">;    //内存中偏移地址</span><br>    <span class="hljs-built_in">DWORD</span>   SizeOfRawData<span class="hljs-comment">;    //PE文件中对其之后的大小</span><br>    <span class="hljs-built_in">DWORD</span>   PointerToRawData<span class="hljs-comment">;//为PE块区在PE文件中偏移</span><br>    <span class="hljs-built_in">DWORD</span>   PointerToRelocations<span class="hljs-comment">;</span><br>    <span class="hljs-built_in">DWORD</span>   PointerToLinenumbers<span class="hljs-comment">;</span><br>    <span class="hljs-built_in">WORD</span>    NumberOfRelocations<span class="hljs-comment">;</span><br>    <span class="hljs-built_in">WORD</span>    NumberOfLinenumbers<span class="hljs-comment">;</span><br>    <span class="hljs-built_in">DWORD</span>   Characteristics<span class="hljs-comment">;    //块区的属性：可读、可写..</span><br>&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>首先我们要开辟一个新空间，大小为可选PE头中的SizeOfImage这个参数的值，然后一个节一个节的copy过去，FileBuffer中的PointerToRawData对应ImageBuffer中的VirtualAddress，copy的大小为SizeOfRawData，具体函数如下：<br>CopyFileBufferToImageBuffer</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LPVOID <span class="hljs-title">CopyFileBufferToImageBuffer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LPVOID pFileBuffer=<span class="hljs-literal">NULL</span>;<br>    LPVOID pImageBuffer=<span class="hljs-literal">NULL</span>;<br>    PIMAGE_DOS_HEADER pDosHeader=<span class="hljs-literal">NULL</span>;<br>    PIMAGE_NT_HEADERS pNTHeader=<span class="hljs-literal">NULL</span>;<br>    PIMAGE_FILE_HEADER pPEHeader=<span class="hljs-literal">NULL</span>;<br>    PIMAGE_OPTIONAL_HEADER32 pOptionHeader=<span class="hljs-literal">NULL</span>;<br>    PIMAGE_SECTION_HEADER pSectionHeader=<span class="hljs-literal">NULL</span>;<br>    pFileBuffer =<span class="hljs-built_in">ReadPEFile</span>(FILEPATH);<br>    <span class="hljs-keyword">if</span>(!pFileBuffer)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件读取失败\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">//判断是否是有效的MZ标志</span><br>    <span class="hljs-keyword">if</span>(*((PWORD)pFileBuffer)!=IMAGE_DOS_SIGNATURE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不是有效的MZ标志\n&quot;</span>);<br>        <span class="hljs-built_in">free</span>(pFileBuffer);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer;<br> <br>    <span class="hljs-keyword">if</span>(*((PDWORD)((DWORD)pFileBuffer+pDosHeader-&gt;e_lfanew))!=IMAGE_NT_SIGNATURE)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不是有效的PE标志\n&quot;</span>);<br>        <span class="hljs-built_in">free</span>(pFileBuffer);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    pNTHeader=(PIMAGE_NT_HEADERS)((DWORD)pFileBuffer+pDosHeader-&gt;e_lfanew);<br>     <br>    pPEHeader=(PIMAGE_FILE_HEADER)(((DWORD)pNTHeader)<span class="hljs-number">+4</span>);<br>     <br>    <span class="hljs-comment">//可选PE头</span><br>    pOptionHeader=(PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader+IMAGE_SIZEOF_FILE_HEADER);<br>    pImageBuffer=<span class="hljs-built_in">malloc</span>(pOptionHeader-&gt;SizeOfImage);<br>    <span class="hljs-comment">//初始化新空间</span><br>    <span class="hljs-built_in">memset</span>(pImageBuffer,<span class="hljs-number">0</span>,pOptionHeader-&gt;SizeOfImage);<br>    <span class="hljs-comment">//copy头文件到新空间</span><br>    <span class="hljs-built_in">memcpy</span>(pImageBuffer,pFileBuffer,pOptionHeader-&gt;SizeOfHeaders);<br>    pSectionHeader=(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader+pPEHeader-&gt;SizeOfOptionalHeader);<br> <br>    <span class="hljs-comment">//copy节</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;pPEHeader-&gt;NumberOfSections;i++,pSectionHeader++)<br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span>*)((DWORD)pImageBuffer+pSectionHeader-&gt;VirtualAddress),<br>            (<span class="hljs-type">void</span>*)((DWORD)pDosHeader+pSectionHeader-&gt;PointerToRawData),pSectionHeader-&gt;SizeOfRawData);<br>     <br>    &#125;<br>    <span class="hljs-comment">//返回pImageBuffer</span><br>    <span class="hljs-keyword">return</span> pImageBuffer;<br>&#125;<br></code></pre></td></tr></table></figure><p>3)、PE文件的还原和保存<br>这一个没什么好说的，第二步的逆过程，直接上代码<br>CopyImageBufferToNewBuffer</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">LPVOID <span class="hljs-title">CopyImageBufferToNewBuffer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LPVOID pImageBuffer=<span class="hljs-literal">NULL</span>;<br>    LPVOID pNewBuffer=<span class="hljs-literal">NULL</span>;<br>    PIMAGE_DOS_HEADER pDosHeader=<span class="hljs-literal">NULL</span>;<br>    PIMAGE_NT_HEADERS pNTHeader=<span class="hljs-literal">NULL</span>;<br>    PIMAGE_FILE_HEADER pPEHeader=<span class="hljs-literal">NULL</span>;<br>    PIMAGE_OPTIONAL_HEADER32 pOptionHeader=<span class="hljs-literal">NULL</span>;<br>    PIMAGE_SECTION_HEADER pSectionHeader=<span class="hljs-literal">NULL</span>;<br>    FILE *pFile =<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-type">char</span> *FILEPATH1=<span class="hljs-string">&quot;c:\\NOTEPAD1.EXE&quot;</span>;<br> <br>    pImageBuffer =<span class="hljs-built_in">CopyFileBufferToImageBuffer</span>();<br>    pNewBuffer=<span class="hljs-built_in">malloc</span>(fileSize);<br>    <span class="hljs-comment">//初始化NewBuffer</span><br>    <span class="hljs-built_in">memset</span>(pNewBuffer,<span class="hljs-number">0</span>,fileSize);<br> <br>    pDosHeader=(PIMAGE_DOS_HEADER)pImageBuffer;<br>    pNTHeader=(PIMAGE_NT_HEADERS)((DWORD)pDosHeader+pDosHeader-&gt;e_lfanew );<br>    pPEHeader=(PIMAGE_FILE_HEADER)(((DWORD)pNTHeader)<span class="hljs-number">+4</span>);<br>    pOptionHeader=(PIMAGE_OPTIONAL_HEADER32)((DWORD)pPEHeader+IMAGE_SIZEOF_FILE_HEADER);<br>    <span class="hljs-built_in">memcpy</span>(pNewBuffer,pImageBuffer,pOptionHeader-&gt;SizeOfHeaders);<br>    pSectionHeader=(PIMAGE_SECTION_HEADER)((DWORD)pOptionHeader+pPEHeader-&gt;SizeOfOptionalHeader);<br>    <span class="hljs-comment">//copy 节</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;pPEHeader-&gt;NumberOfSections;i++,pSectionHeader++)<br>    &#123;<br>        <span class="hljs-built_in">memcpy</span>((<span class="hljs-type">void</span>*)((DWORD)pNewBuffer+pSectionHeader-&gt;PointerToRawData),<br>            (<span class="hljs-type">void</span>*)((DWORD)pImageBuffer+pSectionHeader-&gt;VirtualAddress),pSectionHeader-&gt;SizeOfRawData);<br>    &#125;<br>    pFile=<span class="hljs-built_in">fopen</span>(FILEPATH1,<span class="hljs-string">&quot;wb&quot;</span>);<br>    <span class="hljs-built_in">fwrite</span>(pNewBuffer,fileSize,<span class="hljs-number">1</span>,pFile);<br> <br>    <span class="hljs-built_in">fclose</span>(pFile);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>计算机科学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PE文件</tag>
      
      <tag>汇编</tag>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何搭建私人网站（草草</title>
    <link href="/2018/02/11/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E7%BD%91%E7%AB%99/"/>
    <url>/2018/02/11/%E5%A6%82%E4%BD%95%E6%90%AD%E5%BB%BA%E7%A7%81%E4%BA%BA%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>前言：</p><p>富人靠科技，屌丝靠变异。</p><p><strong>&amp;</strong> 曾经我根本没有多余的钱（现在也没有qwq..）租用一台合适服务器且就算拥有了一台服务器，无期限的续费会使我陷入恐慌。不过恰好那段时间我攒出了一笔小钱。便花450RMB购置了一台魅族PRO5，于是那台304SH洋垃圾就当作备用机使用了。</p><p><strong>&amp;</strong> 在机缘巧合以及来自智慧的⑨用诺基亚搭服务器的先例下便想既然诺基亚都能跑Python运行服务器环境，那么为何不在比Symbian更强大的android环境下跑服务器环境呢？于是在收集了各博主提供的资料后，自己摸索出了比较大众的网站搭建方式。</p><p><strong>&amp;</strong> 本系列的文章适用范围广，对计算机了解需求门槛低，偏科普向。</p><hr><h2 id="Android部署服务器环境请走"><a href="#Android部署服务器环境请走" class="headerlink" title="Android部署服务器环境请走"></a>Android部署服务器环境请走</h2><p><a href="/index.php/archives/8/">a.Android本地服务器环境部署</a></p><h2 id="PC部署服务器环境请走"><a href="#PC部署服务器环境请走" class="headerlink" title="PC部署服务器环境请走"></a>PC部署服务器环境请走</h2><p>a.PC端本地服务器环境部署（基于windows系统</p><hr><blockquote><p><strong>参考资料</strong>：_<a href="https://blog.csdn.net/zangker/article/details/71036270">https://blog.csdn.net/zangker/article/details/71036270</a>_</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网站建设</category>
      
      <category>浮生六记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
